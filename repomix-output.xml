This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.changeset/
  config.json
  README.md
.github/
  ansible/
    deploy.yml
  workflows/
    storybook.yml
.husky/
  pre-commit
examples/
  mini-app/
    .loki/
      .gitignore
    .storybook/
      main.ts
      preview.tsx
      vitest.setup.ts
    public/
      vite.svg
    src/
      assets/
        game/
          game-result/
            loss-icon.svg
            win-icon.svg
        react.svg
      components/
        game/
          CoinTossGame.stories.tsx
          CoinTossGame.tsx
          GameFrame.stories.tsx
          GameFrame.tsx
          GameResultWindow.stories.tsx
          GameResultWindow.tsx
          HistorySheetPanel.stories.tsx
          HistorySheetPanel.tsx
          InfoSheetPanel.stories.tsx
          InfoSheetPanel.tsx
        ui/
          button.stories.tsx
          button.tsx
          card.stories.tsx
          card.tsx
          input.stories.tsx
          input.tsx
          label.tsx
          scroll-area.tsx
          sheet.tsx
          slider.stories.tsx
          slider.tsx
          table.tsx
      context/
        BettingConfigContext.tsx
        useBettingConfig.ts
      hooks/
        types.ts
        useBetResultWatcher.ts
        usePlaceBet.ts
      lib/
        logger.ts
        tokens.ts
        utils.ts
      stories/
        assets/
          accessibility.svg
          discord.svg
          github.svg
          tutorials.svg
          youtube.svg
        Configure.mdx
      App.css
      App.tsx
      index.css
      index.ts
      main.tsx
      providers.tsx
      types.ts
      vite-env.d.ts
    .gitignore
    .prettierrc
    components.json
    eslint.config.js
    index.html
    package.json
    README.md
    tailwind.config.js
    tsconfig.app.json
    tsconfig.json
    tsconfig.node.json
    vite.config.ts
    vitest.workspace.ts
  node/
    src/
      functionalities/
        placeBet.ts
        showHistoryBets.ts
      index.ts
    .env.example
    package.json
    README.md
    tsconfig.json
    utils.ts
packages/
  core/
    src/
      abis/
        v2/
          casino/
            bank.ts
            cointoss.ts
            dice.ts
            game.ts
            keno.ts
            roulette.ts
            weightedGame.ts
          index.ts
        index.ts
      actions/
        casino/
          cointoss.ts
          dice.ts
          game.ts
          keno.ts
          roulette.ts
          weightedGame.ts
          wheel.ts
        common/
          approve.ts
        index.ts
      data/
        subgraphs/
          protocol/
            clients/
              bet.ts
              common.ts
              index.ts
              token.ts
            documents/
              fragments/
                bet.graphql
                token.graphql
              bet.graphql
              bets.graphql
              token.graphql
              tokens.graphql
            index.ts
        casino.ts
        chains.ts
        index.ts
        tokens.ts
      entities/
        casino/
          cointoss.ts
          dice.ts
          game.ts
          keno.ts
          roulette.ts
          weightedGame.ts
          wheel.ts
        index.ts
      errors/
        betSwirlError.ts
        codes.ts
        index.ts
        types.ts
      provider/
        client.ts
        index.ts
        viemClient.ts
        viemWallet.ts
        wallet.ts
      read/
        casino/
          bank.ts
          cointoss.ts
          dice.ts
          game.ts
          keno.ts
          roulette.ts
          weightedGame.ts
          wheel.ts
        common/
          chainlinkVrfCost.ts
          gasPrice.ts
          tokenMetadata.ts
        index.ts
      utils/
        bet.ts
        chains.ts
        format.ts
        index.ts
        subgraphs.ts
        tokens.ts
        wallet.ts
      constants.ts
      index.ts
      interfaces.ts
    CHANGELOG.md
    codegen.ts
    package.json
    README.md
    tsconfig.build.json
    tsconfig.json
    tsup.config.ts
    turbo.json
  providers/
    wagmi/
      src/
        client.ts
        index.ts
        wallet.ts
      CHANGELOG.md
      package.json
      README.md
      tsconfig.build.json
      tsconfig.json
      tsup.config.ts
      turbo.json
.gitignore
betswirl.code-workspace
biome.json
package.json
pnpm-workspace.yaml
README.md
tsconfig.base.json
turbo.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".changeset/README.md">
# Changesets

Hello and welcome! This folder has been automatically generated by `@changesets/cli`, a build tool that works
with multi-package repos, or single-package repos to help you version and publish your code. You can
find the full documentation for it [in our repository](https://github.com/changesets/changesets)

We have a quick list of common questions to get you started engaging with this project in
[our documentation](https://github.com/changesets/changesets/blob/main/docs/common-questions.md)
</file>

<file path="examples/mini-app/public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="examples/mini-app/src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="examples/mini-app/src/stories/assets/accessibility.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" fill="none" viewBox="0 0 48 48"><title>Accessibility</title><circle cx="24.334" cy="24" r="24" fill="#A849FF" fill-opacity=".3"/><path fill="#A470D5" fill-rule="evenodd" d="M27.8609 11.585C27.8609 9.59506 26.2497 7.99023 24.2519 7.99023C22.254 7.99023 20.6429 9.65925 20.6429 11.585C20.6429 13.575 22.254 15.1799 24.2519 15.1799C26.2497 15.1799 27.8609 13.575 27.8609 11.585ZM21.8922 22.6473C21.8467 23.9096 21.7901 25.4788 21.5897 26.2771C20.9853 29.0462 17.7348 36.3314 17.3325 37.2275C17.1891 37.4923 17.1077 37.7955 17.1077 38.1178C17.1077 39.1519 17.946 39.9902 18.9802 39.9902C19.6587 39.9902 20.253 39.6293 20.5814 39.0889L20.6429 38.9874L24.2841 31.22C24.2841 31.22 27.5529 37.9214 27.9238 38.6591C28.2948 39.3967 28.8709 39.9902 29.7168 39.9902C30.751 39.9902 31.5893 39.1519 31.5893 38.1178C31.5893 37.7951 31.3639 37.2265 31.3639 37.2265C30.9581 36.3258 27.698 29.0452 27.0938 26.2771C26.8975 25.4948 26.847 23.9722 26.8056 22.7236C26.7927 22.333 26.7806 21.9693 26.7653 21.6634C26.7008 21.214 27.0231 20.8289 27.4097 20.7005L35.3366 18.3253C36.3033 18.0685 36.8834 16.9773 36.6256 16.0144C36.3678 15.0515 35.2722 14.4737 34.3055 14.7305C34.3055 14.7305 26.8619 17.1057 24.2841 17.1057C21.7062 17.1057 14.456 14.7947 14.456 14.7947C13.4893 14.5379 12.3937 14.9873 12.0715 15.9502C11.7493 16.9131 12.3293 18.0044 13.3604 18.3253L21.2873 20.7005C21.674 20.8289 21.9318 21.214 21.9318 21.6634C21.9174 21.9493 21.9053 22.2857 21.8922 22.6473Z" clip-rule="evenodd"/></svg>
</file>

<file path="examples/mini-app/src/stories/assets/discord.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="33" height="32" fill="none" viewBox="0 0 33 32"><g clip-path="url(#clip0_10031_177575)"><mask id="mask0_10031_177575" style="mask-type:luminance" width="33" height="25" x="0" y="4" maskUnits="userSpaceOnUse"><path fill="#fff" d="M32.5034 4.00195H0.503906V28.7758H32.5034V4.00195Z"/></mask><g mask="url(#mask0_10031_177575)"><path fill="#5865F2" d="M27.5928 6.20817C25.5533 5.27289 23.3662 4.58382 21.0794 4.18916C21.0378 4.18154 20.9962 4.20057 20.9747 4.23864C20.6935 4.73863 20.3819 5.3909 20.1637 5.90358C17.7042 5.53558 15.2573 5.53558 12.8481 5.90358C12.6299 5.37951 12.307 4.73863 12.0245 4.23864C12.003 4.20184 11.9614 4.18281 11.9198 4.18916C9.63431 4.58255 7.44721 5.27163 5.40641 6.20817C5.38874 6.21578 5.3736 6.22848 5.36355 6.24497C1.21508 12.439 0.078646 18.4809 0.636144 24.4478C0.638667 24.477 0.655064 24.5049 0.677768 24.5227C3.41481 26.5315 6.06609 27.7511 8.66815 28.5594C8.70979 28.5721 8.75392 28.5569 8.78042 28.5226C9.39594 27.6826 9.94461 26.7968 10.4151 25.8653C10.4428 25.8107 10.4163 25.746 10.3596 25.7244C9.48927 25.3945 8.66058 24.9922 7.86343 24.5354C7.80038 24.4986 7.79533 24.4084 7.85333 24.3653C8.02108 24.2397 8.18888 24.109 8.34906 23.977C8.37804 23.9529 8.41842 23.9478 8.45249 23.963C13.6894 26.3526 19.359 26.3526 24.5341 23.963C24.5682 23.9465 24.6086 23.9516 24.6388 23.9757C24.799 24.1077 24.9668 24.2397 25.1358 24.3653C25.1938 24.4084 25.19 24.4986 25.127 24.5354C24.3298 25.0011 23.5011 25.3945 22.6296 25.7232C22.5728 25.7447 22.5476 25.8107 22.5754 25.8653C23.0559 26.7955 23.6046 27.6812 24.2087 28.5213C24.234 28.5569 24.2794 28.5721 24.321 28.5594C26.9357 27.7511 29.5869 26.5315 32.324 24.5227C32.348 24.5049 32.3631 24.4783 32.3656 24.4491C33.0328 17.5506 31.2481 11.5584 27.6344 6.24623C27.6256 6.22848 27.6105 6.21578 27.5928 6.20817ZM11.1971 20.8146C9.62043 20.8146 8.32129 19.3679 8.32129 17.5913C8.32129 15.8146 9.59523 14.368 11.1971 14.368C12.8115 14.368 14.0981 15.8273 14.0729 17.5913C14.0729 19.3679 12.7989 20.8146 11.1971 20.8146ZM21.8299 20.8146C20.2533 20.8146 18.9541 19.3679 18.9541 17.5913C18.9541 15.8146 20.228 14.368 21.8299 14.368C23.4444 14.368 24.7309 15.8273 24.7057 17.5913C24.7057 19.3679 23.4444 20.8146 21.8299 20.8146Z"/></g></g><defs><clipPath id="clip0_10031_177575"><rect width="32" height="32" fill="#fff" transform="translate(0.5)"/></clipPath></defs></svg>
</file>

<file path="examples/mini-app/src/stories/assets/github.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="none" viewBox="0 0 32 32"><path fill="#161614" d="M16.0001 0C7.16466 0 0 7.17472 0 16.0256C0 23.1061 4.58452 29.1131 10.9419 31.2322C11.7415 31.3805 12.0351 30.8845 12.0351 30.4613C12.0351 30.0791 12.0202 28.8167 12.0133 27.4776C7.56209 28.447 6.62283 25.5868 6.62283 25.5868C5.89499 23.7345 4.8463 23.2419 4.8463 23.2419C3.39461 22.2473 4.95573 22.2678 4.95573 22.2678C6.56242 22.3808 7.40842 23.9192 7.40842 23.9192C8.83547 26.3691 11.1514 25.6609 12.0645 25.2514C12.2081 24.2156 12.6227 23.5087 13.0803 23.1085C9.52648 22.7032 5.7906 21.3291 5.7906 15.1886C5.7906 13.4389 6.41563 12.0094 7.43916 10.8871C7.27303 10.4834 6.72537 8.85349 7.59415 6.64609C7.59415 6.64609 8.93774 6.21539 11.9953 8.28877C13.2716 7.9337 14.6404 7.75563 16.0001 7.74953C17.3599 7.75563 18.7297 7.9337 20.0084 8.28877C23.0623 6.21539 24.404 6.64609 24.404 6.64609C25.2749 8.85349 24.727 10.4834 24.5608 10.8871C25.5868 12.0094 26.2075 13.4389 26.2075 15.1886C26.2075 21.3437 22.4645 22.699 18.9017 23.0957C19.4756 23.593 19.9869 24.5683 19.9869 26.0634C19.9869 28.2077 19.9684 29.9334 19.9684 30.4613C19.9684 30.8877 20.2564 31.3874 21.0674 31.2301C27.4213 29.1086 32 23.1037 32 16.0256C32 7.17472 24.8364 0 16.0001 0ZM5.99257 22.8288C5.95733 22.9084 5.83227 22.9322 5.71834 22.8776C5.60229 22.8253 5.53711 22.7168 5.57474 22.6369C5.60918 22.5549 5.7345 22.5321 5.85029 22.587C5.9666 22.6393 6.03284 22.7489 5.99257 22.8288ZM6.7796 23.5321C6.70329 23.603 6.55412 23.5701 6.45291 23.4581C6.34825 23.3464 6.32864 23.197 6.40601 23.125C6.4847 23.0542 6.62937 23.0874 6.73429 23.1991C6.83895 23.3121 6.85935 23.4605 6.7796 23.5321ZM7.31953 24.4321C7.2215 24.5003 7.0612 24.4363 6.96211 24.2938C6.86407 24.1513 6.86407 23.9804 6.96422 23.9119C7.06358 23.8435 7.2215 23.905 7.32191 24.0465C7.41968 24.1914 7.41968 24.3623 7.31953 24.4321ZM8.23267 25.4743C8.14497 25.5712 7.95818 25.5452 7.82146 25.413C7.68156 25.2838 7.64261 25.1004 7.73058 25.0035C7.81934 24.9064 8.00719 24.9337 8.14497 25.0648C8.28381 25.1938 8.3262 25.3785 8.23267 25.4743ZM9.41281 25.8262C9.37413 25.9517 9.19423 26.0088 9.013 25.9554C8.83203 25.9005 8.7136 25.7535 8.75016 25.6266C8.78778 25.5003 8.96848 25.4408 9.15104 25.4979C9.33174 25.5526 9.45044 25.6985 9.41281 25.8262ZM10.7559 25.9754C10.7604 26.1076 10.6067 26.2172 10.4165 26.2196C10.2252 26.2238 10.0704 26.1169 10.0683 25.9868C10.0683 25.8534 10.2185 25.7448 10.4098 25.7416C10.6001 25.7379 10.7559 25.8441 10.7559 25.9754ZM12.0753 25.9248C12.0981 26.0537 11.9658 26.1862 11.7769 26.2215C11.5912 26.2554 11.4192 26.1758 11.3957 26.0479C11.3726 25.9157 11.5072 25.7833 11.6927 25.7491C11.8819 25.7162 12.0512 25.7937 12.0753 25.9248Z"/></svg>
</file>

<file path="examples/mini-app/src/stories/assets/tutorials.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="33" height="32" fill="none" viewBox="0 0 33 32"><g clip-path="url(#clip0_10031_177597)"><path fill="#B7F0EF" fill-rule="evenodd" d="M17 7.87059C17 6.48214 17.9812 5.28722 19.3431 5.01709L29.5249 2.99755C31.3238 2.64076 33 4.01717 33 5.85105V22.1344C33 23.5229 32.0188 24.7178 30.6569 24.9879L20.4751 27.0074C18.6762 27.3642 17 25.9878 17 24.1539L17 7.87059Z" clip-rule="evenodd" opacity=".7"/><path fill="#87E6E5" fill-rule="evenodd" d="M1 5.85245C1 4.01857 2.67623 2.64215 4.47507 2.99895L14.6569 5.01848C16.0188 5.28861 17 6.48354 17 7.87198V24.1553C17 25.9892 15.3238 27.3656 13.5249 27.0088L3.34311 24.9893C1.98119 24.7192 1 23.5242 1 22.1358V5.85245Z" clip-rule="evenodd"/><path fill="#61C1FD" fill-rule="evenodd" d="M15.543 5.71289C15.543 5.71289 16.8157 5.96289 17.4002 6.57653C17.9847 7.19016 18.4521 9.03107 18.4521 9.03107C18.4521 9.03107 18.4521 25.1106 18.4521 26.9629C18.4521 28.8152 19.3775 31.4174 19.3775 31.4174L17.4002 28.8947L16.2575 31.4174C16.2575 31.4174 15.543 29.0765 15.543 27.122C15.543 25.1674 15.543 5.71289 15.543 5.71289Z" clip-rule="evenodd"/></g><defs><clipPath id="clip0_10031_177597"><rect width="32" height="32" fill="#fff" transform="translate(0.5)"/></clipPath></defs></svg>
</file>

<file path="examples/mini-app/src/stories/assets/youtube.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="none" viewBox="0 0 32 32"><path fill="#ED1D24" d="M31.3313 8.44657C30.9633 7.08998 29.8791 6.02172 28.5022 5.65916C26.0067 5.00026 16 5.00026 16 5.00026C16 5.00026 5.99333 5.00026 3.4978 5.65916C2.12102 6.02172 1.03665 7.08998 0.668678 8.44657C0 10.9053 0 16.0353 0 16.0353C0 16.0353 0 21.1652 0.668678 23.6242C1.03665 24.9806 2.12102 26.0489 3.4978 26.4116C5.99333 27.0703 16 27.0703 16 27.0703C16 27.0703 26.0067 27.0703 28.5022 26.4116C29.8791 26.0489 30.9633 24.9806 31.3313 23.6242C32 21.1652 32 16.0353 32 16.0353C32 16.0353 32 10.9053 31.3313 8.44657Z"/><path fill="#fff" d="M12.7266 20.6934L21.0902 16.036L12.7266 11.3781V20.6934Z"/></svg>
</file>

<file path="examples/mini-app/src/App.css">
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}
</file>

<file path="examples/mini-app/src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="examples/mini-app/.prettierrc">
{
  "semi": false,
  "trailingComma": "all"
}
</file>

<file path="examples/mini-app/components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/index.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="examples/mini-app/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="examples/mini-app/tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"],
  "baseUrl": ".",
  "paths": {
    "@/*": ["./src/*"]
  }
}
</file>

<file path="examples/mini-app/tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ],
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  }
}
</file>

<file path="examples/mini-app/tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="examples/node/src/index.ts">
import { select } from "@inquirer/prompts";
import * as dotenv from "dotenv";
import { startPlaceBetProcess } from "./functionalities/placeBet";
import { startShowHistoryBetsProcess } from "./functionalities/showHistoryBets";
dotenv.config();

// Main Menu
const showMenu = async () => {
  const answer = await select({
    message: "What do you want to do?",
    loop: false,
    choices: [
      {
        name: "Place a bet",
        value: "place_bet",
      },
      {
        name: "Show my previous bets",
        value: "previous_bets",
      },
      {
        name: "Quit",
        value: "quit",
      },
    ],
  });

  switch (answer) {
    case "place_bet":
      await startPlaceBetProcess();
      break;
    case "previous_bets":
      await startShowHistoryBetsProcess();
      break;
    case "quit":
      console.log("Bye!");
      process.exit(0);
      break;
    default:
      console.log("Invalid choice, please try again.");
      await showMenu();
  }
  await showMenu();
};

async function main() {
  try {
    console.log("🎲 Welcome to BetSwirl Node example! 🎲\n");
    await showMenu();
  } catch (error) {
    console.error("An error occured:", error);
    process.exit(1);
  }
}

main();
</file>

<file path="examples/node/.env.example">
# === REQUIRED ===
# The private key of the account that will be used to place bets. 
PRIVATE_KEY="0x..."
# === OPTIONAL ===
# The RPC URL of the chain you will select while playing. It uses a public one per default.
RPC_URL="https://mainnet.example.com"
# The GraphQL key that will be used to fetch the subgraphs. You can generate one here: https://thegraph.com/studio/apikeys/.
# It uses a rate limited query URL by default.
GRAPHQL_KEY="123..."
</file>

<file path="examples/node/README.md">
# Node CLI example

This example shows how to use most of the features of the **betswirl/sdk-core** package. This is a good example to check if you want to use the sdk in a server application.

## Installation

```bash
pnpm install
```

## Run the app

### Environment variables

Create a `.env` file in the root of the project and add the following variables:

```bash
PRIVATE_KEY="0x..."
```

### Commands

```bash
npm run start
```

## Preview

![Preview](images/demo.gif)
</file>

<file path="examples/node/tsconfig.json">
{
  "extends": "../../tsconfig.base.json",
  "include": ["./**/*.ts"],
  "exclude": [],
  "compilerOptions": {
    "types": ["node"]
  }
}
</file>

<file path="examples/node/utils.ts">
import { type CasinoChain } from "@betswirl/sdk-core";
import { createConfig, webSocket } from "@wagmi/core";
import { http, type Hex, createPublicClient, createWalletClient } from "viem";
import { privateKeyToAccount } from "viem/accounts";

export function getWagmiConfigFromCasinoChain(casinoChain: CasinoChain) {
  return createConfig({
    chains: [casinoChain.viemChain],

    client: () => {
      return getViemClientsFromCasinoChain(casinoChain).walletClient;
    },
  });
}

export function getViemClientsFromCasinoChain(casinoChain: CasinoChain) {
  const privateKey = process.env.PRIVATE_KEY;
  const rpcUrl = process.env.RPC_URL;
  const account = privateKeyToAccount(privateKey as Hex);
  const transport = rpcUrl?.startsWith("wss") ? webSocket(rpcUrl) : http(rpcUrl);
  const walletClient = createWalletClient({
    chain: casinoChain.viemChain,
    transport,
    account,
  });
  const publicClient = createPublicClient({
    chain: casinoChain.viemChain,
    transport,
  });
  return { walletClient, publicClient };
}

export function checkEnvVariables() {
  if (!process.env.PRIVATE_KEY) {
    console.error("❌ PRIVATE_KEY is not set in .env file ❌");
    process.exit(1);
  }
}
</file>

<file path="packages/core/src/abis/v2/casino/bank.ts">
export const bankAbi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "treasuryAddress",
        type: "address",
      },
      {
        internalType: "address",
        name: "teamWalletAddress",
        type: "address",
      },
      {
        internalType: "address",
        name: "wrappedGasToken",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "maxCallGas_",
        type: "uint256",
      },
    ],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  {
    inputs: [],
    name: "AccessDenied",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidAddress",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidParam",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidValue",
    type: "error",
  },
  {
    inputs: [],
    name: "TokenExists",
    type: "error",
  },
  {
    inputs: [],
    name: "TokenHasPendingBets",
    type: "error",
  },
  {
    inputs: [],
    name: "TokenNotExists",
    type: "error",
  },
  {
    inputs: [],
    name: "TokenNotPaused",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "uint16",
        name: "splitSum",
        type: "uint16",
      },
    ],
    name: "WrongHouseEdgeSplit",
    type: "error",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "bool",
        name: "added",
        type: "bool",
      },
    ],
    name: "AddToken",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "affiliateAmount",
        type: "uint256",
      },
    ],
    name: "AffiliateRevenuesDistribution",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "bank",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "dividend",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "treasury",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "team",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "affiliate",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "address",
        name: "affiliateAddress",
        type: "address",
      },
    ],
    name: "AllocateHouseEdgeAmount",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newBalance",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "CashIn",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "Deposit",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newBalance",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "profit",
        type: "uint256",
      },
    ],
    name: "Payout",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "treasuryAmount",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "teamAmount",
        type: "uint256",
      },
    ],
    name: "ProtocolRevenuesDistribution",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32",
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32",
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32",
      },
    ],
    name: "RoleAdminChanged",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32",
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address",
      },
    ],
    name: "RoleGranted",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "role",
        type: "bytes32",
      },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address",
      },
    ],
    name: "RoleRevoked",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "bool",
        name: "allowed",
        type: "bool",
      },
    ],
    name: "SetAllowedToken",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "previousBalanceRisk",
        type: "uint16",
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "balanceRisk",
        type: "uint16",
      },
    ],
    name: "SetBalanceRisk",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "previousMaxCallGas",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "maxCallGas",
        type: "uint256",
      },
    ],
    name: "SetMaxCallGas",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "bool",
        name: "paused",
        type: "bool",
      },
    ],
    name: "SetPausedToken",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "previousTeamWallet",
        type: "address",
      },
      {
        indexed: false,
        internalType: "address",
        name: "teamWallet",
        type: "address",
      },
    ],
    name: "SetTeamWallet",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "bank",
        type: "uint16",
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "dividend",
        type: "uint16",
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "affiliate",
        type: "uint16",
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "treasury",
        type: "uint16",
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "team",
        type: "uint16",
      },
    ],
    name: "SetTokenHouseEdgeSplit",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "address",
        name: "previousBankrollProvider",
        type: "address",
      },
      {
        indexed: false,
        internalType: "address",
        name: "bankrollProvider",
        type: "address",
      },
    ],
    name: "TokenBankrollProviderTransferAccepted",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "address",
        name: "newBankrollProvider",
        type: "address",
      },
    ],
    name: "TokenBankrollProviderTransferStarted",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address",
      },
    ],
    name: "Withdraw",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "WithdrawDividend",
    type: "event",
  },
  {
    inputs: [],
    name: "DEFAULT_ADMIN_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "DIVIDEND_MANAGER_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "GAME_ROLE",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "TREASURY_WALLET",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "WRAPPED",
    outputs: [
      {
        internalType: "contract IWrapped",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
    ],
    name: "acceptTokenBankrollProviderTransfer",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "bool",
        name: "added",
        type: "bool",
      },
    ],
    name: "addToken",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    name: "affiliateAmounts",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "tokenAddress",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "fees",
        type: "uint256",
      },
      {
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
    ],
    name: "cashIn",
    outputs: [],
    stateMutability: "payable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "deposit",
    outputs: [],
    stateMutability: "payable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
    ],
    name: "getBalance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
    ],
    name: "getBankrollProvider",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "tokenAddress",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "multiplier",
        type: "uint256",
      },
    ],
    name: "getBetRequirements",
    outputs: [
      {
        internalType: "bool",
        name: "isAllowedToken",
        type: "bool",
      },
      {
        internalType: "uint256",
        name: "maxBetAmount",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "maxBetCount",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "multiplier",
        type: "uint256",
      },
    ],
    name: "getMaxBetAmount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "multiplier",
        type: "uint256",
      },
    ],
    name: "getMaxBetCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32",
      },
    ],
    name: "getRoleAdmin",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32",
      },
      {
        internalType: "uint256",
        name: "index",
        type: "uint256",
      },
    ],
    name: "getRoleMember",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32",
      },
    ],
    name: "getRoleMemberCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "getTokens",
    outputs: [
      {
        components: [
          {
            internalType: "uint8",
            name: "decimals",
            type: "uint8",
          },
          {
            internalType: "address",
            name: "tokenAddress",
            type: "address",
          },
          {
            internalType: "string",
            name: "name",
            type: "string",
          },
          {
            internalType: "string",
            name: "symbol",
            type: "string",
          },
          {
            components: [
              {
                internalType: "bool",
                name: "allowed",
                type: "bool",
              },
              {
                internalType: "bool",
                name: "paused",
                type: "bool",
              },
              {
                internalType: "uint16",
                name: "balanceRisk",
                type: "uint16",
              },
              {
                internalType: "address",
                name: "bankrollProvider",
                type: "address",
              },
              {
                internalType: "address",
                name: "pendingBankrollProvider",
                type: "address",
              },
              {
                components: [
                  {
                    internalType: "uint16",
                    name: "bank",
                    type: "uint16",
                  },
                  {
                    internalType: "uint16",
                    name: "dividend",
                    type: "uint16",
                  },
                  {
                    internalType: "uint16",
                    name: "affiliate",
                    type: "uint16",
                  },
                  {
                    internalType: "uint16",
                    name: "treasury",
                    type: "uint16",
                  },
                  {
                    internalType: "uint16",
                    name: "team",
                    type: "uint16",
                  },
                  {
                    internalType: "uint256",
                    name: "dividendAmount",
                    type: "uint256",
                  },
                  {
                    internalType: "uint256",
                    name: "affiliateAmount",
                    type: "uint256",
                  },
                  {
                    internalType: "uint256",
                    name: "treasuryAmount",
                    type: "uint256",
                  },
                  {
                    internalType: "uint256",
                    name: "teamAmount",
                    type: "uint256",
                  },
                ],
                internalType: "struct IBankAdmin.HouseEdgeSplitAndAllocation",
                name: "houseEdgeSplitAndAllocation",
                type: "tuple",
              },
            ],
            internalType: "struct IBankAdmin.Token",
            name: "token",
            type: "tuple",
          },
        ],
        internalType: "struct IBankAdmin.TokenMetadata[]",
        name: "",
        type: "tuple[]",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32",
      },
      {
        internalType: "address",
        name: "account",
        type: "address",
      },
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32",
      },
      {
        internalType: "address",
        name: "account",
        type: "address",
      },
    ],
    name: "hasRole",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "maxCallGas",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "user",
        type: "address",
      },
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "profit",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "fees",
        type: "uint256",
      },
      {
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
    ],
    name: "payout",
    outputs: [],
    stateMutability: "payable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32",
      },
      {
        internalType: "address",
        name: "account",
        type: "address",
      },
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "role",
        type: "bytes32",
      },
      {
        internalType: "address",
        name: "account",
        type: "address",
      },
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "bool",
        name: "allowed",
        type: "bool",
      },
    ],
    name: "setAllowedToken",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint16",
        name: "balanceRisk",
        type: "uint16",
      },
    ],
    name: "setBalanceRisk",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint16",
        name: "bank",
        type: "uint16",
      },
      {
        internalType: "uint16",
        name: "dividend",
        type: "uint16",
      },
      {
        internalType: "uint16",
        name: "affiliate",
        type: "uint16",
      },
      {
        internalType: "uint16",
        name: "treasury",
        type: "uint16",
      },
      {
        internalType: "uint16",
        name: "team",
        type: "uint16",
      },
    ],
    name: "setHouseEdgeSplit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "maxCallGas_",
        type: "uint256",
      },
    ],
    name: "setMaxCallGas",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "bool",
        name: "paused",
        type: "bool",
      },
    ],
    name: "setPausedToken",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "teamWallet_",
        type: "address",
      },
    ],
    name: "setTeamWallet",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
    ],
    name: "setTokenBankrollProviderTransfer",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4",
      },
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "teamWallet",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    name: "tokens",
    outputs: [
      {
        internalType: "bool",
        name: "allowed",
        type: "bool",
      },
      {
        internalType: "bool",
        name: "paused",
        type: "bool",
      },
      {
        internalType: "uint16",
        name: "balanceRisk",
        type: "uint16",
      },
      {
        internalType: "address",
        name: "bankrollProvider",
        type: "address",
      },
      {
        internalType: "address",
        name: "pendingBankrollProvider",
        type: "address",
      },
      {
        components: [
          {
            internalType: "uint16",
            name: "bank",
            type: "uint16",
          },
          {
            internalType: "uint16",
            name: "dividend",
            type: "uint16",
          },
          {
            internalType: "uint16",
            name: "affiliate",
            type: "uint16",
          },
          {
            internalType: "uint16",
            name: "treasury",
            type: "uint16",
          },
          {
            internalType: "uint16",
            name: "team",
            type: "uint16",
          },
          {
            internalType: "uint256",
            name: "dividendAmount",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "affiliateAmount",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "treasuryAmount",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "teamAmount",
            type: "uint256",
          },
        ],
        internalType: "struct IBankAdmin.HouseEdgeSplitAndAllocation",
        name: "houseEdgeSplitAndAllocation",
        type: "tuple",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "withdraw",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "tokenAddress",
        type: "address",
      },
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
    ],
    name: "withdrawAffiliateRevenues",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "tokenAddress",
        type: "address",
      },
    ],
    name: "withdrawDividend",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "withdrawDividends",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "tokenAddress",
        type: "address",
      },
    ],
    name: "withdrawProtocolRevenues",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
] as const;
</file>

<file path="packages/core/src/abis/v2/casino/dice.ts">
export const diceAbi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "bankAddress",
        type: "address",
      },
      {
        internalType: "address",
        name: "chainlinkCoordinatorAddress",
        type: "address",
      },
      {
        internalType: "address",
        name: "chainlinkWrapperAddress",
        type: "address",
      },
      {
        internalType: "address",
        name: "wrappedGasToken",
        type: "address",
      },
      {
        internalType: "uint64",
        name: "refundTime_",
        type: "uint64",
      },
      {
        internalType: "uint256",
        name: "maxCallGas_",
        type: "uint256",
      },
    ],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  {
    inputs: [],
    name: "AccessDenied",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "maxBetCount",
        type: "uint256",
      },
    ],
    name: "BetCountTooHigh",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "uint8",
        name: "minCap",
        type: "uint8",
      },
      {
        internalType: "uint8",
        name: "maxCap",
        type: "uint8",
      },
    ],
    name: "CapNotInRange",
    type: "error",
  },
  {
    inputs: [],
    name: "ForbiddenToken",
    type: "error",
  },
  {
    inputs: [],
    name: "HouseEdgeTooHigh",
    type: "error",
  },
  {
    inputs: [],
    name: "HouseEdgeTooLow",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidAddress",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidMaxCallGas",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidParam",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidVRFSubId",
    type: "error",
  },
  {
    inputs: [],
    name: "NotFulfilled",
    type: "error",
  },
  {
    inputs: [],
    name: "NotPendingBet",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "have",
        type: "address",
      },
      {
        internalType: "address",
        name: "want",
        type: "address",
      },
    ],
    name: "OnlyCoordinatorCanFulfill",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "have",
        type: "address",
      },
      {
        internalType: "address",
        name: "owner",
        type: "address",
      },
      {
        internalType: "address",
        name: "coordinator",
        type: "address",
      },
    ],
    name: "OnlyOwnerOrCoordinator",
    type: "error",
  },
  {
    inputs: [],
    name: "TokenHasPendingBets",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "minBetAmount",
        type: "uint256",
      },
    ],
    name: "UnderMinBetAmount",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "minBetCount",
        type: "uint256",
      },
    ],
    name: "UnderMinBetCount",
    type: "error",
  },
  {
    inputs: [],
    name: "WrongGasValueToCoverVRFFee",
    type: "error",
  },
  {
    inputs: [],
    name: "ZeroAddress",
    type: "error",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "address",
        name: "user",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "BetRefunded",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "vrfCoordinator",
        type: "address",
      },
    ],
    name: "CoordinatorSet",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "DistributeTokenVRFFees",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address",
      },
    ],
    name: "OwnershipTransferRequested",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address",
      },
    ],
    name: "OwnershipTransferred",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address",
      },
    ],
    name: "Paused",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "chargedVRFCost",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint8",
        name: "cap",
        type: "uint8",
      },
      {
        indexed: false,
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "betCount",
        type: "uint32",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "stopGain",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "stopLoss",
        type: "uint256",
      },
    ],
    name: "PlaceBet",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalBetAmount",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint8",
        name: "cap",
        type: "uint8",
      },
      {
        indexed: false,
        internalType: "uint8[]",
        name: "rolled",
        type: "uint8[]",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "payout",
        type: "uint256",
      },
    ],
    name: "Roll",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "previousHouseEdge",
        type: "uint16",
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "houseEdge",
        type: "uint16",
      },
    ],
    name: "SetAffiliateHouseEdge",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint16",
        name: "requestConfirmations",
        type: "uint16",
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "keyHash",
        type: "bytes32",
      },
      {
        indexed: false,
        internalType: "contract IVRFV2PlusWrapperCustom",
        name: "chainlinkWrapper",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "VRFCallbackGasExtraBet",
        type: "uint32",
      },
      {
        indexed: false,
        internalType: "bool",
        name: "nativePayment",
        type: "bool",
      },
    ],
    name: "SetChainlinkConfig",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "previousHouseEdge",
        type: "uint16",
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "houseEdge",
        type: "uint16",
      },
    ],
    name: "SetHouseEdge",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "previousMaxCallGas",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "maxCallGas",
        type: "uint256",
      },
    ],
    name: "SetMaxCallGas",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint64",
        name: "previousRefundTime",
        type: "uint64",
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "refundTime",
        type: "uint64",
      },
    ],
    name: "SetRefundTime",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "previousCallbackGasBase",
        type: "uint32",
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "callbackGasBase",
        type: "uint32",
      },
    ],
    name: "SetVRFCallbackGasBase",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "previousSubId",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "subId",
        type: "uint256",
      },
    ],
    name: "SetVRFSubId",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address",
      },
    ],
    name: "Unpaused",
    type: "event",
  },
  {
    inputs: [],
    name: "BANK",
    outputs: [
      {
        internalType: "contract IBankGame",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "WRAPPED",
    outputs: [
      {
        internalType: "contract IWrapped",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    name: "_affiliateHouseEdges",
    outputs: [
      {
        internalType: "uint16",
        name: "",
        type: "uint16",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "acceptOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    name: "bets",
    outputs: [
      {
        internalType: "bool",
        name: "resolved",
        type: "bool",
      },
      {
        internalType: "address",
        name: "receiver",
        type: "address",
      },
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
      {
        internalType: "uint16",
        name: "houseEdge",
        type: "uint16",
      },
      {
        internalType: "uint32",
        name: "timestamp",
        type: "uint32",
      },
      {
        internalType: "uint256",
        name: "payout",
        type: "uint256",
      },
      {
        internalType: "uint16",
        name: "betCount",
        type: "uint16",
      },
      {
        internalType: "uint256",
        name: "stopGain",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "stopLoss",
        type: "uint256",
      },
      {
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
    ],
    name: "diceBets",
    outputs: [
      {
        components: [
          {
            internalType: "uint8",
            name: "cap",
            type: "uint8",
          },
          {
            internalType: "uint8[]",
            name: "rolled",
            type: "uint8[]",
          },
        ],
        internalType: "struct IDice.DiceBet",
        name: "",
        type: "tuple",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
    ],
    name: "getAffiliateHouseEdge",
    outputs: [
      {
        internalType: "uint16",
        name: "",
        type: "uint16",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "getChainlinkConfig",
    outputs: [
      {
        internalType: "uint16",
        name: "requestConfirmations",
        type: "uint16",
      },
      {
        internalType: "bytes32",
        name: "keyHash",
        type: "bytes32",
      },
      {
        internalType: "contract IVRFCoordinatorV2Plus",
        name: "chainlinkCoordinator",
        type: "address",
      },
      {
        internalType: "contract IVRFV2PlusWrapperCustom",
        name: "chainlinkWrapper",
        type: "address",
      },
      {
        internalType: "uint32",
        name: "VRFCallbackGasExtraBet",
        type: "uint32",
      },
      {
        internalType: "bool",
        name: "nativePayment",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint16",
        name: "betCount",
        type: "uint16",
      },
    ],
    name: "getChainlinkVRFCost",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
    ],
    name: "hasPendingBets",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "maxCallGas",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "paused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "requestId",
        type: "uint256",
      },
      {
        internalType: "uint256[]",
        name: "randomWords",
        type: "uint256[]",
      },
    ],
    name: "rawFulfillRandomWords",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
    ],
    name: "refundBet",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "refundTime",
    outputs: [
      {
        internalType: "uint64",
        name: "",
        type: "uint64",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "s_vrfCoordinator",
    outputs: [
      {
        internalType: "contract IVRFCoordinatorV2Plus",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint16",
        name: "affiliateHouseEdge",
        type: "uint16",
      },
    ],
    name: "setAffiliateHouseEdge",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint16",
        name: "requestConfirmations",
        type: "uint16",
      },
      {
        internalType: "bytes32",
        name: "keyHash",
        type: "bytes32",
      },
      {
        internalType: "contract IVRFV2PlusWrapperCustom",
        name: "chainlinkWrapper",
        type: "address",
      },
      {
        internalType: "uint32",
        name: "VRFCallbackGasExtraBet",
        type: "uint32",
      },
      {
        internalType: "bool",
        name: "nativePayment",
        type: "bool",
      },
    ],
    name: "setChainlinkConfig",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_vrfCoordinator",
        type: "address",
      },
    ],
    name: "setCoordinator",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint16",
        name: "houseEdge",
        type: "uint16",
      },
    ],
    name: "setHouseEdge",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "maxCallGas_",
        type: "uint256",
      },
    ],
    name: "setMaxCallGas",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint64",
        name: "refundTime_",
        type: "uint64",
      },
    ],
    name: "setRefundTime",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint32",
        name: "callbackGasBase",
        type: "uint32",
      },
    ],
    name: "setVRFCallbackGasBase",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "subId",
        type: "uint256",
      },
    ],
    name: "setVRFSubId",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "togglePause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    name: "tokens",
    outputs: [
      {
        internalType: "uint16",
        name: "houseEdge",
        type: "uint16",
      },
      {
        internalType: "uint64",
        name: "pendingCount",
        type: "uint64",
      },
      {
        internalType: "uint256",
        name: "vrfSubId",
        type: "uint256",
      },
      {
        internalType: "uint32",
        name: "VRFCallbackGasBase",
        type: "uint32",
      },
      {
        internalType: "uint256",
        name: "VRFFees",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint8",
        name: "cap",
        type: "uint8",
      },
      {
        internalType: "address",
        name: "receiver",
        type: "address",
      },
      {
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
      {
        components: [
          {
            internalType: "address",
            name: "token",
            type: "address",
          },
          {
            internalType: "uint256",
            name: "betAmount",
            type: "uint256",
          },
          {
            internalType: "uint16",
            name: "betCount",
            type: "uint16",
          },
          {
            internalType: "uint256",
            name: "stopGain",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "stopLoss",
            type: "uint256",
          },
          {
            internalType: "uint16",
            name: "maxHouseEdge",
            type: "uint16",
          },
        ],
        internalType: "struct IGamePlayer.BetData",
        name: "betData",
        type: "tuple",
      },
    ],
    name: "wager",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "payable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "bet",
        type: "bytes",
      },
      {
        internalType: "address",
        name: "receiver",
        type: "address",
      },
      {
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
      {
        components: [
          {
            internalType: "address",
            name: "token",
            type: "address",
          },
          {
            internalType: "uint256",
            name: "betAmount",
            type: "uint256",
          },
          {
            internalType: "uint16",
            name: "betCount",
            type: "uint16",
          },
          {
            internalType: "uint256",
            name: "stopGain",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "stopLoss",
            type: "uint256",
          },
          {
            internalType: "uint16",
            name: "maxHouseEdge",
            type: "uint16",
          },
        ],
        internalType: "struct IGamePlayer.BetData",
        name: "betData",
        type: "tuple",
      },
    ],
    name: "wagerWithData",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "payable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
    ],
    name: "withdrawTokenVRFFees",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
] as const;
</file>

<file path="packages/core/src/abis/v2/casino/game.ts">
export const casinoGameAbi = [
  {
    inputs: [],
    name: "AccessDenied",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "maxBetCount",
        type: "uint256",
      },
    ],
    name: "BetCountTooHigh",
    type: "error",
  },
  {
    inputs: [],
    name: "ForbiddenToken",
    type: "error",
  },
  {
    inputs: [],
    name: "HouseEdgeTooHigh",
    type: "error",
  },
  {
    inputs: [],
    name: "HouseEdgeTooLow",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidAddress",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidMaxCallGas",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidParam",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidVRFSubId",
    type: "error",
  },
  {
    inputs: [],
    name: "NotFulfilled",
    type: "error",
  },
  {
    inputs: [],
    name: "NotPendingBet",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "have",
        type: "address",
      },
      {
        internalType: "address",
        name: "want",
        type: "address",
      },
    ],
    name: "OnlyCoordinatorCanFulfill",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "have",
        type: "address",
      },
      {
        internalType: "address",
        name: "owner",
        type: "address",
      },
      {
        internalType: "address",
        name: "coordinator",
        type: "address",
      },
    ],
    name: "OnlyOwnerOrCoordinator",
    type: "error",
  },
  {
    inputs: [],
    name: "TokenHasPendingBets",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "minBetAmount",
        type: "uint256",
      },
    ],
    name: "UnderMinBetAmount",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "minBetCount",
        type: "uint256",
      },
    ],
    name: "UnderMinBetCount",
    type: "error",
  },
  {
    inputs: [],
    name: "WrongGasValueToCoverVRFFee",
    type: "error",
  },
  {
    inputs: [],
    name: "ZeroAddress",
    type: "error",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "address",
        name: "user",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "BetRefunded",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "vrfCoordinator",
        type: "address",
      },
    ],
    name: "CoordinatorSet",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "DistributeTokenVRFFees",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address",
      },
    ],
    name: "OwnershipTransferRequested",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address",
      },
    ],
    name: "OwnershipTransferred",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address",
      },
    ],
    name: "Paused",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "previousHouseEdge",
        type: "uint16",
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "houseEdge",
        type: "uint16",
      },
    ],
    name: "SetAffiliateHouseEdge",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint16",
        name: "requestConfirmations",
        type: "uint16",
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "keyHash",
        type: "bytes32",
      },
      {
        indexed: false,
        internalType: "contract IVRFV2PlusWrapperCustom",
        name: "chainlinkWrapper",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "VRFCallbackGasExtraBet",
        type: "uint32",
      },
      {
        indexed: false,
        internalType: "bool",
        name: "nativePayment",
        type: "bool",
      },
    ],
    name: "SetChainlinkConfig",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "previousHouseEdge",
        type: "uint16",
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "houseEdge",
        type: "uint16",
      },
    ],
    name: "SetHouseEdge",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "previousMaxCallGas",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "maxCallGas",
        type: "uint256",
      },
    ],
    name: "SetMaxCallGas",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint64",
        name: "previousRefundTime",
        type: "uint64",
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "refundTime",
        type: "uint64",
      },
    ],
    name: "SetRefundTime",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "previousCallbackGasBase",
        type: "uint32",
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "callbackGasBase",
        type: "uint32",
      },
    ],
    name: "SetVRFCallbackGasBase",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "previousSubId",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "subId",
        type: "uint256",
      },
    ],
    name: "SetVRFSubId",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address",
      },
    ],
    name: "Unpaused",
    type: "event",
  },
  {
    inputs: [],
    name: "BANK",
    outputs: [
      {
        internalType: "contract IBankGame",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "WRAPPED",
    outputs: [
      {
        internalType: "contract IWrapped",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    name: "_affiliateHouseEdges",
    outputs: [
      {
        internalType: "uint16",
        name: "",
        type: "uint16",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "acceptOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    name: "bets",
    outputs: [
      {
        internalType: "bool",
        name: "resolved",
        type: "bool",
      },
      {
        internalType: "address",
        name: "receiver",
        type: "address",
      },
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
      {
        internalType: "uint16",
        name: "houseEdge",
        type: "uint16",
      },
      {
        internalType: "uint32",
        name: "timestamp",
        type: "uint32",
      },
      {
        internalType: "uint256",
        name: "payout",
        type: "uint256",
      },
      {
        internalType: "uint16",
        name: "betCount",
        type: "uint16",
      },
      {
        internalType: "uint256",
        name: "stopGain",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "stopLoss",
        type: "uint256",
      },
      {
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
    ],
    name: "getAffiliateHouseEdge",
    outputs: [
      {
        internalType: "uint16",
        name: "",
        type: "uint16",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "getChainlinkConfig",
    outputs: [
      {
        internalType: "uint16",
        name: "requestConfirmations",
        type: "uint16",
      },
      {
        internalType: "bytes32",
        name: "keyHash",
        type: "bytes32",
      },
      {
        internalType: "contract IVRFCoordinatorV2Plus",
        name: "chainlinkCoordinator",
        type: "address",
      },
      {
        internalType: "contract IVRFV2PlusWrapperCustom",
        name: "chainlinkWrapper",
        type: "address",
      },
      {
        internalType: "uint32",
        name: "VRFCallbackGasExtraBet",
        type: "uint32",
      },
      {
        internalType: "bool",
        name: "nativePayment",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint16",
        name: "betCount",
        type: "uint16",
      },
    ],
    name: "getChainlinkVRFCost",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
    ],
    name: "hasPendingBets",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "maxCallGas",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "paused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "requestId",
        type: "uint256",
      },
      {
        internalType: "uint256[]",
        name: "randomWords",
        type: "uint256[]",
      },
    ],
    name: "rawFulfillRandomWords",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
    ],
    name: "refundBet",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "refundTime",
    outputs: [
      {
        internalType: "uint64",
        name: "",
        type: "uint64",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "s_vrfCoordinator",
    outputs: [
      {
        internalType: "contract IVRFCoordinatorV2Plus",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint16",
        name: "affiliateHouseEdge",
        type: "uint16",
      },
    ],
    name: "setAffiliateHouseEdge",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint16",
        name: "requestConfirmations",
        type: "uint16",
      },
      {
        internalType: "bytes32",
        name: "keyHash",
        type: "bytes32",
      },
      {
        internalType: "contract IVRFV2PlusWrapperCustom",
        name: "chainlinkWrapper",
        type: "address",
      },
      {
        internalType: "uint32",
        name: "VRFCallbackGasExtraBet",
        type: "uint32",
      },
      {
        internalType: "bool",
        name: "nativePayment",
        type: "bool",
      },
    ],
    name: "setChainlinkConfig",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_vrfCoordinator",
        type: "address",
      },
    ],
    name: "setCoordinator",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint16",
        name: "houseEdge",
        type: "uint16",
      },
    ],
    name: "setHouseEdge",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "maxCallGas_",
        type: "uint256",
      },
    ],
    name: "setMaxCallGas",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint64",
        name: "refundTime_",
        type: "uint64",
      },
    ],
    name: "setRefundTime",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint32",
        name: "callbackGasBase",
        type: "uint32",
      },
    ],
    name: "setVRFCallbackGasBase",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "subId",
        type: "uint256",
      },
    ],
    name: "setVRFSubId",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "togglePause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    name: "tokens",
    outputs: [
      {
        internalType: "uint16",
        name: "houseEdge",
        type: "uint16",
      },
      {
        internalType: "uint64",
        name: "pendingCount",
        type: "uint64",
      },
      {
        internalType: "uint256",
        name: "vrfSubId",
        type: "uint256",
      },
      {
        internalType: "uint32",
        name: "VRFCallbackGasBase",
        type: "uint32",
      },
      {
        internalType: "uint256",
        name: "VRFFees",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
    ],
    name: "withdrawTokenVRFFees",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
] as const;
</file>

<file path="packages/core/src/abis/v2/casino/keno.ts">
export const kenoAbi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "bankAddress",
        type: "address",
      },
      {
        internalType: "address",
        name: "chainlinkCoordinatorAddress",
        type: "address",
      },
      {
        internalType: "address",
        name: "chainlinkWrapperAddress",
        type: "address",
      },
      {
        internalType: "address",
        name: "wrappedGasToken",
        type: "address",
      },
      {
        internalType: "uint64",
        name: "refundTime_",
        type: "uint64",
      },
      {
        internalType: "uint256",
        name: "maxCallGas_",
        type: "uint256",
      },
    ],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  {
    inputs: [],
    name: "AccessDenied",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "maxBetCount",
        type: "uint256",
      },
    ],
    name: "BetCountTooHigh",
    type: "error",
  },
  {
    inputs: [],
    name: "ForbiddenToken",
    type: "error",
  },
  {
    inputs: [],
    name: "HouseEdgeTooHigh",
    type: "error",
  },
  {
    inputs: [],
    name: "HouseEdgeTooLow",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidAddress",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidMaxCallGas",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidParam",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidSettings",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidVRFSubId",
    type: "error",
  },
  {
    inputs: [],
    name: "NotFulfilled",
    type: "error",
  },
  {
    inputs: [],
    name: "NotPendingBet",
    type: "error",
  },
  {
    inputs: [],
    name: "NumbersNotInRange",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "have",
        type: "address",
      },
      {
        internalType: "address",
        name: "want",
        type: "address",
      },
    ],
    name: "OnlyCoordinatorCanFulfill",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "have",
        type: "address",
      },
      {
        internalType: "address",
        name: "owner",
        type: "address",
      },
      {
        internalType: "address",
        name: "coordinator",
        type: "address",
      },
    ],
    name: "OnlyOwnerOrCoordinator",
    type: "error",
  },
  {
    inputs: [],
    name: "TokenHasPendingBets",
    type: "error",
  },
  {
    inputs: [],
    name: "TooManyNumbersPlayed",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "minBetAmount",
        type: "uint256",
      },
    ],
    name: "UnderMinBetAmount",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "minBetCount",
        type: "uint256",
      },
    ],
    name: "UnderMinBetCount",
    type: "error",
  },
  {
    inputs: [],
    name: "WrongGasValueToCoverVRFFee",
    type: "error",
  },
  {
    inputs: [],
    name: "ZeroAddress",
    type: "error",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "address",
        name: "user",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "BetRefunded",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "vrfCoordinator",
        type: "address",
      },
    ],
    name: "CoordinatorSet",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "DistributeTokenVRFFees",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address",
      },
    ],
    name: "OwnershipTransferRequested",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address",
      },
    ],
    name: "OwnershipTransferred",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address",
      },
    ],
    name: "Paused",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "chargedVRFCost",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint40",
        name: "numbers",
        type: "uint40",
      },
      {
        indexed: false,
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "betCount",
        type: "uint32",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "stopGain",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "stopLoss",
        type: "uint256",
      },
    ],
    name: "PlaceBet",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalBetAmount",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint40",
        name: "numbers",
        type: "uint40",
      },
      {
        indexed: false,
        internalType: "uint40[]",
        name: "rolled",
        type: "uint40[]",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "payout",
        type: "uint256",
      },
    ],
    name: "Roll",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "previousHouseEdge",
        type: "uint16",
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "houseEdge",
        type: "uint16",
      },
    ],
    name: "SetAffiliateHouseEdge",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint16",
        name: "requestConfirmations",
        type: "uint16",
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "keyHash",
        type: "bytes32",
      },
      {
        indexed: false,
        internalType: "contract IVRFV2PlusWrapperCustom",
        name: "chainlinkWrapper",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "VRFCallbackGasExtraBet",
        type: "uint32",
      },
      {
        indexed: false,
        internalType: "bool",
        name: "nativePayment",
        type: "bool",
      },
    ],
    name: "SetChainlinkConfig",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "previousHouseEdge",
        type: "uint16",
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "houseEdge",
        type: "uint16",
      },
    ],
    name: "SetHouseEdge",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "previousMaxCallGas",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "maxCallGas",
        type: "uint256",
      },
    ],
    name: "SetMaxCallGas",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint64",
        name: "previousRefundTime",
        type: "uint64",
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "refundTime",
        type: "uint64",
      },
    ],
    name: "SetRefundTime",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "previousCallbackGasBase",
        type: "uint32",
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "callbackGasBase",
        type: "uint32",
      },
    ],
    name: "SetVRFCallbackGasBase",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "previousSubId",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "subId",
        type: "uint256",
      },
    ],
    name: "SetVRFSubId",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint128",
        name: "newBiggestNumber",
        type: "uint128",
      },
      {
        indexed: false,
        internalType: "uint128",
        name: "newMaxNumbers",
        type: "uint128",
      },
    ],
    name: "TokenConfigUpdated",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address",
      },
    ],
    name: "Unpaused",
    type: "event",
  },
  {
    inputs: [],
    name: "BANK",
    outputs: [
      {
        internalType: "contract IBankGame",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "WRAPPED",
    outputs: [
      {
        internalType: "contract IWrapped",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    name: "_affiliateHouseEdges",
    outputs: [
      {
        internalType: "uint16",
        name: "",
        type: "uint16",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "acceptOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    name: "bets",
    outputs: [
      {
        internalType: "bool",
        name: "resolved",
        type: "bool",
      },
      {
        internalType: "address",
        name: "receiver",
        type: "address",
      },
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
      {
        internalType: "uint16",
        name: "houseEdge",
        type: "uint16",
      },
      {
        internalType: "uint32",
        name: "timestamp",
        type: "uint32",
      },
      {
        internalType: "uint256",
        name: "payout",
        type: "uint256",
      },
      {
        internalType: "uint16",
        name: "betCount",
        type: "uint16",
      },
      {
        internalType: "uint256",
        name: "stopGain",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "stopLoss",
        type: "uint256",
      },
      {
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "played",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "matchCount",
        type: "uint256",
      },
    ],
    name: "gain",
    outputs: [
      {
        internalType: "uint256",
        name: "_factor",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
    ],
    name: "gains",
    outputs: [
      {
        internalType: "uint256",
        name: "biggestNumber",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "maxNumbersPlayed",
        type: "uint256",
      },
      {
        internalType: "uint256[][]",
        name: "_gainsTable",
        type: "uint256[][]",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
    ],
    name: "getAffiliateHouseEdge",
    outputs: [
      {
        internalType: "uint16",
        name: "",
        type: "uint16",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "getChainlinkConfig",
    outputs: [
      {
        internalType: "uint16",
        name: "requestConfirmations",
        type: "uint16",
      },
      {
        internalType: "bytes32",
        name: "keyHash",
        type: "bytes32",
      },
      {
        internalType: "contract IVRFCoordinatorV2Plus",
        name: "chainlinkCoordinator",
        type: "address",
      },
      {
        internalType: "contract IVRFV2PlusWrapperCustom",
        name: "chainlinkWrapper",
        type: "address",
      },
      {
        internalType: "uint32",
        name: "VRFCallbackGasExtraBet",
        type: "uint32",
      },
      {
        internalType: "bool",
        name: "nativePayment",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint16",
        name: "betCount",
        type: "uint16",
      },
    ],
    name: "getChainlinkVRFCost",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "seed",
        type: "uint256",
      },
    ],
    name: "getNumbersOutOfRandomWord",
    outputs: [
      {
        internalType: "uint40",
        name: "",
        type: "uint40",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
    ],
    name: "hasPendingBets",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
    ],
    name: "kenoBets",
    outputs: [
      {
        components: [
          {
            internalType: "uint40",
            name: "numbers",
            type: "uint40",
          },
          {
            internalType: "uint40[]",
            name: "rolled",
            type: "uint40[]",
          },
        ],
        internalType: "struct IKeno.KenoBet",
        name: "",
        type: "tuple",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "maxCallGas",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "paused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "requestId",
        type: "uint256",
      },
      {
        internalType: "uint256[]",
        name: "randomWords",
        type: "uint256[]",
      },
    ],
    name: "rawFulfillRandomWords",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
    ],
    name: "refundBet",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "refundTime",
    outputs: [
      {
        internalType: "uint64",
        name: "",
        type: "uint64",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "s_vrfCoordinator",
    outputs: [
      {
        internalType: "contract IVRFCoordinatorV2Plus",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint16",
        name: "affiliateHouseEdge",
        type: "uint16",
      },
    ],
    name: "setAffiliateHouseEdge",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint16",
        name: "requestConfirmations",
        type: "uint16",
      },
      {
        internalType: "bytes32",
        name: "keyHash",
        type: "bytes32",
      },
      {
        internalType: "contract IVRFV2PlusWrapperCustom",
        name: "chainlinkWrapper",
        type: "address",
      },
      {
        internalType: "uint32",
        name: "VRFCallbackGasExtraBet",
        type: "uint32",
      },
      {
        internalType: "bool",
        name: "nativePayment",
        type: "bool",
      },
    ],
    name: "setChainlinkConfig",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_vrfCoordinator",
        type: "address",
      },
    ],
    name: "setCoordinator",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint16",
        name: "houseEdge",
        type: "uint16",
      },
    ],
    name: "setHouseEdge",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "maxCallGas_",
        type: "uint256",
      },
    ],
    name: "setMaxCallGas",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint64",
        name: "refundTime_",
        type: "uint64",
      },
    ],
    name: "setRefundTime",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint32",
        name: "callbackGasBase",
        type: "uint32",
      },
    ],
    name: "setVRFCallbackGasBase",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "subId",
        type: "uint256",
      },
    ],
    name: "setVRFSubId",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "togglePause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    name: "tokenConfigurations",
    outputs: [
      {
        internalType: "uint128",
        name: "biggestNumber",
        type: "uint128",
      },
      {
        internalType: "uint128",
        name: "maxNumbersPlayed",
        type: "uint128",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    name: "tokens",
    outputs: [
      {
        internalType: "uint16",
        name: "houseEdge",
        type: "uint16",
      },
      {
        internalType: "uint64",
        name: "pendingCount",
        type: "uint64",
      },
      {
        internalType: "uint256",
        name: "vrfSubId",
        type: "uint256",
      },
      {
        internalType: "uint32",
        name: "VRFCallbackGasBase",
        type: "uint32",
      },
      {
        internalType: "uint256",
        name: "VRFFees",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint128",
        name: "newBiggestNumber",
        type: "uint128",
      },
      {
        internalType: "uint128",
        name: "newMaxNumbers",
        type: "uint128",
      },
    ],
    name: "updateTokenConfig",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint40",
        name: "numbers",
        type: "uint40",
      },
      {
        internalType: "address",
        name: "receiver",
        type: "address",
      },
      {
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
      {
        components: [
          {
            internalType: "address",
            name: "token",
            type: "address",
          },
          {
            internalType: "uint256",
            name: "betAmount",
            type: "uint256",
          },
          {
            internalType: "uint16",
            name: "betCount",
            type: "uint16",
          },
          {
            internalType: "uint256",
            name: "stopGain",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "stopLoss",
            type: "uint256",
          },
          {
            internalType: "uint16",
            name: "maxHouseEdge",
            type: "uint16",
          },
        ],
        internalType: "struct IGamePlayer.BetData",
        name: "betData",
        type: "tuple",
      },
    ],
    name: "wager",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "payable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "bet",
        type: "bytes",
      },
      {
        internalType: "address",
        name: "receiver",
        type: "address",
      },
      {
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
      {
        components: [
          {
            internalType: "address",
            name: "token",
            type: "address",
          },
          {
            internalType: "uint256",
            name: "betAmount",
            type: "uint256",
          },
          {
            internalType: "uint16",
            name: "betCount",
            type: "uint16",
          },
          {
            internalType: "uint256",
            name: "stopGain",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "stopLoss",
            type: "uint256",
          },
          {
            internalType: "uint16",
            name: "maxHouseEdge",
            type: "uint16",
          },
        ],
        internalType: "struct IGamePlayer.BetData",
        name: "betData",
        type: "tuple",
      },
    ],
    name: "wagerWithData",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "payable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
    ],
    name: "withdrawTokenVRFFees",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
] as const;
</file>

<file path="packages/core/src/abis/v2/casino/roulette.ts">
export const rouletteAbi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "bankAddress",
        type: "address",
      },
      {
        internalType: "address",
        name: "chainlinkCoordinatorAddress",
        type: "address",
      },
      {
        internalType: "address",
        name: "chainlinkWrapperAddress",
        type: "address",
      },
      {
        internalType: "address",
        name: "wrappedGasToken",
        type: "address",
      },
      {
        internalType: "uint64",
        name: "refundTime_",
        type: "uint64",
      },
      {
        internalType: "uint256",
        name: "maxCallGas_",
        type: "uint256",
      },
    ],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  {
    inputs: [],
    name: "AccessDenied",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "maxBetCount",
        type: "uint256",
      },
    ],
    name: "BetCountTooHigh",
    type: "error",
  },
  {
    inputs: [],
    name: "ForbiddenToken",
    type: "error",
  },
  {
    inputs: [],
    name: "HouseEdgeTooHigh",
    type: "error",
  },
  {
    inputs: [],
    name: "HouseEdgeTooLow",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidAddress",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidMaxCallGas",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidParam",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidVRFSubId",
    type: "error",
  },
  {
    inputs: [],
    name: "NotFulfilled",
    type: "error",
  },
  {
    inputs: [],
    name: "NotPendingBet",
    type: "error",
  },
  {
    inputs: [],
    name: "NumbersNotInRange",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "have",
        type: "address",
      },
      {
        internalType: "address",
        name: "want",
        type: "address",
      },
    ],
    name: "OnlyCoordinatorCanFulfill",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "have",
        type: "address",
      },
      {
        internalType: "address",
        name: "owner",
        type: "address",
      },
      {
        internalType: "address",
        name: "coordinator",
        type: "address",
      },
    ],
    name: "OnlyOwnerOrCoordinator",
    type: "error",
  },
  {
    inputs: [],
    name: "TokenHasPendingBets",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "minBetAmount",
        type: "uint256",
      },
    ],
    name: "UnderMinBetAmount",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "minBetCount",
        type: "uint256",
      },
    ],
    name: "UnderMinBetCount",
    type: "error",
  },
  {
    inputs: [],
    name: "WrongGasValueToCoverVRFFee",
    type: "error",
  },
  {
    inputs: [],
    name: "ZeroAddress",
    type: "error",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "address",
        name: "user",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "BetRefunded",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "vrfCoordinator",
        type: "address",
      },
    ],
    name: "CoordinatorSet",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "DistributeTokenVRFFees",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address",
      },
    ],
    name: "OwnershipTransferRequested",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address",
      },
    ],
    name: "OwnershipTransferred",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address",
      },
    ],
    name: "Paused",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "chargedVRFCost",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint40",
        name: "numbers",
        type: "uint40",
      },
      {
        indexed: false,
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "betCount",
        type: "uint32",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "stopGain",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "stopLoss",
        type: "uint256",
      },
    ],
    name: "PlaceBet",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalBetAmount",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint40",
        name: "numbers",
        type: "uint40",
      },
      {
        indexed: false,
        internalType: "uint8[]",
        name: "rolled",
        type: "uint8[]",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "payout",
        type: "uint256",
      },
    ],
    name: "Roll",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "previousHouseEdge",
        type: "uint16",
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "houseEdge",
        type: "uint16",
      },
    ],
    name: "SetAffiliateHouseEdge",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint16",
        name: "requestConfirmations",
        type: "uint16",
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "keyHash",
        type: "bytes32",
      },
      {
        indexed: false,
        internalType: "contract IVRFV2PlusWrapperCustom",
        name: "chainlinkWrapper",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "VRFCallbackGasExtraBet",
        type: "uint32",
      },
      {
        indexed: false,
        internalType: "bool",
        name: "nativePayment",
        type: "bool",
      },
    ],
    name: "SetChainlinkConfig",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "previousHouseEdge",
        type: "uint16",
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "houseEdge",
        type: "uint16",
      },
    ],
    name: "SetHouseEdge",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "previousMaxCallGas",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "maxCallGas",
        type: "uint256",
      },
    ],
    name: "SetMaxCallGas",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint64",
        name: "previousRefundTime",
        type: "uint64",
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "refundTime",
        type: "uint64",
      },
    ],
    name: "SetRefundTime",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "previousCallbackGasBase",
        type: "uint32",
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "callbackGasBase",
        type: "uint32",
      },
    ],
    name: "SetVRFCallbackGasBase",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "previousSubId",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "subId",
        type: "uint256",
      },
    ],
    name: "SetVRFSubId",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address",
      },
    ],
    name: "Unpaused",
    type: "event",
  },
  {
    inputs: [],
    name: "BANK",
    outputs: [
      {
        internalType: "contract IBankGame",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "WRAPPED",
    outputs: [
      {
        internalType: "contract IWrapped",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    name: "_affiliateHouseEdges",
    outputs: [
      {
        internalType: "uint16",
        name: "",
        type: "uint16",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "acceptOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    name: "bets",
    outputs: [
      {
        internalType: "bool",
        name: "resolved",
        type: "bool",
      },
      {
        internalType: "address",
        name: "receiver",
        type: "address",
      },
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
      {
        internalType: "uint16",
        name: "houseEdge",
        type: "uint16",
      },
      {
        internalType: "uint32",
        name: "timestamp",
        type: "uint32",
      },
      {
        internalType: "uint256",
        name: "payout",
        type: "uint256",
      },
      {
        internalType: "uint16",
        name: "betCount",
        type: "uint16",
      },
      {
        internalType: "uint256",
        name: "stopGain",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "stopLoss",
        type: "uint256",
      },
      {
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
    ],
    name: "getAffiliateHouseEdge",
    outputs: [
      {
        internalType: "uint16",
        name: "",
        type: "uint16",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "getChainlinkConfig",
    outputs: [
      {
        internalType: "uint16",
        name: "requestConfirmations",
        type: "uint16",
      },
      {
        internalType: "bytes32",
        name: "keyHash",
        type: "bytes32",
      },
      {
        internalType: "contract IVRFCoordinatorV2Plus",
        name: "chainlinkCoordinator",
        type: "address",
      },
      {
        internalType: "contract IVRFV2PlusWrapperCustom",
        name: "chainlinkWrapper",
        type: "address",
      },
      {
        internalType: "uint32",
        name: "VRFCallbackGasExtraBet",
        type: "uint32",
      },
      {
        internalType: "bool",
        name: "nativePayment",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint16",
        name: "betCount",
        type: "uint16",
      },
    ],
    name: "getChainlinkVRFCost",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
    ],
    name: "hasPendingBets",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "maxCallGas",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "paused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "requestId",
        type: "uint256",
      },
      {
        internalType: "uint256[]",
        name: "randomWords",
        type: "uint256[]",
      },
    ],
    name: "rawFulfillRandomWords",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
    ],
    name: "refundBet",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "refundTime",
    outputs: [
      {
        internalType: "uint64",
        name: "",
        type: "uint64",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
    ],
    name: "rouletteBets",
    outputs: [
      {
        components: [
          {
            internalType: "uint40",
            name: "numbers",
            type: "uint40",
          },
          {
            internalType: "uint8[]",
            name: "rolled",
            type: "uint8[]",
          },
        ],
        internalType: "struct IRoulette.RouletteBet",
        name: "",
        type: "tuple",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "s_vrfCoordinator",
    outputs: [
      {
        internalType: "contract IVRFCoordinatorV2Plus",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint16",
        name: "affiliateHouseEdge",
        type: "uint16",
      },
    ],
    name: "setAffiliateHouseEdge",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint16",
        name: "requestConfirmations",
        type: "uint16",
      },
      {
        internalType: "bytes32",
        name: "keyHash",
        type: "bytes32",
      },
      {
        internalType: "contract IVRFV2PlusWrapperCustom",
        name: "chainlinkWrapper",
        type: "address",
      },
      {
        internalType: "uint32",
        name: "VRFCallbackGasExtraBet",
        type: "uint32",
      },
      {
        internalType: "bool",
        name: "nativePayment",
        type: "bool",
      },
    ],
    name: "setChainlinkConfig",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_vrfCoordinator",
        type: "address",
      },
    ],
    name: "setCoordinator",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint16",
        name: "houseEdge",
        type: "uint16",
      },
    ],
    name: "setHouseEdge",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "maxCallGas_",
        type: "uint256",
      },
    ],
    name: "setMaxCallGas",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint64",
        name: "refundTime_",
        type: "uint64",
      },
    ],
    name: "setRefundTime",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint32",
        name: "callbackGasBase",
        type: "uint32",
      },
    ],
    name: "setVRFCallbackGasBase",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "subId",
        type: "uint256",
      },
    ],
    name: "setVRFSubId",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "togglePause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    name: "tokens",
    outputs: [
      {
        internalType: "uint16",
        name: "houseEdge",
        type: "uint16",
      },
      {
        internalType: "uint64",
        name: "pendingCount",
        type: "uint64",
      },
      {
        internalType: "uint256",
        name: "vrfSubId",
        type: "uint256",
      },
      {
        internalType: "uint32",
        name: "VRFCallbackGasBase",
        type: "uint32",
      },
      {
        internalType: "uint256",
        name: "VRFFees",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint40",
        name: "numbers",
        type: "uint40",
      },
      {
        internalType: "address",
        name: "receiver",
        type: "address",
      },
      {
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
      {
        components: [
          {
            internalType: "address",
            name: "token",
            type: "address",
          },
          {
            internalType: "uint256",
            name: "betAmount",
            type: "uint256",
          },
          {
            internalType: "uint16",
            name: "betCount",
            type: "uint16",
          },
          {
            internalType: "uint256",
            name: "stopGain",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "stopLoss",
            type: "uint256",
          },
          {
            internalType: "uint16",
            name: "maxHouseEdge",
            type: "uint16",
          },
        ],
        internalType: "struct IGamePlayer.BetData",
        name: "betData",
        type: "tuple",
      },
    ],
    name: "wager",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "payable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "bet",
        type: "bytes",
      },
      {
        internalType: "address",
        name: "receiver",
        type: "address",
      },
      {
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
      {
        components: [
          {
            internalType: "address",
            name: "token",
            type: "address",
          },
          {
            internalType: "uint256",
            name: "betAmount",
            type: "uint256",
          },
          {
            internalType: "uint16",
            name: "betCount",
            type: "uint16",
          },
          {
            internalType: "uint256",
            name: "stopGain",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "stopLoss",
            type: "uint256",
          },
          {
            internalType: "uint16",
            name: "maxHouseEdge",
            type: "uint16",
          },
        ],
        internalType: "struct IGamePlayer.BetData",
        name: "betData",
        type: "tuple",
      },
    ],
    name: "wagerWithData",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "payable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
    ],
    name: "withdrawTokenVRFFees",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
] as const;
</file>

<file path="packages/core/src/abis/index.ts">
export * from "./v2";
</file>

<file path="packages/core/src/actions/common/approve.ts">
import type { Hash, Hex } from "viem";
import { encodeFunctionData, erc20Abi, zeroAddress } from "viem";
import { ERROR_CODES } from "../../errors/codes";
import { TransactionError } from "../../errors/types";
import type { BetSwirlFunctionData } from "../../interfaces";
import type { BetSwirlWallet } from "../../provider";

export enum ALLOWANCE_TYPE {
  ALWAYS = "ALWAYS",
  AUTO = "AUTO",
  NONE = "NONE",
}

export interface ApproveResult {
  approvedAmount: bigint;
  tokenAddress: Hex;
  allower: Hex;
  spender: Hex;
}

export type RawAllowance = bigint;

export async function approve(
  wallet: BetSwirlWallet,
  tokenAddress: Hex,
  allower: Hex,
  spender: Hex,
  amount: bigint,
  gasPrice?: bigint,
  pollingInterval?: number,
  allowanceType: ALLOWANCE_TYPE = ALLOWANCE_TYPE.AUTO,
  onApprovePending?: (tx: Hash, result: ApproveResult) => void | Promise<void>,
) {
  try {
    if (tokenAddress === zeroAddress || allowanceType === ALLOWANCE_TYPE.NONE)
      return { receipt: null, result: null };
    let allowance: null | bigint = null;
    if (allowanceType === ALLOWANCE_TYPE.AUTO) {
      const functionData = getAllowanceFunctionData(tokenAddress, allower, spender);
      allowance = await wallet.readContract<typeof functionData, RawAllowance>(functionData);
    }

    if (!allowance || allowance < amount) {
      const amountToApprove = amount - (allowance || 0n);
      const functionData = getApproveFunctionData(tokenAddress, spender, amountToApprove);
      const tx = await wallet.writeContract(functionData, undefined, gasPrice);
      const result: ApproveResult = {
        approvedAmount: amountToApprove,
        tokenAddress,
        allower,
        spender,
      };
      await onApprovePending?.(tx, result);
      const receipt = await wallet.waitTransaction(tx, pollingInterval);
      return { receipt, result };
    }

    return { receipt: null, result: null };
  } catch (error) {
    throw new TransactionError(
      `Error checking and approving token ${tokenAddress} on chain ${wallet.getChainId()}`,
      ERROR_CODES.TRANSACTION.TOKEN_APPROVAL_ERROR,
      {
        chainId: wallet.getChainId(),
        tokenAddress,
        spender,
        amount,
        allower,
      },
    );
  }
}

// multiplier = gross BP_VALUE
export function getAllowanceFunctionData(
  tokenAddress: Hex,
  allower: Hex,
  spender: Hex,
): BetSwirlFunctionData<typeof erc20Abi, "allowance", readonly [Hex, Hex]> {
  const abi = erc20Abi;
  const functionName = "allowance" as const;
  const args = [allower, spender] as const;
  return {
    data: { to: tokenAddress, abi, functionName, args },
    encodedData: encodeFunctionData({
      abi,
      functionName,
      args,
    }),
  };
}

export function getApproveFunctionData(
  tokenAddress: Hex,
  spender: Hex,
  amount: bigint,
): BetSwirlFunctionData<typeof erc20Abi, "approve", readonly [Hex, bigint]> {
  const abi = erc20Abi;
  const functionName = "approve" as const;
  const args = [spender, amount] as const;
  return {
    data: { to: tokenAddress, abi, functionName, args },
    encodedData: encodeFunctionData({
      abi,
      functionName,
      args,
    }),
  };
}
</file>

<file path="packages/core/src/data/subgraphs/protocol/clients/common.ts">
import {
  type ApolloCache,
  type DefaultOptions,
  type FetchPolicy,
  InMemoryCache,
} from "@apollo/client/core/index.js";
import { FORMAT_TYPE } from "../../../../utils/format";
import { replaceGraphQlKey } from "../../../../utils/subgraphs";
import { type CasinoChainId, casinoChainById } from "../../../casino";

export interface SubgraphCasinoClient {
  chainId: CasinoChainId;
  theGraphKey?: string;
  cache?: ApolloCache<any>;
  defaultOptions?: DefaultOptions;
  formatType?: FORMAT_TYPE;
}

export const defaultSubgraphCasinoClient = {
  cache: new InMemoryCache(),
  defaultOptions: {
    query: {
      fetchPolicy: "network-only" as FetchPolicy,
    },
  },
  formatType: FORMAT_TYPE.STANDARD,
};

export function getGraphqlEndpoint(subgraphClient: SubgraphCasinoClient) {
  const casinoChain = casinoChainById[subgraphClient.chainId];
  const graphQlKey = subgraphClient.theGraphKey;
  if (graphQlKey) {
    return replaceGraphQlKey(casinoChain.graphql.endpoint, graphQlKey);
  }
  return casinoChain.graphql.defaultEndpoint;
}
</file>

<file path="packages/core/src/data/subgraphs/protocol/clients/index.ts">
export * from "./bet";
export * from "./token";
</file>

<file path="packages/core/src/data/subgraphs/protocol/clients/token.ts">
import { ApolloClient } from "@apollo/client/core/index.js";
import { type Address } from "viem";
import { DEFAULT_ITEMS_PER_PAGE, SubgraphError } from "../../../..";
import { DEFAULT_PAGE } from "../../../../constants";
import { ERROR_CODES } from "../../../../errors";
import type { SubgraphToken } from "../../../../interfaces";
import { FORMAT_TYPE, formatRawAmount } from "../../../../utils/format";
import { type CasinoChainId } from "../../../casino";
import type { TokenFragment } from "../documents/fragments/token";
import { TokenDocument, type TokenQuery, type TokenQueryVariables } from "../documents/token";
import { TokensDocument, type TokensQuery, type TokensQueryVariables } from "../documents/tokens";
import { OrderDirection, Token_OrderBy } from "../documents/types";
import { getGraphqlEndpoint } from "./common";
import { defaultSubgraphCasinoClient } from "./common";
import type { SubgraphCasinoClient } from "./common";

export function formatToken(
  token: TokenFragment,
  chainId: CasinoChainId,
  formatType: FORMAT_TYPE = FORMAT_TYPE.STANDARD,
): SubgraphToken {
  return {
    id: token.id as Address,
    address: token.address as Address,
    chainId,
    symbol: token.symbol,
    name: token.name,
    decimals: token.decimals,
    betTxnCount: Number(token.betTxnCount),
    betCount: Number(token.betCount),
    winTxnCount: Number(token.winTxnCount),
    userCount: Number(token.userCount),
    totalWagered: BigInt(token.totalWagered),
    formattedTotalWagered: formatRawAmount(BigInt(token.totalWagered), token.decimals, formatType),
    totalPayout: BigInt(token.totalPayout),
    formattedTotalPayout: formatRawAmount(BigInt(token.totalPayout), token.decimals, formatType),
    dividendAmount: BigInt(token.dividendAmount),
    formattedDividendAmount: formatRawAmount(
      BigInt(token.dividendAmount),
      token.decimals,
      formatType,
    ),
    bankAmount: BigInt(token.bankAmount),
    formattedBankAmount: formatRawAmount(BigInt(token.bankAmount), token.decimals, formatType),
    affiliateAmount: BigInt(token.affiliateAmount),
    formattedAffiliateAmount: formatRawAmount(
      BigInt(token.affiliateAmount),
      token.decimals,
      formatType,
    ),
    treasuryAmount: BigInt(token.treasuryAmount),
    formattedTreasuryAmount: formatRawAmount(
      BigInt(token.treasuryAmount),
      token.decimals,
      formatType,
    ),
    teamAmount: BigInt(token.teamAmount),
    formattedTeamAmount: formatRawAmount(BigInt(token.teamAmount), token.decimals, formatType),
  };
}

export async function fetchTokens(
  client: SubgraphCasinoClient,
  page = DEFAULT_PAGE,
  itemsPerPage = DEFAULT_ITEMS_PER_PAGE,
  sortBy: { key: Token_OrderBy; order: OrderDirection } = {
    key: Token_OrderBy.Symbol,
    order: OrderDirection.Asc,
  },
): Promise<{ tokens: SubgraphToken[]; error: SubgraphError | undefined }> {
  const apolloClient = new ApolloClient({
    uri: getGraphqlEndpoint(client),
    cache: client.cache ?? defaultSubgraphCasinoClient.cache,
  });

  const variables: TokensQueryVariables = {
    first: itemsPerPage,
    skip: itemsPerPage * (page - 1),
    //where: {},
    orderBy: sortBy?.key,
    orderDirection: sortBy?.order,
  };

  const { data, error } = await apolloClient.query<TokensQuery, TokensQueryVariables>({
    query: TokensDocument,
    variables,
  });

  return {
    tokens:
      data?.tokens.map((token) =>
        formatToken(
          token,
          client.chainId,
          client.formatType ?? defaultSubgraphCasinoClient.formatType,
        ),
      ) ?? [],
    error: error
      ? new SubgraphError("Error fetching tokens", ERROR_CODES.SUBGRAPH.FETCH_TOKENS_ERROR, error)
      : undefined,
  };
}

export async function fetchToken(
  address: Address,
  client: SubgraphCasinoClient,
): Promise<{ token: SubgraphToken | undefined; error: SubgraphError | undefined }> {
  const apolloClient = new ApolloClient({
    uri: getGraphqlEndpoint(client),
    cache: client.cache ?? defaultSubgraphCasinoClient.cache,
  });

  const { data, error } = await apolloClient.query<TokenQuery, TokenQueryVariables>({
    query: TokenDocument,
    variables: {
      id: address.toLowerCase(),
    },
  });

  return {
    token: data.token
      ? formatToken(
          data.token,
          client.chainId,
          client.formatType ?? defaultSubgraphCasinoClient.formatType,
        )
      : undefined,
    error: error
      ? new SubgraphError("Error fetching token", ERROR_CODES.SUBGRAPH.FETCH_TOKEN_ERROR, error)
      : undefined,
  };
}
</file>

<file path="packages/core/src/data/subgraphs/protocol/documents/fragments/token.graphql">
fragment Token on Token {
  id
  address: id
  symbol
  name
  decimals
  betTxnCount
  betCount
  winTxnCount
  userCount
  totalWagered
  totalPayout
  dividendAmount
  bankAmount
  partnerAmount
  affiliateAmount
  treasuryAmount
  teamAmount
}
</file>

<file path="packages/core/src/data/subgraphs/protocol/documents/bet.graphql">
query Bet($id: ID!) {
  bet(id: $id, subgraphError: allow) {
    ...Bet
  }
}
</file>

<file path="packages/core/src/data/subgraphs/protocol/documents/bets.graphql">
query Bets(
  $first: Int
  $skip: Int
  $where: Bet_filter
  $orderBy: Bet_orderBy
  $orderDirection: OrderDirection
) {
  bets(
    first: $first
    skip: $skip
    where: $where
    orderBy: $orderBy
    orderDirection: $orderDirection
    subgraphError: allow
  ) {
    ...Bet
  }
}
</file>

<file path="packages/core/src/data/subgraphs/protocol/documents/token.graphql">
query Token($id: ID!) {
  token(id: $id, subgraphError: allow) {
    ...Token
  }
}
</file>

<file path="packages/core/src/data/subgraphs/protocol/documents/tokens.graphql">
query Tokens(
  $first: Int
  $skip: Int
  $where: Token_filter
  $orderBy: Token_orderBy
  $orderDirection: OrderDirection
) {
  tokens(
    first: $first
    skip: $skip
    where: $where
    orderBy: $orderBy
    orderDirection: $orderDirection
    subgraphError: allow
  ) {
    ...Token
  }
}
</file>

<file path="packages/core/src/data/subgraphs/protocol/index.ts">
export * from "./clients";

// Fragments
export type { BetFragment, BetFragmentDoc } from "./documents/fragments/bet";

// Queries
export type { BetQuery, BetQueryVariables, BetDocument } from "./documents/bet";
export type {
  BetsQuery,
  BetsQueryVariables,
  BetsDocument,
} from "./documents/bets";

//Enums
export { Bet_OrderBy, OrderDirection } from "./documents/types";
</file>

<file path="packages/core/src/data/index.ts">
export * from "./casino";
export * from "./chains";
export * from "./tokens";
export * from "./subgraphs/protocol";
</file>

<file path="packages/core/src/data/tokens.ts">
import type { Hex } from "viem";

export const BETS_ADDRESS = "0x94025780a1aB58868D9B2dBBB775f44b32e8E6e5" as Hex;
</file>

<file path="packages/core/src/entities/casino/dice.ts">
import { BP_VALUE } from "../../constants";
import { CASINO_GAME_TYPE } from "../../data/casino";
import { getFormattedNetMultiplier, getNetMultiplier } from "../../utils/bet";
import { AbstractCasinoGame, type ChoiceInput } from "./game";

export const MIN_SELECTABLE_DICE_NUMBER = 1 as DiceNumber;
export const MAX_SELECTABLE_DICE_NUMBER = 99 as DiceNumber;

export type DiceNumber =
  | 1
  | 2
  | 3
  | 4
  | 5
  | 6
  | 7
  | 8
  | 9
  | 10
  | 11
  | 12
  | 13
  | 14
  | 15
  | 16
  | 17
  | 18
  | 19
  | 20
  | 21
  | 22
  | 23
  | 24
  | 25
  | 26
  | 27
  | 28
  | 29
  | 30
  | 31
  | 32
  | 33
  | 34
  | 35
  | 36
  | 37
  | 38
  | 39
  | 40
  | 41
  | 42
  | 43
  | 44
  | 45
  | 46
  | 47
  | 48
  | 49
  | 50
  | 51
  | 52
  | 53
  | 54
  | 55
  | 56
  | 57
  | 58
  | 59
  | 60
  | 61
  | 62
  | 63
  | 64
  | 65
  | 66
  | 67
  | 68
  | 69
  | 70
  | 71
  | 72
  | 73
  | 74
  | 75
  | 76
  | 77
  | 78
  | 79
  | 80
  | 81
  | 82
  | 83
  | 84
  | 85
  | 86
  | 87
  | 88
  | 89
  | 90
  | 91
  | 92
  | 93
  | 94
  | 95
  | 96
  | 97
  | 98
  | 99;

export type DiceRolledNumber = 100 & DiceNumber;

export interface DiceChoiceInput extends ChoiceInput<CASINO_GAME_TYPE.DICE> {
  value: DiceNumber;
  id: DiceNumber;
}

export type DiceEncodedInput = number;
export type DiceEncodedRolled = number;

export class Dice extends AbstractCasinoGame<
  DiceNumber,
  DiceEncodedInput,
  DiceRolledNumber,
  DiceEncodedRolled
> {
  static getWinChancePercent(cap: DiceNumber | string): number {
    return Math.max(100 - Number(cap), 1);
  }

  static getMultiplier(cap: DiceNumber | string): number {
    return Math.round((BP_VALUE * 100) / (100 - Number(cap)));
  }

  static getFormattedMultiplier(cap: DiceNumber | string): number {
    return Number((Dice.getMultiplier(cap) / BP_VALUE).toFixed(3));
  }

  static encodeInput(cap: DiceNumber | string): DiceEncodedInput {
    return Number(cap) as DiceEncodedInput;
  }

  static decodeInput(encodedCap: DiceEncodedInput | string): DiceNumber {
    return Number(encodedCap) as DiceNumber;
  }

  static decodeRolled(encodedCap: DiceEncodedRolled | string): DiceRolledNumber {
    return Number(encodedCap) as DiceRolledNumber;
  }

  static getChoiceInputs(houseEdge?: number): DiceChoiceInput[] {
    return Array.from({ length: 99 }, (_, i) => {
      const diceNumber = (i + 1) as DiceNumber;
      return {
        value: diceNumber,
        id: diceNumber,
        game: CASINO_GAME_TYPE.DICE,
        label: `${diceNumber}`,
        winChancePercent: Dice.getWinChancePercent(diceNumber),
        multiplier: Dice.getMultiplier(diceNumber),
        formattedMultiplier: Dice.getFormattedMultiplier(diceNumber),
        netMultiplier: houseEdge
          ? getNetMultiplier(Dice.getMultiplier(diceNumber), houseEdge)
          : undefined,
        formattedNetMultiplier: houseEdge
          ? getFormattedNetMultiplier(Dice.getMultiplier(diceNumber), houseEdge)
          : undefined,
      };
    });
  }
}
</file>

<file path="packages/core/src/entities/casino/roulette.ts">
import { BP_VALUE } from "../../constants";
import { CASINO_GAME_TYPE } from "../../data/casino";
import { getFormattedNetMultiplier, getNetMultiplier } from "../../utils/bet";
import { AbstractCasinoGame, type ChoiceInput } from "./game";
export const MIN_SELECTABLE_ROULETTE_NUMBER = 0 as RouletteNumber;
export const MAX_SELECTABLE_ROULETTE_NUMBER = 36 as RouletteNumber;

export type RouletteNumber =
  | 0
  | 1
  | 2
  | 3
  | 4
  | 5
  | 6
  | 7
  | 8
  | 9
  | 10
  | 11
  | 12
  | 13
  | 14
  | 15
  | 16
  | 17
  | 18
  | 19
  | 20
  | 21
  | 22
  | 23
  | 24
  | 25
  | 26
  | 27
  | 28
  | 29
  | 30
  | 31
  | 32
  | 33
  | 34
  | 35
  | 36;
export enum ROULETTE_INPUT_BUNDLE {
  FIRST_ROW = "First row",
  SECOND_ROW = "Second row",
  THIRD_ROW = "Third row",
  ONE_TO_TWELVE = "1 to 12",
  THIRTEEN_TO_TWENTY_FOUR = "13 to 24",
  TWENTY_FIVE_TO_THIRTY_SIX = "25 to 36",
  ONE_TO_EIGHTEEN = "1 to 18",
  EIGHTEEN_TO_THIRTY_SIX = "18 to 36",
  ODD = "Odd",
  EVEN = "Even",
  RED = "Red",
  BLACK = "Black",
}

export interface RouletteChoiceInput extends ChoiceInput<CASINO_GAME_TYPE.ROULETTE> {
  value: RouletteNumber[];
  id: RouletteNumber[] | ROULETTE_INPUT_BUNDLE;
}

export type RouletteEncodedInput = number;
export type RouletteEncodedRolled = number;

export class Roulette extends AbstractCasinoGame<
  RouletteNumber[],
  RouletteEncodedInput,
  RouletteNumber,
  RouletteEncodedRolled
> {
  static getWinChancePercent(numbers: RouletteNumber[]): number {
    const encodedNumbers = Roulette.encodeInput(numbers);
    return (
      Math.round(
        (Roulette.getSelectedNumbersCount(encodedNumbers) / (MAX_SELECTABLE_ROULETTE_NUMBER + 1)) *
          1e3,
      ) / 10
    );
  }

  static getMultiplier(numbers: RouletteNumber[]): number {
    const encodedNumbers = Roulette.encodeInput(numbers);
    return encodedNumbers
      ? Number(
          (BigInt(BP_VALUE) * BigInt(MAX_SELECTABLE_ROULETTE_NUMBER + 1)) /
            BigInt(Roulette.getSelectedNumbersCount(encodedNumbers)),
        )
      : 0;
  }

  static getFormattedMultiplier(numbers: RouletteNumber[]): number {
    return Number((Roulette.getMultiplier(numbers) / BP_VALUE).toFixed(3));
  }

  static encodeInput(numbers: RouletteNumber[]): RouletteEncodedInput {
    // 1. Make the array unique
    const uniqueNumbers = [...new Set(numbers)];
    // 2. Sort the array
    const sortedNumbers = uniqueNumbers.sort((a, b) => a - b);
    // 3. Create a boolean array
    const sortedBooleans: boolean[] = Array(37).fill(false);
    for (const num of sortedNumbers) {
      sortedBooleans[num] = true;
    }
    // 4. Create a binary numbers
    const binaryNumbers = Object.values(sortedBooleans)
      .slice()
      .reverse()
      .reduce((numbers, isActive) => {
        return numbers + (isActive ? 1 : 0);
      }, "");
    // 5. Transform the binary numbers to a number
    return Number.parseInt(binaryNumbers, 2);
  }

  static decodeInput(encodedNumbers: RouletteEncodedInput | string): RouletteNumber[] {
    return Number(encodedNumbers)
      .toString(2)
      .split("")
      .reverse()
      .map((number, i) => (number === "1" ? i : -1))
      .filter((number) => number >= 0) as RouletteNumber[];
  }

  static decodeRolled(encodedRolled: RouletteEncodedRolled | string): RouletteNumber {
    return Number(encodedRolled) as RouletteNumber;
  }

  static getChoiceInputs(houseEdge?: number): RouletteChoiceInput[] {
    const createChoiceInput = (
      numbers: RouletteNumber[],
      id: RouletteNumber[] | ROULETTE_INPUT_BUNDLE,
      label: string,
    ): RouletteChoiceInput => ({
      value: numbers,
      id,
      game: CASINO_GAME_TYPE.ROULETTE,
      label,
      winChancePercent: Roulette.getWinChancePercent(numbers),
      multiplier: Roulette.getMultiplier(numbers),
      formattedMultiplier: Roulette.getFormattedMultiplier(numbers),
      netMultiplier: houseEdge
        ? getNetMultiplier(Roulette.getMultiplier(numbers), houseEdge)
        : undefined,
      formattedNetMultiplier: houseEdge
        ? getFormattedNetMultiplier(Roulette.getMultiplier(numbers), houseEdge)
        : undefined,
    });

    // 1. Single numbers
    const choiceInputs: RouletteChoiceInput[] = Array.from({ length: 37 }, (_, i) => {
      const rouletteNumber = i as RouletteNumber;
      return createChoiceInput([rouletteNumber], [rouletteNumber], `${rouletteNumber}`);
    });

    // 2. Rows
    choiceInputs.push(
      ...[1, 2, 3].map((startNumber) => {
        const rowNumbers = Array.from(
          { length: 12 },
          (_, i) => startNumber + i * 3,
        ) as RouletteNumber[];
        const bundle =
          startNumber === 1
            ? ROULETTE_INPUT_BUNDLE.FIRST_ROW
            : startNumber === 2
              ? ROULETTE_INPUT_BUNDLE.SECOND_ROW
              : ROULETTE_INPUT_BUNDLE.THIRD_ROW;
        return createChoiceInput(rowNumbers, bundle, `${bundle} (${rowNumbers})`);
      }),
    );

    // 3. From to
    const fromToBundles = [
      {
        from: 1,
        to: 12,
        id: ROULETTE_INPUT_BUNDLE.ONE_TO_TWELVE,
      },
      {
        from: 13,
        to: 24,
        id: ROULETTE_INPUT_BUNDLE.THIRTEEN_TO_TWENTY_FOUR,
      },
      {
        from: 25,
        to: 36,
        id: ROULETTE_INPUT_BUNDLE.TWENTY_FIVE_TO_THIRTY_SIX,
      },
      {
        from: 1,
        to: 18,
        id: ROULETTE_INPUT_BUNDLE.ONE_TO_EIGHTEEN,
      },
      {
        from: 19,
        to: 36,
        id: ROULETTE_INPUT_BUNDLE.EIGHTEEN_TO_THIRTY_SIX,
      },
    ];
    choiceInputs.push(
      ...fromToBundles.map((bundle) => {
        const numbers = Array.from(
          { length: bundle.to - bundle.from + 1 },
          (_, i) => bundle.from + i,
        ) as RouletteNumber[];
        return createChoiceInput(numbers, bundle.id, `${bundle.id}`);
      }),
    );

    // 4. Odd and even
    choiceInputs.push(
      ...[1, 2].map((startNumber) => {
        const rowNumbers = Array.from(
          { length: 18 },
          (_, i) => startNumber + i * 2,
        ) as RouletteNumber[];
        const bundle = startNumber === 1 ? ROULETTE_INPUT_BUNDLE.ODD : ROULETTE_INPUT_BUNDLE.EVEN;
        return createChoiceInput(rowNumbers, bundle, `${bundle} (${rowNumbers})`);
      }),
    );

    // 5. Colors
    const colorBundles = [
      {
        id: ROULETTE_INPUT_BUNDLE.BLACK,
        numbers: [
          2, 4, 6, 8, 10, 11, 13, 15, 17, 20, 22, 24, 26, 28, 29, 31, 33, 35,
        ] as RouletteNumber[],
      },
      {
        id: ROULETTE_INPUT_BUNDLE.RED,
        numbers: [
          1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36,
        ] as RouletteNumber[],
      },
    ];
    choiceInputs.push(
      ...colorBundles.map((colorBundle) =>
        createChoiceInput(colorBundle.numbers, colorBundle.id, `${colorBundle.id}`),
      ),
    );
    return choiceInputs;
  }

  // Roulette utilities
  static getSelectedNumbersCount(encodedNumbers: number) {
    return (Number(encodedNumbers).toString(2).match(/1/g) || []).length;
  }

  static combineChoiceInputs(
    inputs: RouletteChoiceInput[],
    houseEdge?: number,
  ): RouletteChoiceInput {
    // 1. Combine all unique numbers from the inputs
    const combinedNumbers = [...new Set(inputs.flatMap((input) => input.value))];
    // 2. Sort the numbers
    const sortedCombinedNumbers = combinedNumbers.sort((a, b) => a - b);

    // 3. Create a the custom label
    const customLabel = sortedCombinedNumbers.map((rouletteNumber) => rouletteNumber).join(" & ");

    return {
      value: sortedCombinedNumbers,
      id: sortedCombinedNumbers,
      game: CASINO_GAME_TYPE.ROULETTE,
      label: customLabel,
      winChancePercent: Roulette.getWinChancePercent(combinedNumbers),
      multiplier: Roulette.getMultiplier(combinedNumbers),
      formattedMultiplier: Roulette.getFormattedMultiplier(combinedNumbers),
      netMultiplier: houseEdge
        ? getNetMultiplier(Roulette.getMultiplier(combinedNumbers), houseEdge)
        : undefined,
      formattedNetMultiplier: houseEdge
        ? getFormattedNetMultiplier(Roulette.getMultiplier(combinedNumbers), houseEdge)
        : undefined,
    };
  }
}
</file>

<file path="packages/core/src/errors/betSwirlError.ts">
export class BetSwirlError extends Error {
  public code: string;
  public context?: Record<string, any>;

  constructor(message: string, code: string, context?: Record<string, any>) {
    super(message);
    this.name = "BetSwirlError";
    this.code = code;
    this.context = context;
  }
}
</file>

<file path="packages/core/src/errors/index.ts">
export * from "./betSwirlError";
export * from "./codes";
export * from "./types";
</file>

<file path="packages/core/src/errors/types.ts">
import type { ApolloError } from "@apollo/client/core/index.js";
import { BetSwirlError } from "./betSwirlError";

export class ChainError extends BetSwirlError {
  constructor(message: string, code: string, context?: Record<string, any>) {
    super(message, code, context);
    this.name = "ChainError";
  }
}

export class TransactionError extends BetSwirlError {
  constructor(message: string, code: string, context?: Record<string, any>) {
    super(message, code, context);
    this.name = "TransactionError";
  }
}

export class ConfigurationError extends BetSwirlError {
  constructor(message: string, code: string, context?: Record<string, any>) {
    super(message, code, context);
    this.name = "ConfigurationError";
  }
}

export class SubgraphError extends BetSwirlError {
  public apolloError: ApolloError;
  constructor(
    message: string,
    code: string,
    apolloError: ApolloError,
    context?: Record<string, any>,
  ) {
    const errorContext = context ? { ...context, apolloError } : { apolloError };
    super(message, code, errorContext);
    this.name = "SubgraphError";
    this.apolloError = apolloError;
  }
}
</file>

<file path="packages/core/src/provider/index.ts">
export * from "./client";
export * from "./wallet";
export * from "./viemClient";
export * from "./viemWallet";
</file>

<file path="packages/core/src/provider/viemWallet.ts">
import type {
  Abi,
  CallReturnType,
  Hash,
  PublicClient,
  TransactionReceipt,
  WalletClient,
} from "viem";
import type { BetSwirlEventData, BetSwirlFunctionData } from "../interfaces";
import { BetSwirlWallet } from "./wallet";

export class ViemBetSwirlWallet extends BetSwirlWallet {
  public publicClient: PublicClient;
  private walletClient?: WalletClient;

  constructor(viemPublicClient: PublicClient, viemWalletClient?: WalletClient) {
    super();
    this.walletClient = viemWalletClient;
    this.publicClient = viemPublicClient;
  }

  getChainId() {
    return this.walletClient?.chain?.id ?? this.publicClient.chain!.id;
  }

  getAccount(_chainId?: number) {
    return this.walletClient?.account;
  }

  getPublicClient(_chainId?: number) {
    return this.publicClient;
  }

  override async readContract<
    TFunctionData extends BetSwirlFunctionData<Abi, string, readonly any[]>,
    TReturnType = any,
  >(functionData: TFunctionData, gasPrice?: bigint): Promise<CallReturnType | TReturnType> {
    if (gasPrice) {
      return this.publicClient.call({
        to: functionData.data.to,
        data: functionData.encodedData,
        gasPrice,
      });
    }

    return this.publicClient.readContract({
      address: functionData.data.to,
      abi: functionData.data.abi,
      functionName: functionData.data.functionName,
      args: functionData.data.args,
    }) as Promise<TReturnType>;
  }
  async readContracts<
    TFunctionDatas extends BetSwirlFunctionData<Abi, string, readonly any[]>[],
    TReturnTypes extends any[],
  >(functionDatas: [...TFunctionDatas]): Promise<TReturnTypes> {
    const results = await Promise.all(
      functionDatas.map((functionData) =>
        this.publicClient.readContract({
          address: functionData.data.to,
          abi: functionData.data.abi,
          functionName: functionData.data.functionName,
          args: functionData.data.args,
        }),
      ),
    );

    return results as TReturnTypes;
  }

  async getTransactionReceipt(txHash: Hash): Promise<TransactionReceipt> {
    return this.publicClient.getTransactionReceipt({ hash: txHash });
  }

  watchContractEvent<TEventData extends BetSwirlEventData<Abi, string, any>>(
    eventData: TEventData,
  ): () => void {
    return this.publicClient.watchContractEvent({
      address: eventData.data.to,
      abi: eventData.data.abi,
      eventName: eventData.data.eventName,
      args: eventData.data.args,
      pollingInterval: eventData.data.pollingInterval,
      onLogs: (logs) => eventData.callbacks.onLogs?.(logs),
      onError: (error) => eventData.callbacks.onError?.(error),
    });
  }

  async writeContract<TFunctionData extends BetSwirlFunctionData<Abi, string, readonly any[]>>(
    functionData: TFunctionData,
    value?: bigint,
    gasPrice?: bigint,
  ): Promise<Hash> {
    if (!this.walletClient) {
      throw new Error("[ViemBetSwirlWallet]Wallet client is not initialized");
    }

    const { request } = await this.publicClient.simulateContract({
      address: functionData.data.to,
      abi: functionData.data.abi,
      functionName: functionData.data.functionName,
      args: functionData.data.args,
      account: this.getAccount(),
      value,
      gasPrice,
    });

    return this.walletClient.writeContract(request);
  }

  async waitTransaction(txHash: Hash, pollingInterval?: number): Promise<TransactionReceipt> {
    return this.publicClient.waitForTransactionReceipt({
      hash: txHash,
      pollingInterval,
    });
  }
}
</file>

<file path="packages/core/src/provider/wallet.ts">
import type {
  Abi,
  Account,
  CallReturnType,
  Hash,
  TransactionReceipt,
  PublicClient as ViemPublicClient,
} from "viem";
import type { BetSwirlEventData, BetSwirlFunctionData } from "../interfaces";

export abstract class BetSwirlWallet {
  abstract getChainId(): number;

  abstract getPublicClient(chainId?: number): ViemPublicClient;
  abstract getAccount(chainId?: number): Account | undefined;

  abstract readContract<TFunctionData extends BetSwirlFunctionData<Abi, string, readonly any[]>>(
    functionData: TFunctionData,
    gasPrice: bigint,
  ): Promise<CallReturnType>;

  abstract readContract<
    TFunctionData extends BetSwirlFunctionData<Abi, string, readonly any[]>,
    TReturnType = any,
  >(functionData: TFunctionData, gasPrice?: undefined): Promise<TReturnType>;

  abstract readContracts<
    TFunctionDatas extends BetSwirlFunctionData<Abi, string, readonly any[]>[],
    TReturnTypes extends any[],
  >(functionDatas: [...TFunctionDatas]): Promise<TReturnTypes>;

  abstract getTransactionReceipt(txHash: Hash): Promise<TransactionReceipt>;

  abstract watchContractEvent<
    TEventData extends BetSwirlEventData<Abi, string, Record<string, any>>,
  >(eventData: TEventData): () => void;

  abstract writeContract<TFunctionData extends BetSwirlFunctionData<Abi, string, readonly any[]>>(
    functionData: TFunctionData,
    value?: bigint,
    gasPrice?: bigint,
  ): Promise<Hash>;

  abstract waitTransaction(txHash: Hash, pollingInterval?: number): Promise<TransactionReceipt>;
}
</file>

<file path="packages/core/src/read/casino/bank.ts">
import { casinoChainById, maxGameBetCountByType } from "../../data/casino";

import { type Hex, encodeFunctionData } from "viem";
import { bankAbi } from "../../abis/v2/casino/bank";
import type { CASINO_GAME_TYPE, CasinoChainId } from "../../data/casino";
import { TransactionError } from "../../errors/types";
import type { BetRequirements, BetSwirlFunctionData, CasinoToken, Token } from "../../interfaces";

import { ERROR_CODES } from "../../errors/codes";
import type { BetSwirlWallet } from "../../provider";
import { getCasinoChainId } from "../../utils/chains";
import { rawTokenToToken } from "../../utils/tokens";

export type RawCasinoToken = {
  decimals: number;
  tokenAddress: `0x${string}`;
  name: string;
  symbol: string;
  token: {
    allowed: boolean;
    paused: boolean;
    balanceRisk: number;
    bankrollProvider: `0x${string}`;
    pendingBankrollProvider: `0x${string}`;
    houseEdgeSplitAndAllocation: {
      bank: number;
      dividend: number;
      affiliate: number;
      treasury: number;
      team: number;
      dividendAmount: bigint;
      affiliateAmount: bigint;
      treasuryAmount: bigint;
      teamAmount: bigint;
    };
  };
};

export function parseRawCasinoToken(
  rawToken: RawCasinoToken,
  casinoChainId: CasinoChainId,
): CasinoToken {
  return {
    ...rawTokenToToken(rawToken, casinoChainId),
    paused: !rawToken.token.allowed || rawToken.token.paused,
    balanceRisk: rawToken.token.balanceRisk,
    balanceRiskPercent: rawToken.token.balanceRisk / 100,
    bankrollProvider: rawToken.token.bankrollProvider,
    chainId: casinoChainId,
    houseEdgeSplit: {
      bank: rawToken.token.houseEdgeSplitAndAllocation.bank,
      bankPercent: rawToken.token.houseEdgeSplitAndAllocation.bank / 100,
      dividend: rawToken.token.houseEdgeSplitAndAllocation.dividend,
      dividendPercent: rawToken.token.houseEdgeSplitAndAllocation.dividend / 100,
      affiliate: rawToken.token.houseEdgeSplitAndAllocation.affiliate,
      affiliatePercent: rawToken.token.houseEdgeSplitAndAllocation.affiliate / 100,
      treasury: rawToken.token.houseEdgeSplitAndAllocation.treasury,
      treasuryPercent: rawToken.token.houseEdgeSplitAndAllocation.treasury / 100,
      team: rawToken.token.houseEdgeSplitAndAllocation.team,
      teamPercent: rawToken.token.houseEdgeSplitAndAllocation.team / 100,
    },
  };
}

export async function getCasinoTokens(
  wallet: BetSwirlWallet,
  onlyActive = false,
): Promise<CasinoToken[]> {
  const casinoChainId = getCasinoChainId(wallet);
  try {
    const functionData = getCasinoTokensFunctionData(casinoChainId);
    const rawTokens = await wallet.readContract<typeof functionData, RawCasinoToken[]>(
      functionData,
    );

    return rawTokens
      .map((rawToken) => parseRawCasinoToken(rawToken, casinoChainId))
      .filter((token) => !onlyActive || !token.paused);
  } catch (error) {
    throw new TransactionError("Error getting tokens", ERROR_CODES.BANK.GET_TOKENS_ERROR, {
      chainId: casinoChainId,
      cause: error,
    });
  }
}

export function getCasinoTokensFunctionData(
  casinoChainId: CasinoChainId,
): BetSwirlFunctionData<typeof bankAbi, "getTokens", readonly []> {
  const casinoChain = casinoChainById[casinoChainId];

  const abi = bankAbi;
  const functionName = "getTokens" as const;
  const args = [] as const;
  return {
    data: { to: casinoChain.contracts.bank, abi, functionName, args },
    encodedData: encodeFunctionData({
      abi,
      functionName,
      args,
    }),
  };
}

/**
 * Raw bet requirements data returned by the smart contract
 * [0] - isAllowed: Indicates if the token is allowed for betting
 * [1] - maxBetAmount: Maximum amount allowed per bet
 * [2] - maxBetCount: Maximum number of simultaneous bets allowed
 */
export type RawBetRequirements = [boolean, bigint, bigint];

export function parseRawBetRequirements(
  rawBetRequirements: RawBetRequirements,
  token: Token,
  multiplier: number,
  game: CASINO_GAME_TYPE,
  casinoChainId: CasinoChainId,
): BetRequirements {
  return {
    token,
    multiplier,
    chainId: casinoChainId,
    maxBetAmount: rawBetRequirements[1],
    maxBetCount: Math.min(Number(rawBetRequirements[2]), maxGameBetCountByType[game]),
    isAllowed: rawBetRequirements[0],
  };
}

export async function getBetRequirements(
  wallet: BetSwirlWallet,
  token: Token,
  multiplier: number | number[], // gross BP_VALUE
  game: CASINO_GAME_TYPE,
): Promise<BetRequirements> {
  const casinoChainId = getCasinoChainId(wallet);

  const biggestMultiplier = Math.max(...(Array.isArray(multiplier) ? multiplier : [multiplier]));
  try {
    const functionData = getBetRequirementsFunctionData(
      token.address,
      biggestMultiplier,
      casinoChainId,
    );
    const rawBetRequirements = await wallet.readContract<typeof functionData, RawBetRequirements>(
      functionData,
    );

    return parseRawBetRequirements(
      rawBetRequirements,
      token,
      biggestMultiplier,
      game,
      casinoChainId,
    );
  } catch (error) {
    throw new TransactionError(
      "Error getting bet requirements",
      ERROR_CODES.BANK.GET_BET_REQUIREMENTS_ERROR,
      {
        chainId: casinoChainId,
        cause: error,
      },
    );
  }
}
// multiplier = gross BP_VALUE
export function getBetRequirementsFunctionData(
  tokenAddress: Hex,
  multiplier: number,
  casinoChainId: CasinoChainId,
): BetSwirlFunctionData<typeof bankAbi, "getBetRequirements", readonly [Hex, bigint]> {
  const casinoChain = casinoChainById[casinoChainId];

  const abi = bankAbi;
  const functionName = "getBetRequirements" as const;
  const args = [tokenAddress, BigInt(multiplier)] as const;
  return {
    data: { to: casinoChain.contracts.bank, abi, functionName, args },
    encodedData: encodeFunctionData({
      abi,
      functionName,
      args,
    }),
  };
}
</file>

<file path="packages/core/src/read/casino/dice.ts">
import { type TransactionReceipt } from "viem";
import { type DicePlacedBet } from "../../actions/casino/dice";
import { Dice, type DiceNumber } from "../../entities/casino/dice";
import type { BetSwirlWallet } from "../../provider";
import { type CasinoRolledBet, type CasinoWaitRollOptions, waitRolledBet } from "./game";

export interface DiceRolledBet extends Omit<CasinoRolledBet, "decodedRoll"> {
  rolled: DiceNumber[];
}

export async function waitDiceRolledBet(
  wallet: BetSwirlWallet,
  placedBet: DicePlacedBet,
  options?: CasinoWaitRollOptions,
): Promise<{
  rolledBet: DiceRolledBet;
  receipt: TransactionReceipt;
}> {
  const { rolledBet, receipt } = await waitRolledBet(wallet, placedBet, options);
  return {
    rolledBet: {
      ...rolledBet,
      rolled: rolledBet.encodedRolled.map(Dice.decodeRolled),
    },
    receipt,
  };
}
</file>

<file path="packages/core/src/read/casino/roulette.ts">
import { type TransactionReceipt } from "viem";
import { type RoulettePlacedBet } from "../../actions/casino/roulette";
import { Roulette, type RouletteNumber } from "../../entities/casino/roulette";
import type { BetSwirlWallet } from "../../provider";
import { type CasinoRolledBet, type CasinoWaitRollOptions, waitRolledBet } from "./game";

export interface RouletteRolledBet extends Omit<CasinoRolledBet, "decodedRoll"> {
  rolled: RouletteNumber[];
}

export async function waitRouletteRolledBet(
  wallet: BetSwirlWallet,
  placedBet: RoulettePlacedBet,
  options?: CasinoWaitRollOptions,
): Promise<{
  rolledBet: RouletteRolledBet;
  receipt: TransactionReceipt;
}> {
  const { rolledBet, receipt } = await waitRolledBet(wallet, placedBet, options);
  return {
    rolledBet: {
      ...rolledBet,
      rolled: rolledBet.encodedRolled.map(Roulette.decodeRolled),
    },
    receipt,
  };
}
</file>

<file path="packages/core/src/read/common/chainlinkVrfCost.ts">
import { casinoGameAbi } from "../../abis/v2/casino/game";

import { type Hex, encodeFunctionData } from "viem";
import { defaultCasinoPlaceBetOptions } from "../../actions";
import { type CASINO_GAME_TYPE, type CasinoChainId, casinoChainById } from "../../data/casino";
import { ERROR_CODES } from "../../errors/codes";
import { ChainError, TransactionError } from "../../errors/types";
import type { BetSwirlFunctionData } from "../../interfaces";
import type { BetSwirlWallet } from "../../provider";
import { getCasinoChainId } from "../../utils";
import { GAS_PRICE_TYPE, getGasPrices } from "./gasPrice";

export type RawChainlinkVrfCost = bigint;

export async function getChainlinkVrfCost(
  wallet: BetSwirlWallet,
  game: CASINO_GAME_TYPE, // TODO allow to pass PVP_GAME_TYPE
  tokenAddress: Hex,
  betCount: number,
  gasPrice?: bigint,
  gasPriceType?: GAS_PRICE_TYPE,
): Promise<bigint> {
  const casinoChainId = getCasinoChainId(wallet);

  // Get default gas price if gas price is not passed
  const effectiveGasPrice =
    gasPrice ||
    (await getGasPrices(wallet, casinoChainId))[
      gasPriceType || defaultCasinoPlaceBetOptions.gasPriceType
    ];
  const functionData = getChainlinkVrfCostFunctionData(game, tokenAddress, betCount, casinoChainId);
  const gameAddress = functionData.data.to;
  try {
    const { data: vrfCost } = await wallet.readContract<typeof functionData>(
      functionData,
      effectiveGasPrice,
    );

    if (!vrfCost) {
      console.warn(
        `[getChainlinkVrfCost] vrfCost is 0 for tokenAddress: ${tokenAddress}, betCount: ${betCount}, gameAddress: ${gameAddress}, chainId: ${casinoChainId}`,
      );
      return 0n;
    }
    return BigInt(vrfCost || 0n);
  } catch (error) {
    throw new TransactionError(
      `An error occured while getting the chainlink vrf cost: ${error}`,
      ERROR_CODES.READ.CHAINLINK_VRF_COST_ERROR,
      {
        gameAddress,
        tokenAddress,
        betCount,
        chainId: casinoChainId,
        gasPrice: effectiveGasPrice,
      },
    );
  }
}

export function getChainlinkVrfCostFunctionData(
  game: CASINO_GAME_TYPE,
  tokenAddress: Hex,
  betCount: number,
  casinoChainId: CasinoChainId,
): BetSwirlFunctionData<typeof casinoGameAbi, "getChainlinkVRFCost", readonly [Hex, number]> {
  const casinoChain = casinoChainById[casinoChainId];
  const gameAddress = casinoChain.contracts.games[game]?.address;

  if (!gameAddress) {
    throw new ChainError(
      `${game} is not available for chain ${casinoChain.viemChain.name} (${casinoChainId})`,
      ERROR_CODES.CHAIN.UNSUPPORTED_GAME,
      {
        chainId: casinoChainId,
        supportedChains: Object.keys(casinoChainById),
      },
    );
  }
  const abi = casinoGameAbi;
  const functionName = "getChainlinkVRFCost";
  const args = [tokenAddress, betCount] as const;
  return {
    data: { to: gameAddress, abi, functionName, args },
    encodedData: encodeFunctionData({
      abi,
      functionName,
      args,
    }),
  };
}
</file>

<file path="packages/core/src/read/common/gasPrice.ts">
import type { BetSwirlWallet } from "../../provider";

export enum GAS_PRICE_TYPE {
  NORMAL = "NORMAL",
  FAST = "FAST",
  INSTANT = "INSTANT",
}

export interface RETURN_TYPE_GAS_PRICES {
  [GAS_PRICE_TYPE.NORMAL]: bigint;
  [GAS_PRICE_TYPE.FAST]: bigint;
  [GAS_PRICE_TYPE.INSTANT]: bigint;
}

export async function getGasPrices(
  wallet: BetSwirlWallet,
  chainId?: number,
): Promise<RETURN_TYPE_GAS_PRICES> {
  const gasPrice = await wallet.getPublicClient(chainId).getGasPrice();
  const basePrice = gasPrice ? BigInt(gasPrice) : BigInt(1000000000);

  return {
    [GAS_PRICE_TYPE.NORMAL]: basePrice,
    [GAS_PRICE_TYPE.FAST]: (basePrice * 120n) / 100n, // 20%
    [GAS_PRICE_TYPE.INSTANT]: (basePrice * 150n) / 100n, // 50%
  };
}
</file>

<file path="packages/core/src/read/common/tokenMetadata.ts">
import {
  type Address,
  type Hex,
  encodeFunctionData,
  erc20Abi,
  getAddress,
  zeroAddress,
} from "viem";
import { type ChainId, chainById } from "../../data/chains";
import { ERROR_CODES } from "../../errors/codes";
import { TransactionError } from "../../errors/types";
import type { BetSwirlFunctionData, Token } from "../../interfaces";
import type { BetSwirlWallet } from "../../provider";
import { chainNativeCurrencyToToken } from "../../utils/tokens";

export type RawTokenSymbol = string;
export type RawTokenDecimals = number;
export async function getTokenMetadata(
  wallet: BetSwirlWallet,
  tokenAddress: Hex,
  chainId: ChainId,
): Promise<Token> {
  if (tokenAddress === zeroAddress) {
    return chainNativeCurrencyToToken(chainById[chainId].nativeCurrency);
  }

  try {
    const functionDatas = [
      getTokenDecimalsFunctionData(tokenAddress),
      getTokenSymbolFunctionData(tokenAddress),
    ];
    const tokenMetadata = await wallet.readContracts<
      typeof functionDatas,
      [RawTokenDecimals, RawTokenSymbol]
    >(functionDatas);

    return {
      address: getAddress(tokenAddress),
      decimals: tokenMetadata[0],
      symbol: tokenMetadata[1] || "UNKNOWN",
    };
  } catch (error) {
    throw new TransactionError(
      `Error checking metdata of ${tokenAddress} on chain ${chainId}`,
      ERROR_CODES.TRANSACTION.TOKEN_METADATA_ERROR,
      {
        chainId,
        tokenAddress,
      },
    );
  }
}

export function getTokenDecimalsFunctionData(
  tokenAddress: Address,
): BetSwirlFunctionData<typeof erc20Abi, "decimals", readonly []> {
  const abi = erc20Abi;
  const functionName = "decimals" as const;
  const args = [] as const;
  return {
    data: { to: tokenAddress, abi, functionName, args },
    encodedData: encodeFunctionData({
      abi,
      functionName,
      args,
    }),
  };
}

export function getTokenSymbolFunctionData(
  tokenAddress: Address,
): BetSwirlFunctionData<typeof erc20Abi, "symbol", readonly []> {
  const abi = erc20Abi;
  const functionName = "symbol" as const;
  const args = [] as const;
  return {
    data: { to: tokenAddress, abi, functionName, args },
    encodedData: encodeFunctionData({
      abi,
      functionName,
      args,
    }),
  };
}
</file>

<file path="packages/core/src/utils/chains.ts">
import { casinoChainById } from "../data/casino";
import type { CasinoChainId } from "../data/casino";
import { ERROR_CODES } from "../errors/codes";
import { ChainError } from "../errors/types";
import type { BetSwirlWallet } from "../provider";

export function getCasinoChainId(
  wallet: BetSwirlWallet,
  ...overridedChainIds: Array<number | undefined>
): CasinoChainId {
  const chainId = overridedChainIds?.find((id) => id !== undefined) || wallet.getChainId();
  if (chainId && !(chainId in casinoChainById)) {
    throw new ChainError(
      `Chain ID ${chainId} is not compatible with casino games`,
      ERROR_CODES.CHAIN.UNSUPPORTED_CHAIN,
      {
        chainId,
        supportedChains: Object.keys(casinoChainById),
      },
    );
  }
  return chainId as CasinoChainId;
}
</file>

<file path="packages/core/src/utils/format.ts">
import Decimal from "decimal.js";
import { formatUnits } from "viem";

/**
 * Formats a number or string representation of a number into a more readable string format,
 * with support for large numbers and optional control over decimal places and minimum displayable values.
 *
 * @param {string | number} input - The number or string representation of a number to be formatted.
 * @param {number} [maxDecimals=2] - The maximum number of decimal places to display after the decimal point.
 * @param {number} [minValue=1e-5] - The minimum value to display. Values smaller than this threshold will be shown as "< minValue".
 * @param {number} [trailingDecimals=2] - The number of decimal places to retain even if they are trailing zeros.
 *
 * @returns {string} - The formatted number as a string, potentially with a suffix indicating large numbers (e.g., "M" for million, "B" for billion).
 *
 * @example
 * // Small number with default params
 * formatAmount(123.456); // returns "123.46"
 *
 * @example
 * // Small number with max decimals
 * formatAmount(123.456, 1); // returns "123.5"
 *
 * @example
 * // Small number with a min value
 * formatAmount(0.000004, 2, 1e-5); // returns "< 0.00001"
 *
 * @example
 * // Large number with default params
 * formatAmount(123456789); // returns "123.46M"
 *
 * @example
 * // Large numbers with 4 decimals & trailing zeros
 * formatAmount(123.4000, 4, 1e-5, 4); // returns "123.4000"
 *
 * @example
 * // Large number with 3 decimals BUT 2 traling zeros
 * formatAmount(1500000000, 3, 1e-5, 2); // returns "1.50B"
 */
function _formatAmount(
  input: string | number,
  maxDecimals = 2, // Maximum decimals after the dot
  minValue = 1e-5, // Minimum displayable value
  trailingDecimals = 2, // Maximum decimals after the dot to keep even if they are trailing zero
): string {
  const amount = new Decimal(input);
  // Check min value
  if (amount.gt(0) && amount.lt(minValue)) {
    return `<${minValue}`;
  }

  let divisor = new Decimal(1);
  let suffix = "";
  // If number if larger or equals to 1 million, then format it
  if (amount.gte(1e6)) {
    const suffixes = ["M", "B", "T", "Qa", "Qi", "Sx", "Sp"];
    const thresholds = [1e6, 1e9, 1e12, 1e15, 1e18, 1e21, 1e24];
    // Find the most appropriate suffix
    const index = thresholds.findIndex((threshold) =>
      amount.lt(new Decimal(threshold).times(1000)),
    );
    divisor = new Decimal(thresholds[index]!);
    suffix = suffixes[index]!;
  }

  // Format the number with max decimals
  let formattedNumber = amount.div(divisor).toFixed(maxDecimals);

  // Remove some trailing zeros if needed
  if (trailingDecimals < maxDecimals) {
    const [integerPart, decimalPart] = formattedNumber.split(".");
    if (decimalPart) {
      const significantPart = decimalPart.slice(0, trailingDecimals);
      // Remove all trailing zeros in the trailed part
      const trailedPart = decimalPart.slice(trailingDecimals).replace(/0+$/, "");
      formattedNumber = Number(decimalPart)
        ? `${integerPart}.${significantPart}${trailedPart}`
        : (integerPart ?? "0");
    }
  }
  const finalFormattedNumber = formattedNumber + suffix;
  // If string equals zero, returns "0" to avoid to have "0.00", etc
  return Number(finalFormattedNumber) === 0 ? "0" : finalFormattedNumber;
}

export function formatAmount(
  amount: string | number | undefined,
  formatType: FORMAT_TYPE = FORMAT_TYPE.STANDARD,
) {
  const value = amount || 0;
  const { maxDecimals, minValue, trailingDecimals } = formatTypes[formatType];
  return _formatAmount(value, maxDecimals, minValue, trailingDecimals);
}

export function formatRawAmount(
  rawAmount: bigint | undefined,
  decimals = 18,
  formatType: FORMAT_TYPE = FORMAT_TYPE.STANDARD,
) {
  const value = rawAmount || 0n;
  const amount = formatUnits(BigInt(value), decimals);
  return formatAmount(amount, formatType);
}
interface FormatOptions {
  maxDecimals: number;
  minValue: number;
  trailingDecimals: number;
}

export enum FORMAT_TYPE {
  MINIFY = "minify",
  STANDARD = "standard",
  PRECISE = "precise",
  FULL_PRECISE = "full_precise",
}

export const formatTypes: Record<FORMAT_TYPE, FormatOptions> = {
  [FORMAT_TYPE.MINIFY]: {
    maxDecimals: 2,
    minValue: 1e-2,
    trailingDecimals: 0,
  },
  [FORMAT_TYPE.STANDARD]: {
    maxDecimals: 4,
    minValue: 1e-4,
    trailingDecimals: 2,
  },
  [FORMAT_TYPE.PRECISE]: { maxDecimals: 9, minValue: 1e-9, trailingDecimals: 2 },
  [FORMAT_TYPE.FULL_PRECISE]: {
    maxDecimals: 18,
    minValue: 1e-18,
    trailingDecimals: 3,
  },
};
</file>

<file path="packages/core/src/utils/subgraphs.ts">
export const replaceGraphQlKey = (endpoint: string, key: string) => {
  const updatedEndpoint = endpoint.includes("{key}") ? endpoint.replace("{key}", key) : endpoint;
  return updatedEndpoint;
};
</file>

<file path="packages/core/src/utils/tokens.ts">
import { type Address, zeroAddress } from "viem";
import { GAS_TOKEN_ADDRESS } from "../constants";
import { casinoChainById, chainById } from "../data";
import type { CasinoChainId, ChainId } from "../data";
import type { RawToken, Token } from "../interfaces";

type ChainNativeCurrency = {
  name: string;
  symbol: string;
  decimals: number;
};
export function chainNativeCurrencyToToken(nativeCurrency: ChainNativeCurrency): Token {
  return {
    symbol: nativeCurrency.symbol,
    address: zeroAddress,
    decimals: nativeCurrency.decimals,
  };
}

export function formatTokenUrl(tokenAddress: Address, chainId: ChainId) {
  const chain = chainById[chainId];
  return `${chain.blockExplorers?.default.url}/token/${tokenAddress}`;
}

export function rawTokenToToken(rawToken: RawToken, casinoChainId: CasinoChainId): Token {
  const casinoChain = casinoChainById[casinoChainId];
  return {
    address: rawToken.tokenAddress,
    symbol:
      rawToken.tokenAddress === GAS_TOKEN_ADDRESS
        ? casinoChain.viemChain.nativeCurrency.symbol
        : rawToken.symbol,
    decimals: rawToken.decimals,
  };
}
</file>

<file path="packages/core/src/utils/wallet.ts">
import type { Hash } from "viem";
import { ERROR_CODES, TransactionError } from "../errors";
import type { BetSwirlWallet } from "../provider";

export async function getTransactionReceiptWithRetry(
  wallet: BetSwirlWallet,
  txHash: Hash,
  retries: number[] = [
    250, 500, 750, 1000, 1250, 1500, 1750, 2000, 2500, 3000, 3500, 4000, 4500, 5000,
  ],
) {
  let lastError: Error | undefined;

  for (const delay of retries) {
    try {
      const receipt = wallet.getTransactionReceipt(txHash);
      return receipt;
    } catch (error) {
      lastError = error as Error;
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
  }

  throw new TransactionError(
    "Get transaction recript failfor all retries",
    ERROR_CODES.WALLET.GET_TRANSACTION_RECEIPT_ERROR,
    {
      hash: txHash,
      chainId: wallet.getChainId(),
      retries,
    },
  );
}
</file>

<file path="packages/core/src/constants.ts">
import { zeroAddress } from "viem";

export const BP_VALUE = 10000;
export const DEFAULT_ADMIN_ROLE =
  "0x0000000000000000000000000000000000000000000000000000000000000000";

export const DEFAULT_PAGE = 1;
export const DEFAULT_ITEMS_PER_PAGE = 25;
export const GAS_TOKEN_ADDRESS = zeroAddress;
export const BETSWIRL_BASE_URL = "https://betswirl.com";
</file>

<file path="packages/core/src/index.ts">
export * from "./abis";
export * from "./actions";
export * from "./provider";
export * from "./data";
export * from "./entities";
export * from "./errors";
export * from "./read";
export * from "./utils";
export * from "./interfaces";
export * from "./constants";
</file>

<file path="packages/core/src/interfaces.ts">
import type { Abi, Address, ContractEventName, ContractFunctionName, Hash, Hex, Log } from "viem";
import type { CASINO_GAME_TYPE, CasinoChainId } from "./data/casino";

export interface BetSwirlFunctionData<
  TAbi extends Abi,
  TFunctionName extends ContractFunctionName<TAbi>,
  TArgs extends readonly any[],
> {
  data: {
    to: Address;
    abi: TAbi;
    functionName: TFunctionName;
    args: TArgs;
  };
  encodedData: Hex;
}
export interface BetSwirlEventData<
  TAbi extends Abi,
  TEventName extends ContractEventName<TAbi>,
  TArgs extends Record<string, any>,
> {
  data: {
    to: Address;
    abi: TAbi;
    eventName: TEventName;
    args: TArgs;
    pollingInterval: number;
  };
  callbacks: {
    onLogs?: (logs: Log[]) => Promise<void> | void;
    onError?: (error: Error) => Promise<void> | void;
  };
}

export type RawToken = {
  symbol: string;
  tokenAddress: Hex;
  decimals: number;
};

export type Token = {
  symbol: string;
  address: Hex;
  decimals: number;
};

export interface CasinoGame {
  game: CASINO_GAME_TYPE;
  label: string;
  gameAddress: Hex;
  bankAddress: Hex;
  abi: Abi;
  paused: boolean;
  chainId: CasinoChainId;
}

export interface HouseEdgeSplit {
  bank: number; // 0 to 10 000 (10 000 = 100%)
  bankPercent: number;
  dividend: number; // 0 to 10 000 (10 000 = 100%)
  dividendPercent: number;
  affiliate: number; // 0 to 10 000 (10 000 = 100%)
  affiliatePercent: number;
  treasury: number; // 0 to 10 000 (10 000 = 100%)
  treasuryPercent: number;
  team: number; // 0 to 10 000 (10 000 = 100%)
  teamPercent: number;
}

export interface CasinoToken extends Token {
  paused: boolean;
  balanceRisk: number; // 1 to 10 000
  balanceRiskPercent: number;
  bankrollProvider: Hex; // Owner of the token bankroll
  houseEdgeSplit: HouseEdgeSplit;
  chainId: CasinoChainId;
}

export interface CasinoGameToken extends CasinoToken {
  game: CASINO_GAME_TYPE;
  defaultHouseEdge: number; // 1 to 3500 (3500 = 35%)
  defaultHouseEdgePercent: number;
  affiliateHouseEdge: number; // 1 to 3500 (3500 = 35%)
  affiliateHouseEdgePercent: number;
  chainlinkVrfSubscriptionId: bigint;
}

export interface BetRequirements {
  token: Token;
  multiplier: number;
  maxBetAmount: bigint;
  maxBetCount: number;
  isAllowed: boolean;
  chainId: CasinoChainId;
}

// Subgraph types
export interface CasinoBet {
  id: bigint;
  token: Token;
  nativeCurrency: Token;
  chainId: CasinoChainId;
  game: CASINO_GAME_TYPE;
  gameAddress: Address;
  bettor: Address;
  betAmount: bigint;
  formattedBetAmount: string;
  totalBetAmount: bigint;
  formattedTotalBetAmount: string;
  betCount: number;
  stopLoss: bigint;
  formattedStopLoss: string;
  stopGain: bigint;
  formattedStopGain: string;
  houseEdge: number; // BP
  betTimestampSecs: number; // secs
  betDate: Date;
  chargedVRFFees: bigint;
  formattedChargedVRFFees: string;
  betTxnHash: Hash;
  encodedInput: string;
  decodedInput: any;
  payout?: bigint;
  formattedPayout?: string;
  formattedPayoutMultiplier?: number;
  benefit?: bigint;
  formattedBenefit?: string;
  rollTxnHash?: Hash;
  rollTimestampSecs?: number;
  rollDate?: Date;
  isResolved: boolean;
  isRefunded: boolean;
  rollTotalBetAmount?: bigint;
  fomattedRollTotalBetAmount?: string;
  rollBetCount?: number;
  encodedRolled?: Array<string>;
  decodedRolled?: Array<any>;
  affiliate?: Address;
  isWin?: boolean;
  isLost?: boolean;
  isStopLossTriggered?: boolean;
  isStopGainTriggered?: boolean;
}

export interface SubgraphToken {
  id: Address;
  address: Address;
  chainId: CasinoChainId;
  symbol: string;
  name: string;
  decimals: number;
  betTxnCount: number;
  betCount: number;
  winTxnCount: number;
  userCount: number;
  totalWagered: bigint;
  formattedTotalWagered: string;
  totalPayout: bigint;
  formattedTotalPayout: string;
  dividendAmount: bigint;
  formattedDividendAmount: string;
  bankAmount: bigint;
  formattedBankAmount: string;
  affiliateAmount: bigint;
  formattedAffiliateAmount: string;
  treasuryAmount: bigint;
  formattedTreasuryAmount: string;
  teamAmount: bigint;
  formattedTeamAmount: string;
}
</file>

<file path="packages/core/codegen.ts">
import type { CodegenConfig } from "@graphql-codegen/cli";

const config: CodegenConfig = {
  ignoreNoDocuments: false, // for better experience with the watcher
  generates: {
    // Protocol types.ts
    "src/data/subgraphs/protocol/documents/types.ts": {
      schema: "https://api.studio.thegraph.com/query/1726/betswirl-avalanche/v2.2.0",
      plugins: ["typescript"],
    },
    // Protocol each query
    "src/data/subgraphs/protocol/documents": {
      preset: "near-operation-file",
      schema: "https://api.studio.thegraph.com/query/1726/betswirl-avalanche/v2.2.0",
      documents: ["src/data/subgraphs/protocol/documents/**/*.graphql"],
      presetConfig: {
        extension: ".ts",
        baseTypesPath: "types.ts",
      },
      plugins: ["typescript-operations", "typescript-document-nodes"],
      config: {
        withHooks: false,
        nameSuffix: "Document",
        fragmentSuffix: "FragmentDoc",
        scalars: {
          BigInt: "string",
          BigDecimal: "string",
        },
      },
    },
  },
};

export default config;
</file>

<file path="packages/core/README.md">
# @betswirl/sdk-core

VanillaJS library to use Betswirl protocol

## Installation

```bash
npm i @betswirl/sdk-core viem @apollo/client
```
## Usage

### 1.With an external BetSwirl client

Using the sdk with an external BetSwirl client helps you to reduce your codebase and use your favorite compatible viem wallet.
Here is the list of available external clients:

- [Wagmi (@betswirl/wagmi-provider)](https://www.npmjs.com/package/@betswirl/wagmi-provider)

The example below uses the BetSwirl Wagmi client.

```typescript
import { createConfig } from "@wagmi/core";
import { initWagmiBetSwirlClient} from "@betswirl/wagmi-provider";

  /* Init Wagmi BetSwirl client */
  const wagmiConfig = createConfig(...)

  const wagmiBetSwirlClient = initWagmiBetSwirlClient(wagmiConfig, {
    chainId: 137,
    affiliate: "0x...",
    gasPriceType: GAS_PRICE_TYPE.FAST,
    ...
  });

  /* Use the client */
  const casinoGames = await wagmiBetSwirlClient.getCasinoGames(false, 137);
  ...
  wagmiBetSwirlClient.playDice(77, ...)
  ...

```


### 2. With the native BetSwirl client (Viem)

Using the sdk with the native BetSwirl Viem client helps you to reduce your codebase.
**walletClient** is optional if you only need to read data.

```typescript
import { http, createWalletClient, createPublicClient } from "viem";
import { initViemBetSwirlClient } from "@betswirl/sdk-core";

  /* Create the Viem clients */
  const account = privateKeyToAccount("0x...");
  const transport = http("https://...")

  const publicClient = createPublicClient({
    chain: casinoChain.viemChain,
    transport,
  });

  const walletClient = createWalletClient({
    chain: casinoChain.viemChain,
    transport,
    account,
  })

  /* Create the native BetSwirl client */
  const viemBetSwirlClient = initViemBetSwirlClient(publicClient, walletClient, {
    chainId: 137,
    affiliate: "0x...",
    gasPriceType: GAS_PRICE_TYPE.FAST,
    ...
  })

  /* Use the native BetSwirl client */
  const casinoGames = await viemBetSwirlClient.getCasinoGames(false);
  ...
  viemBetSwirlClient.playDice(77, ...)
  ...

```

### 3. Without a client (only a wallet)
Using the sdk withtout a client doesn't let you to centralize all your options in one place. It's more appropriate for projects using only one or two sdk functions. The example below uses the BetSwirl viem wallet, which is native to the sdk. **walletClient** is optional if you only need to read data.


```typescript
import { http, createWalletClient, createPublicClient } from "viem";
import { initViemBetSwirlClient } from "@betswirl/sdk-core";

  /* Create the Viem clients */
  const account = privateKeyToAccount("0x...");
  const transport = http("https://...")

  const publicClient = createPublicClient({
    chain: casinoChain.viemChain,
    transport,
  });

  const walletClient = createWalletClient({
    chain: casinoChain.viemChain,
    transport,
    account,
  })
  

  /* Create the native BetSwirl wallet */
  const viemBetSwirlWallet = new ViemBetSwirlWallet(publicClient, walletClient)

  /* Use functionalities with the wallet*/
  const casinoGames = await getCasinoGames(viemBetSwirlWallet, false);
  ...
  placeDiceBet(viemBetSwirlWallet, 77, ...)
  ...

```

### 4. Using function data
Getting function data doesn't require you to use a client or a wallet. It's particularly useful for frontend projects (React, Vue, etc) or IA agents plugins (Goat, AgentKit, Moxie, etc). The example below shows the placeBet function used in the Moxie BetSwirl plugin to place a bet.


```typescript
import { MoxieWalletClient } from "@moxie-protocol/moxie-lib/src/wallet";
import {
    CASINO_GAME_TYPE,
    type CasinoChainId,
    GameEncodedInput,
    getPlaceBetFunctionData,
} from "@betswirl/sdk-core";
export async function placeBet(
    moxieWalletClient: MoxieWalletClient,
    game: CASINO_GAME_TYPE,
    gameEncodedInput: GameEncodedInput,
    gameMultiplier: number,
    casinoGameParams: {
        betAmount: bigint;
        betToken: Hex;
        betCount: number;
        receiver: Hex;
        stopGain: bigint;
        stopLoss: bigint;
    }
) {
    const chainId = Number(
        (await moxieWalletClient.wallet.provider.getNetwork()).chainId
    ) as CasinoChainId;
    // getBetRequirements is a custom function built in the BetSwirl plugin
    const betRequirements = await getBetRequirements(
        moxieWalletClient,
        game,
        casinoGameParams.betToken,
        gameMultiplier
    );

    if (!betRequirements.isAllowed) {
        throw new Error(`The token isn't allowed for betting`);
    }

    if (casinoGameParams.betAmount > betRequirements.maxBetAmount) {
        throw new Error(
            `Bet amount should be less than ${betRequirements.maxBetAmount}`
        );
    }
    if (casinoGameParams.betCount > betRequirements.maxBetCount) {
        throw new Error(
            `Bet count should be less than ${betRequirements.maxBetCount}`
        );
    }

    const functionData = getPlaceBetFunctionData(
        {
            betAmount: casinoGameParams.betAmount,
            game,
            gameEncodedInput: gameEncodedInput,
            receiver: casinoGameParams.receiver,
            betCount: casinoGameParams.betCount,
            tokenAddress: casinoGameParams.betToken,
            stopGain: casinoGameParams.stopGain,
            stopLoss: casinoGameParams.stopLoss,
        },
        chainId
    );

    try {
        const gasPrice =
            ((await moxieWalletClient.wallet.provider.getFeeData()).gasPrice *
                120n) /
            100n;

    // getChainlinkVrfCost is a custom function built in the BetSwirl plugin
        const vrfCost =
            (await getChainlinkVrfCost(
                moxieWalletClient,
                game,
                casinoGameParams.betToken,
                casinoGameParams.betCount,
                gasPrice
            ))
        const { hash: betHash } = await moxieWalletClient.sendTransaction(
            chainId.toString(),
            {
                toAddress: functionData.data.to,
                data: functionData.encodedData,
                value: functionData.extraData.getValue(vrfCost)
                gasPrice: Number(gasPrice),
            }
        );

        return betHash as Hex;
    } catch (error) {
        throw new Error(
            `An error occured while placing the bet: $${error.shortMessage || error.message}`
        );
    }
}

```

## Examples

- [NodeJs CLI using Wagmi external client](https://github.com/BetSwirl/sdk/tree/main/examples/node)
- [Goat plugin using function data](https://github.com/goat-sdk/goat/pull/392)
- [Moxie plugin using function data](https://github.com/moxie-protocol/moxie-agent-skills/pull/11)
</file>

<file path="packages/core/tsconfig.build.json">
{
  "extends": "../../tsconfig.base.json",
  "include": ["src/**/*.ts"],
  "exclude": ["src/**/*.test.ts", "src/**/*.test-d.ts", "src/**/documents/**/*.ts"],
  "compilerOptions": {
    "sourceMap": true
  }
}
</file>

<file path="packages/core/tsconfig.json">
{
  "extends": "./tsconfig.build.json",
  "include": ["src/**/*.ts", "test/**/*.ts"],
  "exclude": []
}
</file>

<file path="packages/core/tsup.config.ts">
import { defineConfig } from "tsup";

declare const process: {
  env: {
    NODE_ENV: string;
  };
};

export default defineConfig({
  entry: ["src/index.ts"],
  format: ["esm", "cjs"],
  dts: {
    compilerOptions: {
      incremental: false,
      noUnusedLocals: false,
    },
  },
  splitting: true,
  clean: true,
  shims: true,
  outDir: "dist",
  minify: process.env.NODE_ENV === "production",
  sourcemap: true,
  bundle: true,
  outExtension: ({ format }) => ({
    js: format === "esm" ? ".mjs" : ".cjs",
  }),
  treeshake: true,
});
</file>

<file path="packages/core/turbo.json">
{
  "$schema": "https://turbo.build/schema.json",
  "extends": ["//"],
  "tasks": {
    "build": {
      "inputs": ["src/**", "tsup.config.ts", "!./**/*.test.{ts,tsx}", "tsconfig.json"],
      "dependsOn": ["^build"],
      "outputs": ["dist/**"]
    }
  }
}
</file>

<file path="packages/providers/wagmi/src/index.ts">
export * from "./client";
export * from "./wallet";
</file>

<file path="packages/providers/wagmi/README.md">
# @betswirl/wagmi-provider

A provider allowing to use **@betswirl/sdk-core** through a Wagmi client.

## Installation

```bash
pnpm i @betswirl/wagmi-provider
```

## Usage
```typescript
import { createConfig } from "@wagmi/core";
import { initWagmiBetSwirlClient} from "@betswirl/wagmi-provider";

  /* Init the client */
  const wagmiConfig = createConfig(...)

  const wagmiBetSwirlClient = initWagmiBetSwirlClient(wagmiConfig, {
    chainId: 137,
    affiliate: "0x...",
    gasPriceType: GAS_PRICE_TYPE.FAST,
    ...
  });

  /* Use the client */
  const casinoGames = await wagmiBetSwirlClient.getCasinoGames(false, 137);
  ...
  wagmiBetSwirlClient.playDice(77, ...)
  ...

```

## Example

- [NodeJs CLI](https://github.com/BetSwirl/sdk/tree/main/examples/node)
</file>

<file path="packages/providers/wagmi/tsconfig.json">
{
  "extends": "./tsconfig.build.json",
  "include": ["src/**/*.ts", "test/**/*.ts"],
  "exclude": []
}
</file>

<file path="packages/providers/wagmi/turbo.json">
{
  "$schema": "https://turbo.build/schema.json",
  "extends": ["//"],
  "tasks": {
    "build": {
      "inputs": ["src/**", "tsup.config.ts", "!./**/*.test.{ts,tsx}", "tsconfig.json"],
      "dependsOn": ["^build"],
      "outputs": ["dist/**"]
    }
  }
}
</file>

<file path="betswirl.code-workspace">
{
  "folders": [
    {
      "path": "."
    }
  ],
  "settings": {
    "editor.formatOnSave": true,
    "editor.defaultFormatter": "biomejs.biome",
    "[typescript]": {
      "editor.defaultFormatter": "biomejs.biome"
    },
    "[javascript]": {
      "editor.defaultFormatter": "biomejs.biome"
    },
    "[json]": {
      "editor.defaultFormatter": "biomejs.biome"
    }
  }
}
</file>

<file path="biome.json">
{
  "$schema": "https://biomejs.dev/schemas/1.9.4/schema.json",
  "vcs": {
    "enabled": false,
    "clientKind": "git",
    "useIgnoreFile": false
  },
  "files": {
    "ignoreUnknown": false,
    "ignore": [
      "dist/**/*",
      "node_modules/**/*",
      ".turbo/**/*",
      "**/tsconfig*.json",
      "**/documents/**/*.ts"
    ]
  },
  "formatter": {
    "enabled": true,
    "indentStyle": "space",
    "indentWidth": 2,
    "lineWidth": 100
  },
  "organizeImports": {
    "enabled": true
  },
  "linter": {
    "enabled": true,
    "rules": {
      "recommended": true,
      "correctness": {
        "noUnusedImports": "warn",
        "useExhaustiveDependencies": "warn"
      },
      "style": {
        "useImportType": "off",
        "noNonNullAssertion": "off"
      },
      "suspicious": {
        "noExplicitAny": "off"
      }
    }
  },
  "javascript": {
    "formatter": {
      "quoteStyle": "double"
    },
    "parser": {
      "unsafeParameterDecoratorsEnabled": true
    }
  }
}
</file>

<file path="pnpm-workspace.yaml">
packages:
  - 'packages/core'
  - 'packages/providers/*'
  - 'examples/*'

catalog:
    viem: ^2.22.23
</file>

<file path="README.md">
# 🌀BetSwirl SDKs

**BetSwirl** is a decentralized protocol allowing to play casino games on multiple chains. 

The goal of this repo is to give developers some tools to interact easily with the protocol. 

Feel free to reach us via [Discord](https://discord.gg/4BxtJV7fbZ) or [Telegram](https://t.me/betswirl) if you need **support**!


## General
### Networks
- **Arbitrum**
- **Avalanche**
- **Base**
- **Binance Smart Chain**
- **Polygon**
- Arbitrum Sepolia
- Avalanche Fuji
- Base Sepolia
- Binance Smart Chain Testnet
- Polygon Amoy

### Deployed contracts

All our mainnets contracts have the same address on each network:

- **Bank** `0x8FB3110015FBCAA469ee45B64dcd2BdF544B9CFA`
- **CoinToss** `0xC3Dff2489F8241729B824e23eD01F986fcDf8ec3`
- **Dice** `0xAa4D2931a9fE14c3dec8AC3f12923Cbb535C0e5f`
- **Roulette** `0x6678e3B4AB2a8C8Cdd068F132C21293CcBda33cb`
- **Keno** `0xc3428E4FEb5C770Db51DCb9B1C08223B10994a89`

=> You can find more info and the deployed testnet contracts [here](https://github.com/BetSwirl/sdk/blob/main/packages/core/src/data/casino.ts)
  
### Subgraphs
- **[Arbitrum](https://thegraph.com/explorer/subgraphs/AsPBS4ymrjoR61r1x2avNJJtMPvzZ3quMHxvQTgDJbU?view=Query&chain=arbitrum-one)**
- **[Avalanche](https://thegraph.com/explorer/subgraphs/4nQJ4T5TXvTxgECqQ6ox6Nwf57d5BNt6SCn7CzzxjDZN?view=Query&chain=arbitrum-one)**
- **[Base](https://thegraph.com/explorer/subgraphs/6rt22DL9aaAjJHDUZ25sSsPuvuKxp1Tnf8LBXhL8WdZi?view=Query&chain=arbitrum-one)**
- **[Binance Smart Chain](https://thegraph.com/explorer/subgraphs/69xMkatN58qWXZS7FXqiVQmvkHhNrq3thTfdB6t85Wvk?view=Query&chain=arbitrum-one)**
- **[Polygon](https://thegraph.com/explorer/subgraphs/FL3ePDCBbShPvfRJTaSCNnehiqxsPHzpLud6CpbHoeKW?view=Query&chain=arbitrum-one)**

=> You can find more info and the testnet subgraph query urls [here](https://github.com/BetSwirl/sdk/blob/main/packages/core/src/data/casino.ts)
  
### Audits

**[Paladin](https://paladinsec.co/)** is our main auditor and has done 3 audits:
- 07/2024 Bank & Casino games
- 10/2024 PvP games & Wheel game
- 11/2024 Leaderboard & Freebet

=> Consult the audit results [here](https://paladinsec.co/projects/betswirl/)

### Randomness
We use **[Chainlink VRF 2.5](https://docs.chain.link/vrf)** to manage randomness. This is why a small fee in native token is requested for each bet. Here is the list of our subscriptions:

- **[Arbitrum](https://vrf.chain.link/arbitrum#/side-drawer/subscription/arbitrum/26510450093329368004237878416199508562205945994063563127634409219041040756566)**
- **[Avalanche](https://vrf.chain.link/avalanche#/side-drawer/subscription/avalanche/87060360337790157170135218934045586905659360396458026876115663885747477615369)**
- **[Base](https://vrf.chain.link/base#/side-drawer/subscription/base/93271074453882857048982544254580571499844752099945152824703671195862788259559)**
- **[Binance Smart Chain](https://vrf.chain.link/bsc#/side-drawer/subscription/bsc/64778934296371996396369853439912130360272408155611603044356319460986888838555)**
- **[Polygon](https://vrf.chain.link/polygon#/side-drawer/subscription/polygon/79838174144652451313763716789896498714546673967850869672884710820136443316484)**

## Contribution

### Installation

```bash
pnpm install
```

Install Biome extension 
### Local changes

If you updated a package and you want to see the changes in the other packages, then run this command in the updated package:

```bash
pnpm run build
```

=> The dependencies of the other packages will automatically be updated with the new version.

### Publishing

```bash
pnpm change:version
pnpm change:publish
```
</file>

<file path="tsconfig.base.json">
{
  // This tsconfig file contains the shared config for the build (tsconfig.build.json) and type checking (tsconfig.json) config.
  "include": [],
  "compilerOptions": {
    // Incremental builds
    // NOTE: Enabling incremental builds speeds up `tsc`. Keep in mind though that it does not reliably bust the cache when the `tsconfig.json` file changes.
    "incremental": true,

    // Type checking
    "strict": true,
    "noFallthroughCasesInSwitch": true, // Not enabled by default in `strict` mode.
    "noImplicitOverride": true, // Not enabled by default in `strict` mode.
    "noImplicitReturns": true, // Not enabled by default in `strict` mode.
    "noUncheckedIndexedAccess": true,
    "noUnusedLocals": true, // Not enabled by default in `strict` mode.
    "noUnusedParameters": true, // Not enabled by default in `strict` mode.
    "useDefineForClassFields": true, // Not enabled by default in `strict` mode unless we bump `target` to ES2022.
    "useUnknownInCatchVariables": true,
    "resolveJsonModule": true,
    "allowImportingTsExtensions": true,


    // JavaScript support
    "allowJs": false,
    "checkJs": false,

    // Interop constraints
    "forceConsistentCasingInFileNames": true,
    "verbatimModuleSyntax": true,

    // Language and environment
    "moduleResolution": "node",
    "target": "es2021", // Setting this to `ES2021` enables native support for `Node v16+`: https://github.com/microsoft/TypeScript/wiki/Node-Target-Mapping.
    "lib": [
      "ES2022", // By using ES2022 we get access to the `.cause` property on `Error` instances.
      "DOM" // We are adding `DOM` here to get the `fetch`, etc. types. This should be removed once these types are available via DefinitelyTyped.
    ],

    // Skip type checking for node modules
    "skipLibCheck": true,
    "noErrorTruncation": true
  }
}
</file>

<file path="turbo.json">
{
  "$schema": "https://turbo.build/schema.json",
  "tasks": {
    "build": {
      "env": ["NODE_ENV"],
      "outputLogs": "new-only",
      "dependsOn": ["^build"],
      "outputs": ["dist/**"]
    },
    "test": {
      "dependsOn": ["build"],
      "outputs": []
    },
    "lint": {
      "outputs": []
    },
    "clean": {
      "cache": false,
      "outputs": []
    }
  }
}
</file>

<file path=".changeset/config.json">
{
  "$schema": "https://unpkg.com/@changesets/config@3.1.1/schema.json",
  "changelog": ["@changesets/changelog-github", { "repo": "betswirl/sdk" }],
  "commit": false,
  "fixed": [],
  "linked": [],
  "access": "public",
  "baseBranch": "main",
  "updateInternalDependencies": "patch"
}
</file>

<file path="examples/mini-app/.loki/.gitignore">
current
difference
</file>

<file path="examples/mini-app/src/assets/game/game-result/loss-icon.svg">
<svg width="25" height="33" viewBox="0 0 25 33" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M0.270508 24.9548H23.7292V31.0155C23.7292 31.854 23.0494 32.5338 22.2109 32.5338H1.78879C0.950265 32.5338 0.270508 31.854 0.270508 31.0155V24.9548Z" fill="#FF565A"/>
<path d="M6.63723 30.2533V26.6616C6.63723 26.5808 6.83163 26.5403 7.22045 26.5403C7.61311 26.5403 7.80944 26.5808 7.80944 26.6616V29.4911H8.6987C8.76799 29.4911 8.81611 29.5815 8.84306 29.7625C8.85461 29.851 8.86039 29.9415 8.86039 30.0339C8.86039 30.1263 8.85461 30.2206 8.84306 30.3168C8.81227 30.5016 8.76222 30.594 8.69293 30.594H6.9144C6.82971 30.594 6.76234 30.5593 6.7123 30.4901C6.66225 30.4208 6.63723 30.3418 6.63723 30.2533ZM10.9194 30.6517C10.3804 30.6517 9.93965 30.4747 9.59703 30.1205C9.25827 29.7663 9.08888 29.2505 9.08888 28.5729C9.08888 27.8916 9.26019 27.3757 9.60281 27.0254C9.94927 26.6751 10.3939 26.4999 10.9367 26.4999C11.4833 26.4999 11.9241 26.6732 12.259 27.0196C12.594 27.3622 12.7614 27.8839 12.7614 28.5845C12.7614 29.2813 12.5901 29.801 12.2475 30.1436C11.9049 30.4824 11.4622 30.6517 10.9194 30.6517ZM10.9252 27.6086C10.7404 27.6086 10.5845 27.6933 10.4574 27.8627C10.3342 28.0321 10.2726 28.2707 10.2726 28.5787C10.2726 28.8828 10.3323 29.1177 10.4516 29.2832C10.571 29.4449 10.7269 29.5257 10.9194 29.5257C11.1157 29.5257 11.2735 29.443 11.3929 29.2774C11.5161 29.1119 11.5777 28.8751 11.5777 28.5672C11.5777 28.2592 11.5141 28.0224 11.3871 27.8569C11.2639 27.6914 11.1099 27.6086 10.9252 27.6086ZM13.3752 29.185C13.4483 29.2428 13.5734 29.3217 13.7505 29.4218C13.9315 29.5219 14.1028 29.5719 14.2644 29.5719C14.43 29.5719 14.5127 29.5084 14.5127 29.3814C14.5127 29.3236 14.4896 29.2736 14.4435 29.2312C14.3973 29.185 14.3126 29.1331 14.1894 29.0753C14.0662 29.0176 13.9738 28.9733 13.9122 28.9425C13.8506 28.9079 13.7678 28.854 13.6639 28.7808C13.5638 28.7038 13.4868 28.6249 13.4329 28.5441C13.2789 28.3246 13.2019 28.0455 13.2019 27.7068C13.2019 27.368 13.3271 27.0831 13.5773 26.8522C13.8314 26.6173 14.1624 26.4999 14.5705 26.4999C14.8477 26.4999 15.1037 26.5307 15.3385 26.5923C15.5733 26.6501 15.6946 26.727 15.7023 26.8233C15.7023 26.8348 15.7023 26.8464 15.7023 26.8579C15.7023 26.9927 15.6599 27.164 15.5752 27.3719C15.4906 27.5759 15.4309 27.6895 15.3962 27.7126C15.1499 27.5855 14.9285 27.522 14.7322 27.522C14.5397 27.522 14.4435 27.5913 14.4435 27.7299C14.4435 27.8146 14.5147 27.8896 14.6571 27.9551C14.6879 27.9705 14.7322 27.9916 14.7899 28.0186C14.8477 28.0455 14.9131 28.0783 14.9862 28.1168C15.0632 28.1514 15.1441 28.1976 15.2288 28.2553C15.3173 28.3092 15.4116 28.3824 15.5117 28.4748C15.7158 28.6673 15.8178 28.9213 15.8178 29.237C15.8178 29.6489 15.7042 29.9858 15.4771 30.2475C15.2499 30.5093 14.8996 30.644 14.4261 30.6517C14.1952 30.6517 13.9853 30.6325 13.7967 30.594C13.6119 30.5555 13.4502 30.4804 13.3117 30.3688C13.1731 30.2572 13.1038 30.1224 13.1038 29.9646C13.1038 29.8067 13.1327 29.6508 13.1904 29.4969C13.2481 29.339 13.3097 29.2351 13.3752 29.185ZM18.1694 28.1572C18.2426 28.1572 18.2791 28.2919 18.2791 28.5614C18.2791 28.6422 18.2695 28.7385 18.2502 28.8501C18.2349 28.9579 18.2041 29.0118 18.1579 29.0118H17.4245V29.5892H18.487C18.5524 29.5892 18.5967 29.6739 18.6198 29.8433C18.6314 29.9165 18.6371 29.9954 18.6371 30.0801C18.6371 30.1609 18.6256 30.2668 18.6025 30.3977C18.5794 30.5286 18.5409 30.594 18.487 30.594H16.5121C16.3659 30.594 16.2927 30.5343 16.2927 30.415V26.702C16.2927 26.6019 16.337 26.5519 16.4255 26.5519H18.4928C18.5736 26.5519 18.614 26.7232 18.614 27.0658C18.614 27.4046 18.5736 27.574 18.4928 27.574H17.4245V28.1572H18.1694Z" fill="white"/>
<circle cx="12.1966" cy="12.3404" r="10.9466" fill="#FFCC54"/>
<circle cx="12.1966" cy="12.3404" r="10.9466" fill="#FF565A"/>
<path d="M23.3255 11.7675C23.3099 14.3493 22.377 16.9628 20.5028 19.0752C16.4905 23.5973 9.68452 24.1107 5.30138 20.2218C2.40713 17.6539 1.29383 13.8087 2.02597 10.1907C2.00804 13.1363 3.1838 16.0408 5.51969 18.1134C9.90285 22.0023 16.7088 21.489 20.7211 16.9667C22.0842 15.4304 22.9489 13.629 23.3255 11.7675Z" fill="#E44B4E"/>
<path d="M12.3601 13.5594C13.4175 13.5594 14.4607 13.853 15.2567 14.4123L15.3307 14.4656C16.0875 15.0246 16.5821 15.8234 16.5821 16.7259C16.5821 17.0969 16.2813 17.3976 15.9104 17.3976C15.5394 17.3976 15.2387 17.0969 15.2387 16.7259C15.2387 16.3587 15.0444 15.9419 14.5807 15.5825L14.4844 15.5113C13.9487 15.1349 13.1858 14.9028 12.3601 14.9028C11.5859 14.9028 10.8671 15.1069 10.3388 15.4425L10.2358 15.5113C9.7025 15.886 9.48144 16.3342 9.48144 16.7259C9.48144 17.0969 9.18072 17.3976 8.80976 17.3976C8.43881 17.3976 8.13808 17.0969 8.13808 16.7259C8.13808 15.7943 8.66511 14.9733 9.46345 14.4123L9.53879 14.3606C10.3246 13.8349 11.3357 13.5594 12.3601 13.5594Z" fill="#5B1D1D"/>
<path d="M7.49039 8.76172C7.49039 8.89716 7.51709 9.03127 7.56892 9.15641C7.62076 9.28155 7.69672 9.39534 7.7925 9.49112C7.88828 9.5869 8.00207 9.66286 8.12721 9.7147C8.25235 9.76653 8.38646 9.79323 8.5219 9.79323C8.65734 9.79323 8.79145 9.76653 8.91659 9.7147C9.04174 9.66286 9.15552 9.5869 9.2513 9.49112C9.34709 9.39534 9.42305 9.28155 9.47488 9.15641C9.52671 9.03127 9.55341 8.89716 9.55341 8.76172H10.9208C10.9208 9.07671 10.8587 9.38864 10.7382 9.67966C10.6177 9.9707 10.4409 10.2352 10.2182 10.458C9.9954 10.6807 9.73088 10.8575 9.43984 10.978C9.14882 11.0986 8.83689 11.1606 8.5219 11.1606C8.20691 11.1606 7.89498 11.0986 7.60396 10.978C7.31292 10.8575 7.0484 10.6807 6.82565 10.458C6.60289 10.2352 6.42614 9.9707 6.30558 9.67966C6.18505 9.38864 6.12305 9.07671 6.12305 8.76172H7.49039Z" fill="#5B1D1D"/>
<path d="M15.1667 8.76172C15.1667 8.89716 15.1934 9.03127 15.2453 9.15641C15.2971 9.28155 15.373 9.39534 15.4688 9.49112C15.5646 9.5869 15.6784 9.66286 15.8035 9.7147C15.9287 9.76653 16.0628 9.79323 16.1982 9.79323C16.3337 9.79323 16.4678 9.76653 16.5929 9.7147C16.7181 9.66286 16.8319 9.5869 16.9276 9.49112C17.0234 9.39534 17.0994 9.28155 17.1512 9.15641C17.203 9.03127 17.2297 8.89716 17.2297 8.76172H18.5971C18.5971 9.07671 18.5351 9.38864 18.4145 9.67966C18.294 9.9707 18.1172 10.2352 17.8945 10.458C17.6717 10.6807 17.4072 10.8575 17.1162 10.978C16.8252 11.0986 16.5132 11.1606 16.1982 11.1606C15.8832 11.1606 15.5713 11.0986 15.2803 10.978C14.9893 10.8575 14.7247 10.6807 14.502 10.458C14.2792 10.2352 14.1025 9.9707 13.9819 9.67966C13.8614 9.38864 13.7994 9.07671 13.7994 8.76172H15.1667Z" fill="#5B1D1D"/>
<path d="M12.3601 13.5594C13.4175 13.5594 14.4607 13.853 15.2567 14.4123L15.3307 14.4656C16.0875 15.0246 16.5821 15.8234 16.5821 16.7259C16.5821 17.0969 16.2813 17.3976 15.9104 17.3976C15.5394 17.3976 15.2387 17.0969 15.2387 16.7259C15.2387 16.3587 15.0444 15.9419 14.5807 15.5825L14.4844 15.5113C13.9487 15.1349 13.1858 14.9028 12.3601 14.9028C11.5859 14.9028 10.8671 15.1069 10.3388 15.4425L10.2358 15.5113C9.7025 15.886 9.48144 16.3342 9.48144 16.7259C9.48144 17.0969 9.18072 17.3976 8.80976 17.3976C8.43881 17.3976 8.13808 17.0969 8.13808 16.7259C8.13808 15.7943 8.66511 14.9733 9.46345 14.4123L9.53879 14.3606C10.3246 13.8349 11.3357 13.5594 12.3601 13.5594Z" fill="#5B1D1D"/>
<path d="M7.49039 8.76172C7.49039 8.89716 7.51709 9.03127 7.56892 9.15641C7.62076 9.28155 7.69672 9.39534 7.7925 9.49112C7.88828 9.5869 8.00207 9.66286 8.12721 9.7147C8.25235 9.76653 8.38646 9.79323 8.5219 9.79323C8.65734 9.79323 8.79145 9.76653 8.91659 9.7147C9.04174 9.66286 9.15552 9.5869 9.2513 9.49112C9.34709 9.39534 9.42305 9.28155 9.47488 9.15641C9.52671 9.03127 9.55341 8.89716 9.55341 8.76172H10.9208C10.9208 9.07671 10.8587 9.38864 10.7382 9.67966C10.6177 9.9707 10.4409 10.2352 10.2182 10.458C9.9954 10.6807 9.73088 10.8575 9.43984 10.978C9.14882 11.0986 8.83689 11.1606 8.5219 11.1606C8.20691 11.1606 7.89498 11.0986 7.60396 10.978C7.31292 10.8575 7.0484 10.6807 6.82565 10.458C6.60289 10.2352 6.42614 9.9707 6.30558 9.67966C6.18505 9.38864 6.12305 9.07671 6.12305 8.76172H7.49039Z" fill="#5B1D1D"/>
<path d="M15.1667 8.76172C15.1667 8.89716 15.1934 9.03127 15.2453 9.15641C15.2971 9.28155 15.373 9.39534 15.4688 9.49112C15.5646 9.5869 15.6784 9.66286 15.8035 9.7147C15.9287 9.76653 16.0628 9.79323 16.1982 9.79323C16.3337 9.79323 16.4678 9.76653 16.5929 9.7147C16.7181 9.66286 16.8319 9.5869 16.9276 9.49112C17.0234 9.39534 17.0994 9.28155 17.1512 9.15641C17.203 9.03127 17.2297 8.89716 17.2297 8.76172H18.5971C18.5971 9.07671 18.5351 9.38864 18.4145 9.67966C18.294 9.9707 18.1172 10.2352 17.8945 10.458C17.6717 10.6807 17.4072 10.8575 17.1162 10.978C16.8252 11.0986 16.5132 11.1606 16.1982 11.1606C15.8832 11.1606 15.5713 11.0986 15.2803 10.978C14.9893 10.8575 14.7247 10.6807 14.502 10.458C14.2792 10.2352 14.1025 9.9707 13.9819 9.67966C13.8614 9.38864 13.7994 9.07671 13.7994 8.76172H15.1667Z" fill="#5B1D1D"/>
<path d="M12.1976 1.7937C17.9725 1.7937 22.654 6.25691 22.654 11.7626C22.654 11.8163 22.6526 11.8699 22.6517 11.9233C22.5616 6.49186 17.9162 2.28385 12.1976 2.28385C6.47903 2.28385 1.83328 6.49186 1.74319 11.9233C1.7423 11.8699 1.74121 11.8163 1.74121 11.7626C1.74121 6.25691 6.42271 1.7937 12.1976 1.7937Z" fill="#E44B4E"/>
<path d="M16.9887 4.93541C16.286 5.52526 18.5171 7.17665 18.9173 6.72447C19.3176 6.27222 17.8774 4.1893 16.9887 4.93541Z" fill="#FFDCDD"/>
<circle cx="12.1969" cy="12.2498" r="10.749" stroke="#1C1F21" stroke-width="0.721804"/>
<circle cx="12.1959" cy="12.2496" r="10.749" stroke="#2D0C0B" stroke-width="0.721804"/>
</svg>
</file>

<file path="examples/mini-app/src/assets/game/game-result/win-icon.svg">
<svg width="28" height="35" viewBox="0 0 28 35" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M2.27051 26.9548H25.7292V33.0155C25.7292 33.854 25.0494 34.5338 24.2109 34.5338H3.78879C2.95027 34.5338 2.27051 33.854 2.27051 33.0155V26.9548Z" fill="#FF565A"/>
<path d="M24.0869 14.1156C24.0869 18.2142 19.7098 19.0332 14.0839 19.0332C8.45803 19.0332 3.71387 18.2142 3.71387 14.1156C3.71387 10.017 8.27448 6.69434 13.9004 6.69434C19.5261 6.69434 24.0869 10.017 24.0869 14.1156Z" fill="#FFBB54"/>
<path d="M15.0977 13.4111C11.1551 13.4111 7.73809 11.7781 6.04479 9.39087C4.58879 10.6743 3.71387 12.3204 3.71387 14.1155C3.71387 18.2141 8.45803 19.0331 14.0839 19.0331C19.7098 19.0331 24.0869 18.2141 24.0869 14.1155C24.0869 12.8893 23.676 11.7335 22.9533 10.7144C21.0849 12.3616 18.2596 13.4111 15.0977 13.4111Z" fill="#FFAD30"/>
<path d="M25.3241 7.22688C24.0153 7.22688 19.1192 13.8173 19.1192 13.8173C19.1192 13.8173 15.1825 2.75098 13.8894 2.75098C12.5961 2.75098 8.6596 13.8173 8.6596 13.8173C8.6596 13.8173 3.79424 7.22674 2.48545 7.22674C1.72492 7.22674 2.45052 21.3525 3.07175 21.9659C3.68945 22.576 11.1582 23.1559 13.8755 23.1559C16.5928 23.1559 23.9205 22.6621 24.6793 21.9659C25.3172 21.3807 26.0868 7.22688 25.3241 7.22688Z" fill="#FFCC54"/>
<path d="M15.3475 2.50262C15.3475 3.34913 14.6614 4.03527 13.8149 4.03527C12.9684 4.03527 12.2822 3.34913 12.2822 2.50262C12.2822 1.65611 12.9684 0.969971 13.8149 0.969971C14.6614 0.969971 15.3475 1.65626 15.3475 2.50262Z" fill="#FFCC54"/>
<path d="M13.8147 3.71487C13.2454 3.71487 12.7822 3.2516 12.7822 2.68227C12.7822 2.11293 13.2454 1.64966 13.8147 1.64966C14.384 1.64966 14.8472 2.11293 14.8472 2.68227C14.8472 3.2516 14.3839 3.71487 13.8147 3.71487Z" fill="#FFBB54"/>
<path d="M13.8147 3.53518C13.2454 3.53518 12.7822 3.07191 12.7822 2.50258C12.7822 1.93324 13.2454 1.46997 13.8147 1.46997C14.384 1.46997 14.8472 1.93324 14.8472 2.50258C14.8472 3.07191 14.3839 3.53518 13.8147 3.53518Z" fill="#FF565A"/>
<path d="M13.9593 1.75089C13.5949 1.80293 14.0581 2.56274 14.2886 2.50264C14.519 2.4424 14.4203 1.68499 13.9593 1.75089Z" fill="white"/>
<path d="M13.8147 3.09384C13.3213 3.09384 12.9088 2.7454 12.8073 2.28198C12.7917 2.35326 12.7822 2.42679 12.7822 2.50273C12.7822 3.07206 13.2455 3.53534 13.8147 3.53534C14.384 3.53534 14.8472 3.07206 14.8472 2.50273C14.8472 2.42693 14.8378 2.3534 14.8221 2.28212C14.7206 2.7454 14.3081 3.09384 13.8147 3.09384Z" fill="#FF3B48"/>
<path d="M3.69225 7.22674C3.69225 8.07324 3.0061 8.75939 2.1596 8.75939C1.31309 8.75939 0.626953 8.07324 0.626953 7.22674C0.626953 6.38023 1.31309 5.69409 2.1596 5.69409C3.0061 5.69409 3.69225 6.38023 3.69225 7.22674Z" fill="#FFCC54"/>
<path d="M2.15942 8.43899C1.59008 8.43899 1.12695 7.97572 1.12695 7.40638C1.12695 6.83705 1.59008 6.37378 2.15942 6.37378C2.72875 6.37378 3.19189 6.83705 3.19189 7.40638C3.19189 7.97572 2.72861 8.43899 2.15942 8.43899Z" fill="#FFBB54"/>
<path d="M2.15942 8.25931C1.59008 8.25931 1.12695 7.79603 1.12695 7.2267C1.12695 6.65737 1.59008 6.19409 2.15942 6.19409C2.72875 6.19409 3.19189 6.65737 3.19189 7.2267C3.19189 7.79589 2.72875 8.25931 2.15942 8.25931Z" fill="#FF565A"/>
<path d="M2.30402 6.47501C1.9396 6.52705 2.40287 7.28687 2.63337 7.22677C2.86388 7.16652 2.76503 6.40911 2.30402 6.47501Z" fill="white"/>
<path d="M2.15942 7.81772C1.66602 7.81772 1.25352 7.46927 1.15198 7.00586C1.13629 7.07713 1.12695 7.15067 1.12695 7.22661C1.12695 7.79594 1.59023 8.25921 2.15942 8.25921C2.72875 8.25921 3.19189 7.79594 3.19189 7.22661C3.19189 7.15067 3.18241 7.07727 3.16686 7.006C3.06532 7.46927 2.65281 7.81772 2.15942 7.81772Z" fill="#FF3B48"/>
<path d="M27.1747 7.22674C27.1747 8.07324 26.4885 8.75939 25.642 8.75939C24.7955 8.75939 24.1094 8.07324 24.1094 7.22674C24.1094 6.38023 24.7955 5.69409 25.642 5.69409C26.4885 5.69409 27.1747 6.38023 27.1747 7.22674Z" fill="#FFCC54"/>
<path d="M25.6418 8.43899C25.0725 8.43899 24.6094 7.97572 24.6094 7.40638C24.6094 6.83705 25.0725 6.37378 25.6418 6.37378C26.2112 6.37378 26.6743 6.83705 26.6743 7.40638C26.6743 7.97572 26.2112 8.43899 25.6418 8.43899Z" fill="#FFBB54"/>
<path d="M25.6418 8.25931C25.0725 8.25931 24.6094 7.79603 24.6094 7.2267C24.6094 6.65737 25.0725 6.19409 25.6418 6.19409C26.2112 6.19409 26.6743 6.65737 26.6743 7.2267C26.6743 7.79589 26.2112 8.25931 25.6418 8.25931Z" fill="#FF565A"/>
<path d="M25.7865 6.47501C25.422 6.52705 25.8852 7.28687 26.1159 7.22677C26.3464 7.16652 26.2475 6.40911 25.7865 6.47501Z" fill="white"/>
<path d="M25.6418 7.81772C25.1484 7.81772 24.7359 7.46927 24.6344 7.00586C24.6189 7.07713 24.6094 7.15067 24.6094 7.22661C24.6094 7.79594 25.0725 8.25921 25.6418 8.25921C26.2112 8.25921 26.6743 7.79594 26.6743 7.22661C26.6743 7.15067 26.6648 7.07727 26.6493 7.006C26.5477 7.46927 26.1352 7.81772 25.6418 7.81772Z" fill="#FF3B48"/>
<path d="M13.8752 23.156C16.5924 23.156 23.9201 22.6622 24.6789 21.966C24.8459 21.8127 25.0219 20.7286 25.1771 19.2128C23.1973 19.9678 20.1148 20.5356 15.3461 20.3083C4.90567 19.8107 4.17216 15.3166 2.16309 11.1069C2.21088 15.3369 2.66369 21.5632 3.07153 21.966C3.68909 22.5761 11.1579 23.156 13.8752 23.156Z" fill="#FFBB54"/>
<circle cx="13.9742" cy="22.6094" r="3.49858" fill="#1C1F21"/>
<path d="M13.8643 25.1114C12.4245 25.1114 11.2531 23.9397 11.2529 22.4999C11.2529 21.0602 12.4244 19.8884 13.8641 19.8884C15.3039 19.8884 16.4754 21.0602 16.4754 22.4999C16.4755 23.9397 15.304 25.1114 13.8643 25.1114Z" fill="#FF565A"/>
<path d="M14.2294 20.5984C13.3076 20.73 14.4793 22.6517 15.0622 22.4996C15.6453 22.3474 15.3954 20.4318 14.2294 20.5984Z" fill="white"/>
<path d="M13.8643 23.995C12.6164 23.995 11.5731 23.1136 11.3163 21.9417C11.2768 22.1218 11.2531 22.3078 11.2529 22.4998C11.2529 23.9397 12.4244 25.1113 13.8643 25.1113C15.304 25.1113 16.4755 23.9395 16.4754 22.4997C16.4754 22.3078 16.4516 22.122 16.4122 21.9417C16.1555 23.1136 15.1121 23.995 13.8643 23.995Z" fill="#FF3B48"/>
<path d="M8.40674 28.8346C8.39519 28.7922 8.58959 28.7711 8.98995 28.7711C9.43266 28.7711 9.65979 28.8076 9.67134 28.8808L9.95428 31.3118L10.5664 28.8519C10.5856 28.7942 10.7358 28.7653 11.0168 28.7653C11.2978 28.7653 11.4479 28.7922 11.4672 28.8461L12.0677 31.3234L12.4026 28.8692C12.4103 28.8269 12.4989 28.798 12.6683 28.7826C12.8377 28.7672 12.9743 28.7595 13.0783 28.7595C13.4825 28.7595 13.6788 28.7865 13.6672 28.8404L12.9685 32.6688C12.9531 32.7266 12.8434 32.7689 12.6394 32.7959C12.4354 32.8228 12.2698 32.8363 12.1428 32.8363C11.6654 32.8363 11.4152 32.7824 11.3921 32.6746L10.9995 31.0866L10.5721 32.6688C10.5568 32.7381 10.422 32.7882 10.1679 32.819C10.0371 32.8305 9.90616 32.8363 9.77528 32.8363L9.40571 32.819C9.15164 32.792 9.0169 32.7439 9.0015 32.6746L8.40674 28.8346Z" fill="white"/>
<path d="M14.5746 31.8257V29.77H14.1646C14.0991 29.77 14.0529 29.6873 14.026 29.5217C14.0144 29.4409 14.0087 29.3581 14.0087 29.2734C14.0087 29.1888 14.0144 29.106 14.026 29.0251C14.0529 28.8596 14.0991 28.7768 14.1646 28.7768H16.1048C16.1702 28.7768 16.2145 28.8596 16.2376 29.0251C16.253 29.106 16.2607 29.1888 16.2607 29.2734C16.2607 29.3581 16.253 29.4409 16.2376 29.5217C16.2145 29.6873 16.1702 29.77 16.1048 29.77H15.7179V31.8257H16.1221C16.1875 31.8257 16.2337 31.9085 16.2607 32.074C16.2761 32.1549 16.2838 32.2377 16.2838 32.3223C16.2838 32.407 16.2761 32.4898 16.2607 32.5706C16.2337 32.7362 16.1875 32.819 16.1221 32.819H14.1761C14.1107 32.819 14.0664 32.7362 14.0433 32.5706C14.0279 32.4898 14.0202 32.407 14.0202 32.3223C14.0202 32.2377 14.0279 32.1549 14.0433 32.074C14.0664 31.9085 14.1107 31.8257 14.1761 31.8257H14.5746Z" fill="white"/>
<path d="M19.9489 32.6919C19.9489 32.7728 19.768 32.8132 19.4061 32.8132C19.0442 32.8132 18.8479 32.7843 18.8171 32.7266L17.8528 30.9249V32.7208C17.8528 32.7901 17.6738 32.8247 17.3157 32.8247C16.9616 32.8247 16.7845 32.7901 16.7845 32.7208V28.8577C16.7845 28.7999 16.9366 28.7711 17.2407 28.7711C17.36 28.7711 17.4986 28.7826 17.6564 28.8057C17.8181 28.825 17.9163 28.8635 17.9509 28.9212L18.8748 30.6997V28.8866C18.8748 28.8134 19.0538 28.7768 19.4119 28.7768C19.7699 28.7768 19.9489 28.8134 19.9489 28.8866V32.6919Z" fill="white"/>
</svg>
</file>

<file path="examples/mini-app/src/components/game/GameFrame.stories.tsx">
import type { Meta, StoryObj } from "@storybook/react"
import { GameFrame } from "./GameFrame"
import { TokenImage } from "@coinbase/onchainkit/token"
import { ETH_TOKEN } from "../../lib/tokens"
import { type HistoryEntry } from "./HistorySheetPanel"
import gameBg from "../../assets/game/game-background.png"
import { COINTOSS_FACE } from "@betswirl/sdk-core"

const meta = {
  title: "Game/GameFrame",
  component: GameFrame,
  parameters: {
    layout: "centered",
    backgrounds: {
      default: "light",
      values: [
        { name: "light", value: "#FFFFFF" },
        { name: "dark", value: "oklch(0.15 0 0)" },
      ],
    },
  },
  tags: ["autodocs"],
} satisfies Meta<typeof GameFrame>

export default meta
type Story = StoryObj<typeof meta>

const connectWalletBtnStub = <div></div>

const mockHistoryData: HistoryEntry[] = [
  {
    id: "1",
    status: "Won bet",
    multiplier: 1.94,
    payoutAmount: "1.94675",
    payoutCurrencyIcon: <TokenImage token={ETH_TOKEN} size={14} />,
    timestamp: "~24h ago",
  },
  {
    id: "2",
    status: "Won bet",
    multiplier: 1.2,
    payoutAmount: 0.2,
    payoutCurrencyIcon: <TokenImage token={ETH_TOKEN} size={14} />,
    timestamp: "~2h ago",
  },
  {
    id: "3",
    status: "Busted",
    multiplier: 1.94,
    payoutAmount: 1.94,
    payoutCurrencyIcon: <TokenImage token={ETH_TOKEN} size={14} />,
    timestamp: "~2h ago",
  },
  {
    id: "4",
    status: "Won bet",
    multiplier: 1.946,
    payoutAmount: 2.453,
    payoutCurrencyIcon: <TokenImage token={ETH_TOKEN} size={14} />,
    timestamp: "~2h ago",
  },
  {
    id: "5",
    status: "Busted",
    multiplier: 1.94,
    payoutAmount: 1.94,
    payoutCurrencyIcon: <TokenImage token={ETH_TOKEN} size={14} />,
    timestamp: "~2h ago",
  },
  {
    id: "6",
    status: "Won bet",
    multiplier: 1.946,
    payoutAmount: 2.453,
    payoutCurrencyIcon: <TokenImage token={ETH_TOKEN} size={14} />,
    timestamp: "~2h ago",
  },
  {
    id: "7",
    status: "Won bet",
    multiplier: 1.94,
    payoutAmount: 0.1,
    payoutCurrencyIcon: <TokenImage token={ETH_TOKEN} size={14} />,
    timestamp: "~2h ago",
  },
  {
    id: "8",
    status: "Won bet",
    multiplier: 1.94,
    payoutAmount: 0.1,
    payoutCurrencyIcon: <TokenImage token={ETH_TOKEN} size={14} />,
    timestamp: "~2h ago",
  },
  {
    id: "9",
    status: "Won bet",
    multiplier: 1.94,
    payoutAmount: 0.1,
    payoutCurrencyIcon: <TokenImage token={ETH_TOKEN} size={14} />,
    timestamp: "~2h ago",
  },
]

const Template: Story = {
  args: {
    themeSettings: {
      backgroundImage: gameBg,
    },
    historyData: mockHistoryData,
    balance: 1.7,
    connectWallletBtn: connectWalletBtnStub,
    isConnected: false,
    onPlayBtnClick: (betAmount: string) =>
      console.log("betAmount: ", betAmount),
    tokenDecimals: 18,
    gameResult: null,
    betStatus: null,
  },
  render: (args) => <GameFrame {...args} />,
}

export const WalletNotConnected: Story = {
  args: {
    ...Template.args,
  },
}

export const WalletConnected: Story = {
  args: {
    ...Template.args,
    isConnected: true,
  },
}

export const PlacingBet: Story = {
  args: {
    ...Template.args,
    isConnected: true,
    betStatus: "pending",
  },
}

export const ErrorBet: Story = {
  args: {
    ...Template.args,
    isConnected: true,
    betStatus: "error",
  },
}

export const Win: Story = {
  args: {
    ...Template.args,
    isConnected: true,
    betStatus: "success",
    gameResult: {
      isWin: true,
      payout: 0.19,
      currency: "ETH",
      rolled: COINTOSS_FACE.HEADS,
    },
  },
}

export const Loss: Story = {
  args: {
    ...Template.args,
    isConnected: true,
    betStatus: "success",
    gameResult: {
      isWin: false,
      payout: 0.19,
      currency: "ETH",
      rolled: COINTOSS_FACE.TAILS,
    },
  },
}
</file>

<file path="examples/mini-app/src/components/game/GameFrame.tsx">
import { History, Info } from "lucide-react"
import { ChangeEvent, useEffect, useRef, useState } from "react"
import coinIcon from "../../assets/game/coin-background-icon.png"
import { cn } from "../../lib/utils"
import { Button } from "../ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "../ui/card"
import { Input } from "../ui/input"
import { Label } from "../ui/label"

import { TokenImage } from "@coinbase/onchainkit/token"

import { Sheet, SheetTrigger } from "../ui/sheet"
import { HistoryEntry, HistorySheetPanel } from "./HistorySheetPanel"
import { InfoSheetPanel } from "./InfoSheetPanel"
import { ETH_TOKEN } from "../../lib/tokens"
import { GameResultWindow } from "./GameResultWindow"
import { BetStatus, GameResultFormatted } from "../../types"

function formatBetAmount(num: number, decimals: number): string {
  if (Number.isNaN(num)) return "0"
  if (num === 0) return "0"

  let s = num.toFixed(decimals)

  if (s.includes(".")) {
    s = s.replace(/\.?0+$/, "")
  }

  if (s.endsWith(".")) {
    s = s.slice(0, -1)
  }

  return s === "" || Number.isNaN(parseFloat(s)) ? "0" : s
}

interface IThemeSettings {
  theme?: "light" | "dark" | "system"
  customTheme?: {
    "--primary"?: string
    "--play-btn-font"?: string
    "--game-window-overlay"?: string
  } & React.CSSProperties
  backgroundImage: string
}

interface GameFrameProps extends React.HTMLAttributes<HTMLDivElement> {
  themeSettings: IThemeSettings
  historyData: HistoryEntry[]
  balance: number
  connectWallletBtn: React.ReactNode
  isConnected: boolean
  onPlayBtnClick: (betAmount: string) => void
  tokenDecimals: number
  gameResult: GameResultFormatted | null
  betStatus: BetStatus | null
}

const STEP = 0.0001

export function GameFrame({
  themeSettings,
  historyData,
  balance,
  connectWallletBtn,
  isConnected,
  onPlayBtnClick,
  tokenDecimals,
  gameResult,
  betStatus,
  ...props
}: GameFrameProps) {
  const [betAmount, setBetAmount] = useState("0")
  const [isInfoSheetOpen, setIsInfoSheetOpen] = useState(false)
  const [isHistorySheetOpen, setIsHistorySheetOpen] = useState(false)
  const cardRef = useRef<HTMLDivElement>(null)
  const [isMounted, setIsMounted] = useState(false)
  const { theme } = themeSettings

  const themeClass = theme === "system" ? undefined : theme

  useEffect(() => {
    setIsMounted(true)
  }, [])

  const isBetAmountInvalid =
    Number.isNaN(Number.parseFloat(betAmount)) ||
    Number.parseFloat(betAmount || "0") <= 0

  const multiplier = 1.94
  const winChance = 50
  const parsedBetAmountForPayout = Number.parseFloat(betAmount || "0")
  const targetPayout = (
    (Number.isNaN(parsedBetAmountForPayout) ? 0 : parsedBetAmountForPayout) *
    multiplier
  ).toFixed(2)
  const fee = 0

  const formattedBalance = balance.toFixed(4)

  const isInGameResultState = !!gameResult
  const isBettingInProgress = betStatus === "pending"
  const canInitiateBet =
    isConnected && !isBetAmountInvalid && !isBettingInProgress

  const isErrorState = betStatus === "error"

  const isPlayButtonDisabled: boolean = isErrorState
    ? false
    : isInGameResultState
      ? false
      : !canInitiateBet

  let playButtonText: string
  if (isErrorState) {
    playButtonText = "Error, try again"
  } else if (isInGameResultState) {
    playButtonText = "Try again"
  } else if (isBettingInProgress) {
    playButtonText = "Placing Bet..."
  } else if (!isConnected) {
    playButtonText = "Connect Wallet"
  } else {
    playButtonText = "Place Bet"
  }

  const handlePlayBtnClick = () => {
    if (isInGameResultState) {
      setBetAmount("0")
    }
    onPlayBtnClick(betAmount)
  }

  return (
    <div
      className={cn(
        "cointoss-game-wrapper game-global-styles",
        themeClass,
        props.className,
      )}
      style={themeSettings.customTheme as React.CSSProperties}
      {...props}
    >
      <Card
        ref={cardRef}
        className={cn(
          "relative overflow-hidden",
          "bg-card text-card-foreground border",
        )}
      >
        <CardHeader className="flex flex-row justify-between items-center h-[44px]">
          <CardTitle className="text-lg text-title-color font-bold">
            CoinToss
          </CardTitle>
          {connectWallletBtn}
        </CardHeader>

        <CardContent className="flex flex-col gap-4">
          <div
            className={cn(
              "h-[160px] rounded-[16px] flex flex-col justify-end items-center relative bg-cover bg-center bg-no-repeat",
              "bg-muted overflow-hidden",
            )}
            style={{
              backgroundImage: `url(${themeSettings.backgroundImage})`,
            }}
          >
            <div
              className={cn(
                "absolute inset-0 rounded-[16px]",
                "bg-game-window-overlay",
              )}
            ></div>

            <Sheet open={isInfoSheetOpen} onOpenChange={setIsInfoSheetOpen}>
              <SheetTrigger asChild>
                <Button
                  variant="iconTransparent"
                  size="iconRound"
                  className={cn(
                    "absolute top-2 left-2 z-10",
                    "text-white border border-border-stroke",
                    isInfoSheetOpen && "text-primary border-primary",
                  )}
                >
                  <Info className="h-4 w-4" />
                </Button>
              </SheetTrigger>
              {isMounted && cardRef.current && (
                <InfoSheetPanel
                  portalContainer={cardRef.current}
                  winChance={winChance}
                  rngFee={fee}
                  targetPayout={targetPayout}
                  gasPrice="34.2123 gwei"
                />
              )}
            </Sheet>

            <Sheet
              open={isHistorySheetOpen}
              onOpenChange={setIsHistorySheetOpen}
            >
              <SheetTrigger asChild>
                <Button
                  variant="iconTransparent"
                  size="iconRound"
                  className={cn(
                    "absolute top-2 right-2 z-5",
                    "text-white border border-border-stroke bg-neutral-background",
                    isHistorySheetOpen && "text-primary border-primary",
                  )}
                >
                  <History className="h-4 w-4" />
                </Button>
              </SheetTrigger>
              {isMounted && cardRef.current && (
                <HistorySheetPanel
                  portalContainer={cardRef.current}
                  historyData={historyData}
                />
              )}
            </Sheet>

            <div className="absolute top-1/5 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-[26px] font-extrabold leading-[34px] text-white">
              {multiplier.toFixed(2)} x
            </div>
            <img
              src={coinIcon}
              alt="Coin"
              className="absolute top-[62px] left-1/2 transform -translate-x-1/2 mt-2 h-16 w-16"
            />
            <GameResultWindow
              isVisible={!!gameResult}
              isWin={gameResult?.isWin}
              amount={Number(betAmount)}
              payout={gameResult?.payout}
              currency="ETH"
              rolled={gameResult?.rolled || ""}
            />
          </div>

          <div className="bg-control-panel-background p-4 rounded-[16px] flex flex-col gap-4">
            <div className="flex flex-col gap-3">
              <div className="text-sm font-medium flex items-center">
                <span className="text-text-on-surface-variant">
                  Balance:&nbsp;
                </span>
                <span className="font-semibold">{formattedBalance}</span>
                <TokenImage token={ETH_TOKEN} size={16} className="ml-1" />
              </div>

              <Label
                htmlFor="betAmount"
                className="text-sm font-medium -mb-1 text-text-on-surface-variant"
              >
                Bet amount
              </Label>
              <Input
                id="betAmount"
                type="number"
                placeholder="0"
                min={0}
                max={balance}
                step={STEP}
                value={betAmount}
                onChange={(e: ChangeEvent<HTMLInputElement>) => {
                  setBetAmount(e.target.value)
                }}
                className="relative"
                token={{
                  icon: <TokenImage token={ETH_TOKEN} size={16} />,
                  symbol: "ETH",
                }}
                disabled={
                  !isConnected || betStatus === "pending" || !!gameResult
                }
              />

              <div className="grid grid-cols-3 gap-2">
                <Button
                  variant="secondary"
                  onClick={() => {
                    setBetAmount((prev) => {
                      const prevNum = Number.parseFloat(prev || "0")
                      if (Number.isNaN(prevNum) || prevNum === 0) return "0"
                      return formatBetAmount(prevNum / 2, tokenDecimals)
                    })
                  }}
                  className="border border-border-stroke rounded-[8px] h-[30px] w-[85.33px] text-text-on-surface"
                  disabled={
                    !isConnected || isBettingInProgress || isInGameResultState
                  }
                >
                  1/2
                </Button>
                <Button
                  variant="secondary"
                  onClick={() => {
                    setBetAmount((prev) => {
                      const oldNum = Number.parseFloat(prev || "0")
                      const newAmount = oldNum * 2
                      const finalAmount = Math.min(balance, newAmount)
                      return formatBetAmount(finalAmount, tokenDecimals)
                    })
                  }}
                  className="border border-border-stroke rounded-[8px] h-[30px] w-[85.33px] text-text-on-surface"
                  disabled={
                    !isConnected || isBettingInProgress || isInGameResultState
                  }
                >
                  2x
                </Button>
                <Button
                  variant="secondary"
                  className="border border-border-stroke rounded-[8px] h-[30px] w-[85.33px] text-text-on-surface"
                  onClick={() => {
                    setBetAmount(formattedBalance)
                  }}
                  disabled={
                    !isConnected || isBettingInProgress || isInGameResultState
                  }
                >
                  Max
                </Button>
              </div>
            </div>

            <Button
              size="lg"
              className={cn(
                "w-full",
                "border-0",
                "font-bold",
                "rounded-[16px]",
                "text-play-btn-font",
              )}
              variant={isErrorState ? "destructive" : "default"}
              onClick={handlePlayBtnClick}
              disabled={isPlayButtonDisabled}
            >
              {playButtonText}
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="examples/mini-app/src/context/BettingConfigContext.tsx">
import { type BettingConfig, BettingConfigContext } from "./useBettingConfig.ts"

export const BettingConfigProvider = ({
  value,
  children,
}: {
  value: BettingConfig
  children: React.ReactNode
}) => {
  return (
    <BettingConfigContext.Provider value={value}>
      {children}
    </BettingConfigContext.Provider>
  )
}
</file>

<file path="examples/mini-app/src/context/useBettingConfig.ts">
import { createContext, useContext } from "react"

export type BettingConfig = {
  affiliate?: string
}
export const BettingConfigContext = createContext<BettingConfig | undefined>(
  undefined,
)
export const useBettingConfig = () => {
  const context = useContext(BettingConfigContext)
  if (!context)
    throw new Error(
      "useBettingConfig must be used inside BettingConfigProvider",
    )
  return context
}
</file>

<file path="examples/mini-app/src/hooks/types.ts">
import type { Abi, Hex } from "viem"
import type { CASINO_GAME_TYPE, COINTOSS_FACE } from "@betswirl/sdk-core"

export interface GameResult {
  isWin: boolean
  payout: bigint
  currency: string
  rolled: COINTOSS_FACE
}

export interface WatchTarget {
  betId: bigint
  contractAddress: Hex
  gameType: CASINO_GAME_TYPE
  eventAbi: Abi
  eventName: string
  eventArgs: { id: bigint }
}
</file>

<file path="examples/mini-app/src/hooks/useBetResultWatcher.ts">
import { useState, useCallback, useEffect, useMemo } from "react"
import type { Log, AbiEvent } from "viem"
import { decodeEventLog } from "viem"
import { usePublicClient, useWatchContractEvent } from "wagmi"
import { CASINO_GAME_TYPE, COINTOSS_FACE, CoinToss } from "@betswirl/sdk-core"
import type { GameResult, WatchTarget } from "./types"
import { createLogger } from "../lib/logger"

const logger = createLogger("useBetResultWatcher")

interface UseBetResultWatcherProps {
  watchParams: WatchTarget | null
  publicClient: ReturnType<typeof usePublicClient> | null
  enabled: boolean
}

type BetResultWatcherStatus =
  | "idle"
  | "listening"
  | "fallback_listening"
  | "success"
  | "error"

interface BetResultWatcherOutput {
  gameResult: GameResult | null
  status: BetResultWatcherStatus
  error: Error | null
  reset: () => void
}

const POLLING_INTERVAL = 2500
const PRIMARY_WATCHER_TIMEOUT = 30000

function _decodeRolled(
  rolled: boolean[],
  game: CASINO_GAME_TYPE,
): COINTOSS_FACE {
  switch (game) {
    case CASINO_GAME_TYPE.COINTOSS:
      return CoinToss.decodeRolled(rolled[0])
    default:
      logger.debug(`_decodeRolled: Unsupported game type: ${game}`)
      throw new Error(`Unsupported game type for decoding roll: ${game}`)
  }
}

export function useBetResultWatcher({
  watchParams,
  publicClient,
  enabled,
}: UseBetResultWatcherProps): BetResultWatcherOutput {
  const [internalGameResult, setInternalGameResult] =
    useState<GameResult | null>(null)
  const [status, setStatus] = useState<BetResultWatcherStatus>("idle")
  const [error, setError] = useState<Error | null>(null)
  const [filterErrorOccurred, setFilterErrorOccurred] = useState<boolean>(false)

  const eventArgs = useMemo(() => {
    if (watchParams?.betId) {
      return { id: watchParams.betId }
    }
    return undefined
  }, [watchParams?.betId])

  const reset = useCallback(() => {
    logger.debug("reset: Resetting watcher state")
    setInternalGameResult(null)
    setStatus("idle")
    setError(null)
    setFilterErrorOccurred(false)
  }, [])

  useEffect(() => {
    if (!enabled) {
      if (status !== "idle") reset()
      return
    }

    if (watchParams && publicClient && status === "idle") {
      logger.debug(
        "useEffect[enabled,watchParams]: Watcher enabled, starting.",
        {
          watchParams,
        },
      )
      setStatus("listening")
      setError(null)
      setFilterErrorOccurred(false)
    }
  }, [enabled, watchParams, publicClient, status, reset])

  useEffect(() => {
    if (
      enabled &&
      watchParams &&
      status === "listening" &&
      !filterErrorOccurred
    ) {
      logger.debug(
        `useEffect[timeout]: Starting primary watcher timeout (${PRIMARY_WATCHER_TIMEOUT}ms).`,
        { betId: watchParams.betId },
      )
      const timerId = setTimeout(() => {
        logger.warn(
          `useEffect[timeout]: Primary watcher timed out for betId ${watchParams.betId}. Switching to fallback.`,
        )
        setFilterErrorOccurred(true)
        setStatus("fallback_listening")
      }, PRIMARY_WATCHER_TIMEOUT)

      return () => {
        logger.debug(
          `useEffect[timeout]: Clearing primary watcher timeout for betId ${watchParams.betId}.`,
        )
        clearTimeout(timerId)
      }
    }
  }, [enabled, watchParams, status, filterErrorOccurred])

  const processEventLogs = useCallback(
    (logs: readonly Log[], currentWatchParams: WatchTarget) => {
      const { betId, gameType, eventAbi, eventName } = currentWatchParams
      logger.debug(
        `processEventLogs: Processing ${logs.length} logs for betId ${betId}`,
        { eventName },
      )

      for (const log of logs) {
        const decodedRollLog = decodeEventLog({
          abi: eventAbi,
          data: log.data,
          topics: log.topics,
          strict: false,
        })

        if (decodedRollLog.eventName !== eventName) continue

        const rollArgs = decodedRollLog.args as unknown as {
          id: bigint
          payout: bigint
          rolled: boolean[]
        }

        if (rollArgs.id === betId) {
          const rolledResult = _decodeRolled(rollArgs.rolled, gameType)
          const result: GameResult = {
            isWin: rollArgs.payout > 0n,
            payout: rollArgs.payout,
            currency: "ETH",
            rolled: rolledResult,
          }
          logger.debug("processEventLogs: Bet event processed:", {
            ...result,
            betId,
            txHash: log.transactionHash,
          })
          setInternalGameResult(result)
          setStatus("success")
          setError(null)
          return
        }
      }
    },
    [],
  )

  useWatchContractEvent({
    address: watchParams?.contractAddress,
    abi: watchParams?.eventAbi,
    eventName: watchParams?.eventName,
    args: eventArgs,
    enabled:
      enabled &&
      !!watchParams &&
      !filterErrorOccurred &&
      status === "listening",
    pollingInterval: POLLING_INTERVAL,
    onLogs: (logs) => {
      if (!watchParams) return
      logger.debug(
        `useWatchContractEvent: Received ${logs.length} logs (primary)`,
      )
      processEventLogs(logs, watchParams)
    },
    onError: (watchError) => {
      logger.debug(
        "useWatchContractEvent: Error from primary watcher:",
        watchError,
      )
      setFilterErrorOccurred(true)
      setStatus("fallback_listening")
    },
  })

  useEffect(() => {
    if (
      !enabled ||
      !watchParams ||
      !publicClient ||
      !filterErrorOccurred ||
      status !== "fallback_listening"
    ) {
      return
    }
    logger.debug("fallbackPoller: Starting fallback polling.", {
      betId: watchParams.betId,
    })
    let isActive = true

    const poll = async () => {
      if (!isActive || !watchParams || !publicClient) return

      const { contractAddress, eventName, eventAbi, betId } = watchParams
      const eventDefinition = eventAbi.find(
        (item): item is AbiEvent =>
          item.type === "event" && item.name === eventName,
      )

      if (!eventDefinition) {
        logger.debug(
          `fallbackPoller: Critical: Event definition for ${eventName} not found.`,
        )
        setError(new Error(`Event definition for ${eventName} not found.`))
        setStatus("error")
        return
      }

      const currentBlock = await publicClient.getBlockNumber()
      const fromBlock = currentBlock > 100n ? currentBlock - 100n : 0n
      logger.debug(
        `fallbackPoller: Querying logs from ${fromBlock} to ${currentBlock}`,
      )
      const logs = await publicClient.getLogs({
        address: contractAddress,
        event: eventDefinition,
        args: { id: betId },
        fromBlock,
        toBlock: currentBlock,
      })
      logger.debug(
        `fallbackPoller: Fetched ${logs.length} logs (fallback) for betId ${betId}`,
      )
      if (logs.length > 0) {
        processEventLogs(logs, watchParams)
      }
    }

    poll()
    const intervalId = setInterval(poll, POLLING_INTERVAL)

    return () => {
      logger.debug("fallbackPoller: Stopping fallback polling.")
      isActive = false
      clearInterval(intervalId)
    }
  }, [
    enabled,
    watchParams,
    publicClient,
    filterErrorOccurred,
    status,
    processEventLogs,
  ])

  useEffect(() => {
    if (status === "success" || status === "error") {
      logger.debug(
        `useEffect[status]: Final status reached: ${status}. Watcher inactive.`,
      )
    }
  }, [status])

  return { gameResult: internalGameResult, status, error, reset }
}
</file>

<file path="examples/mini-app/src/lib/logger.ts">
export interface Logger {
  debug: (message: string, data?: unknown) => void
  info: (message: string, data?: unknown) => void
  warn: (message: string, data?: unknown) => void
  error: (message: string, error?: Error | unknown, data?: unknown) => void
}

export function createLogger(moduleContext: string): Logger {
  const formatMessage = (level: string, message: string): string => {
    return `[${moduleContext}] ${level.toUpperCase()}: ${message}`
  }

  return {
    debug: (message: string, data?: unknown) => {
      const logMessage = formatMessage("debug", message)
      if (data !== undefined) {
        console.log(logMessage, data)
      } else {
        console.log(logMessage)
      }
    },
    info: (message: string, data?: unknown) => {
      const logMessage = formatMessage("info", message)
      if (data !== undefined) {
        console.info(logMessage, data)
      } else {
        console.info(logMessage)
      }
    },
    warn: (message: string, data?: unknown) => {
      const logMessage = formatMessage("warn", message)
      if (data !== undefined) {
        console.warn(logMessage, data)
      } else {
        console.warn(logMessage)
      }
    },
    error: (message: string, error?: Error | unknown, data?: unknown) => {
      const logMessage = formatMessage("error", message)
      const paramsToLog: unknown[] = []
      if (error !== undefined) paramsToLog.push(error)
      if (data !== undefined) paramsToLog.push(data)

      if (paramsToLog.length > 0) {
        console.error(logMessage, ...paramsToLog)
      } else {
        console.error(logMessage)
      }
    },
  }
}
</file>

<file path="examples/mini-app/src/lib/tokens.ts">
import type { Token } from "@coinbase/onchainkit/token"

export const ETH_TOKEN: Token = {
  name: "Ethereum",
  address: "",
  symbol: "ETH",
  decimals: 18,
  image:
    "https://wallet-api-production.s3.amazonaws.com/uploads/tokens/eth_288.png",
  chainId: 84532,
}
</file>

<file path="examples/mini-app/src/types.ts">
import { COINTOSS_FACE } from "@betswirl/sdk-core"

export interface GameResult {
  isWin: boolean
  payout: bigint
  currency: string
  rolled: COINTOSS_FACE
}

export interface GameResultFormatted extends Omit<GameResult, "payout"> {
  payout: number
}

export type BetStatus = "pending" | "success" | "error"
</file>

<file path="examples/mini-app/README.md">
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default tseslint.config({
  extends: [
    // Remove ...tseslint.configs.recommended and replace with this
    ...tseslint.configs.recommendedTypeChecked,
    // Alternatively, use this for stricter rules
    ...tseslint.configs.strictTypeChecked,
    // Optionally, add this for stylistic rules
    ...tseslint.configs.stylisticTypeChecked,
  ],
  languageOptions: {
    // other options...
    parserOptions: {
      project: ["./tsconfig.node.json", "./tsconfig.app.json"],
      tsconfigRootDir: import.meta.dirname,
    },
  },
})
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from "eslint-plugin-react-x"
import reactDom from "eslint-plugin-react-dom"

export default tseslint.config({
  plugins: {
    // Add the react-x and react-dom plugins
    "react-x": reactX,
    "react-dom": reactDom,
  },
  rules: {
    // other rules...
    // Enable its recommended typescript rules
    ...reactX.configs["recommended-typescript"].rules,
    ...reactDom.configs.recommended.rules,
  },
})
```

## Deploy

```shell
setfacl -R -m u:dev-components:rwx /var/www/betswirl-sdk/
```
</file>

<file path="packages/core/src/abis/v2/casino/cointoss.ts">
export const coinTossAbi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "bankAddress",
        type: "address",
      },
      {
        internalType: "address",
        name: "chainlinkCoordinatorAddress",
        type: "address",
      },
      {
        internalType: "address",
        name: "chainlinkWrapperAddress",
        type: "address",
      },
      {
        internalType: "address",
        name: "wrappedGasToken",
        type: "address",
      },
      {
        internalType: "uint64",
        name: "refundTime_",
        type: "uint64",
      },
      {
        internalType: "uint256",
        name: "maxCallGas_",
        type: "uint256",
      },
    ],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  {
    inputs: [],
    name: "AccessDenied",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "maxBetCount",
        type: "uint256",
      },
    ],
    name: "BetCountTooHigh",
    type: "error",
  },
  {
    inputs: [],
    name: "ForbiddenToken",
    type: "error",
  },
  {
    inputs: [],
    name: "HouseEdgeTooHigh",
    type: "error",
  },
  {
    inputs: [],
    name: "HouseEdgeTooLow",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidAddress",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidMaxCallGas",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidParam",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidVRFSubId",
    type: "error",
  },
  {
    inputs: [],
    name: "NotFulfilled",
    type: "error",
  },
  {
    inputs: [],
    name: "NotPendingBet",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "have",
        type: "address",
      },
      {
        internalType: "address",
        name: "want",
        type: "address",
      },
    ],
    name: "OnlyCoordinatorCanFulfill",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "have",
        type: "address",
      },
      {
        internalType: "address",
        name: "owner",
        type: "address",
      },
      {
        internalType: "address",
        name: "coordinator",
        type: "address",
      },
    ],
    name: "OnlyOwnerOrCoordinator",
    type: "error",
  },
  {
    inputs: [],
    name: "TokenHasPendingBets",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "minBetAmount",
        type: "uint256",
      },
    ],
    name: "UnderMinBetAmount",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "minBetCount",
        type: "uint256",
      },
    ],
    name: "UnderMinBetCount",
    type: "error",
  },
  {
    inputs: [],
    name: "WrongGasValueToCoverVRFFee",
    type: "error",
  },
  {
    inputs: [],
    name: "ZeroAddress",
    type: "error",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "address",
        name: "user",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "BetRefunded",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "vrfCoordinator",
        type: "address",
      },
    ],
    name: "CoordinatorSet",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "DistributeTokenVRFFees",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address",
      },
    ],
    name: "OwnershipTransferRequested",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address",
      },
    ],
    name: "OwnershipTransferred",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address",
      },
    ],
    name: "Paused",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "chargedVRFCost",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "bool",
        name: "face",
        type: "bool",
      },
      {
        indexed: false,
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "betCount",
        type: "uint32",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "stopGain",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "stopLoss",
        type: "uint256",
      },
    ],
    name: "PlaceBet",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalBetAmount",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "bool",
        name: "face",
        type: "bool",
      },
      {
        indexed: false,
        internalType: "bool[]",
        name: "rolled",
        type: "bool[]",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "payout",
        type: "uint256",
      },
    ],
    name: "Roll",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "previousHouseEdge",
        type: "uint16",
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "houseEdge",
        type: "uint16",
      },
    ],
    name: "SetAffiliateHouseEdge",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint16",
        name: "requestConfirmations",
        type: "uint16",
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "keyHash",
        type: "bytes32",
      },
      {
        indexed: false,
        internalType: "contract IVRFV2PlusWrapperCustom",
        name: "chainlinkWrapper",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "VRFCallbackGasExtraBet",
        type: "uint32",
      },
      {
        indexed: false,
        internalType: "bool",
        name: "nativePayment",
        type: "bool",
      },
    ],
    name: "SetChainlinkConfig",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "previousHouseEdge",
        type: "uint16",
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "houseEdge",
        type: "uint16",
      },
    ],
    name: "SetHouseEdge",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "previousMaxCallGas",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "maxCallGas",
        type: "uint256",
      },
    ],
    name: "SetMaxCallGas",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint64",
        name: "previousRefundTime",
        type: "uint64",
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "refundTime",
        type: "uint64",
      },
    ],
    name: "SetRefundTime",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "previousCallbackGasBase",
        type: "uint32",
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "callbackGasBase",
        type: "uint32",
      },
    ],
    name: "SetVRFCallbackGasBase",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "previousSubId",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "subId",
        type: "uint256",
      },
    ],
    name: "SetVRFSubId",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address",
      },
    ],
    name: "Unpaused",
    type: "event",
  },
  {
    inputs: [],
    name: "BANK",
    outputs: [
      {
        internalType: "contract IBankGame",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "WRAPPED",
    outputs: [
      {
        internalType: "contract IWrapped",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    name: "_affiliateHouseEdges",
    outputs: [
      {
        internalType: "uint16",
        name: "",
        type: "uint16",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "acceptOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    name: "bets",
    outputs: [
      {
        internalType: "bool",
        name: "resolved",
        type: "bool",
      },
      {
        internalType: "address",
        name: "receiver",
        type: "address",
      },
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
      {
        internalType: "uint16",
        name: "houseEdge",
        type: "uint16",
      },
      {
        internalType: "uint32",
        name: "timestamp",
        type: "uint32",
      },
      {
        internalType: "uint256",
        name: "payout",
        type: "uint256",
      },
      {
        internalType: "uint16",
        name: "betCount",
        type: "uint16",
      },
      {
        internalType: "uint256",
        name: "stopGain",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "stopLoss",
        type: "uint256",
      },
      {
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
    ],
    name: "coinTossBets",
    outputs: [
      {
        components: [
          {
            internalType: "bool",
            name: "face",
            type: "bool",
          },
          {
            internalType: "bool[]",
            name: "rolled",
            type: "bool[]",
          },
        ],
        internalType: "struct ICoinToss.CoinTossBet",
        name: "",
        type: "tuple",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
    ],
    name: "getAffiliateHouseEdge",
    outputs: [
      {
        internalType: "uint16",
        name: "",
        type: "uint16",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "getChainlinkConfig",
    outputs: [
      {
        internalType: "uint16",
        name: "requestConfirmations",
        type: "uint16",
      },
      {
        internalType: "bytes32",
        name: "keyHash",
        type: "bytes32",
      },
      {
        internalType: "contract IVRFCoordinatorV2Plus",
        name: "chainlinkCoordinator",
        type: "address",
      },
      {
        internalType: "contract IVRFV2PlusWrapperCustom",
        name: "chainlinkWrapper",
        type: "address",
      },
      {
        internalType: "uint32",
        name: "VRFCallbackGasExtraBet",
        type: "uint32",
      },
      {
        internalType: "bool",
        name: "nativePayment",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint16",
        name: "betCount",
        type: "uint16",
      },
    ],
    name: "getChainlinkVRFCost",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
    ],
    name: "hasPendingBets",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "maxCallGas",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "paused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "requestId",
        type: "uint256",
      },
      {
        internalType: "uint256[]",
        name: "randomWords",
        type: "uint256[]",
      },
    ],
    name: "rawFulfillRandomWords",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
    ],
    name: "refundBet",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "refundTime",
    outputs: [
      {
        internalType: "uint64",
        name: "",
        type: "uint64",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "s_vrfCoordinator",
    outputs: [
      {
        internalType: "contract IVRFCoordinatorV2Plus",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint16",
        name: "affiliateHouseEdge",
        type: "uint16",
      },
    ],
    name: "setAffiliateHouseEdge",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint16",
        name: "requestConfirmations",
        type: "uint16",
      },
      {
        internalType: "bytes32",
        name: "keyHash",
        type: "bytes32",
      },
      {
        internalType: "contract IVRFV2PlusWrapperCustom",
        name: "chainlinkWrapper",
        type: "address",
      },
      {
        internalType: "uint32",
        name: "VRFCallbackGasExtraBet",
        type: "uint32",
      },
      {
        internalType: "bool",
        name: "nativePayment",
        type: "bool",
      },
    ],
    name: "setChainlinkConfig",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_vrfCoordinator",
        type: "address",
      },
    ],
    name: "setCoordinator",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint16",
        name: "houseEdge",
        type: "uint16",
      },
    ],
    name: "setHouseEdge",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "maxCallGas_",
        type: "uint256",
      },
    ],
    name: "setMaxCallGas",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint64",
        name: "refundTime_",
        type: "uint64",
      },
    ],
    name: "setRefundTime",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint32",
        name: "callbackGasBase",
        type: "uint32",
      },
    ],
    name: "setVRFCallbackGasBase",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "subId",
        type: "uint256",
      },
    ],
    name: "setVRFSubId",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "togglePause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    name: "tokens",
    outputs: [
      {
        internalType: "uint16",
        name: "houseEdge",
        type: "uint16",
      },
      {
        internalType: "uint64",
        name: "pendingCount",
        type: "uint64",
      },
      {
        internalType: "uint256",
        name: "vrfSubId",
        type: "uint256",
      },
      {
        internalType: "uint32",
        name: "VRFCallbackGasBase",
        type: "uint32",
      },
      {
        internalType: "uint256",
        name: "VRFFees",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "bool",
        name: "face",
        type: "bool",
      },
      {
        internalType: "address",
        name: "receiver",
        type: "address",
      },
      {
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
      {
        components: [
          {
            internalType: "address",
            name: "token",
            type: "address",
          },
          {
            internalType: "uint256",
            name: "betAmount",
            type: "uint256",
          },
          {
            internalType: "uint16",
            name: "betCount",
            type: "uint16",
          },
          {
            internalType: "uint256",
            name: "stopGain",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "stopLoss",
            type: "uint256",
          },
          {
            internalType: "uint16",
            name: "maxHouseEdge",
            type: "uint16",
          },
        ],
        internalType: "struct IGamePlayer.BetData",
        name: "betData",
        type: "tuple",
      },
    ],
    name: "wager",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "payable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "bet",
        type: "bytes",
      },
      {
        internalType: "address",
        name: "receiver",
        type: "address",
      },
      {
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
      {
        components: [
          {
            internalType: "address",
            name: "token",
            type: "address",
          },
          {
            internalType: "uint256",
            name: "betAmount",
            type: "uint256",
          },
          {
            internalType: "uint16",
            name: "betCount",
            type: "uint16",
          },
          {
            internalType: "uint256",
            name: "stopGain",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "stopLoss",
            type: "uint256",
          },
          {
            internalType: "uint16",
            name: "maxHouseEdge",
            type: "uint16",
          },
        ],
        internalType: "struct IGamePlayer.BetData",
        name: "betData",
        type: "tuple",
      },
    ],
    name: "wagerWithData",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "payable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
    ],
    name: "withdrawTokenVRFFees",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
] as const;
</file>

<file path="packages/core/src/abis/v2/casino/weightedGame.ts">
export const wheelAbi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "bankAddress",
        type: "address",
      },
      {
        internalType: "address",
        name: "chainlinkCoordinatorAddress",
        type: "address",
      },
      {
        internalType: "address",
        name: "chainlinkWrapperAddress",
        type: "address",
      },
      {
        internalType: "address",
        name: "wrappedGasToken",
        type: "address",
      },
      {
        internalType: "uint64",
        name: "refundTime_",
        type: "uint64",
      },
      {
        internalType: "uint256",
        name: "maxCallGas_",
        type: "uint256",
      },
      {
        internalType: "uint8",
        name: "maxColors_",
        type: "uint8",
      },
    ],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  {
    inputs: [],
    name: "AccessDenied",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "maxBetCount",
        type: "uint256",
      },
    ],
    name: "BetCountTooHigh",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "id",
        type: "uint32",
      },
    ],
    name: "ConfigNotExists",
    type: "error",
  },
  {
    inputs: [],
    name: "ForbiddenToken",
    type: "error",
  },
  {
    inputs: [],
    name: "HouseEdgeTooHigh",
    type: "error",
  },
  {
    inputs: [],
    name: "HouseEdgeTooLow",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidAddress",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidConfig",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidMaxCallGas",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidParam",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidVRFSubId",
    type: "error",
  },
  {
    inputs: [],
    name: "NotFulfilled",
    type: "error",
  },
  {
    inputs: [],
    name: "NotPendingBet",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "have",
        type: "address",
      },
      {
        internalType: "address",
        name: "want",
        type: "address",
      },
    ],
    name: "OnlyCoordinatorCanFulfill",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "have",
        type: "address",
      },
      {
        internalType: "address",
        name: "owner",
        type: "address",
      },
      {
        internalType: "address",
        name: "coordinator",
        type: "address",
      },
    ],
    name: "OnlyOwnerOrCoordinator",
    type: "error",
  },
  {
    inputs: [],
    name: "TokenHasPendingBets",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "minBetAmount",
        type: "uint256",
      },
    ],
    name: "UnderMinBetAmount",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "minBetCount",
        type: "uint256",
      },
    ],
    name: "UnderMinBetCount",
    type: "error",
  },
  {
    inputs: [],
    name: "WrongGasValueToCoverVRFFee",
    type: "error",
  },
  {
    inputs: [],
    name: "ZeroAddress",
    type: "error",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "address",
        name: "user",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "BetRefunded",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "vrfCoordinator",
        type: "address",
      },
    ],
    name: "CoordinatorSet",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "DistributeTokenVRFFees",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint32",
        name: "configId",
        type: "uint32",
      },
      {
        indexed: false,
        internalType: "uint64[]",
        name: "weights",
        type: "uint64[]",
      },
      {
        indexed: false,
        internalType: "uint64[]",
        name: "multipliers",
        type: "uint64[]",
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "gameId",
        type: "uint32",
      },
    ],
    name: "GameConfigAdded",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address",
      },
    ],
    name: "OwnershipTransferRequested",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address",
      },
    ],
    name: "OwnershipTransferred",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address",
      },
    ],
    name: "Paused",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "chargedVRFCost",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "configId",
        type: "uint32",
      },
      {
        indexed: false,
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "betCount",
        type: "uint32",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "stopGain",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "stopLoss",
        type: "uint256",
      },
    ],
    name: "PlaceBet",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalBetAmount",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "configId",
        type: "uint32",
      },
      {
        indexed: false,
        internalType: "uint8[]",
        name: "rolled",
        type: "uint8[]",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "payout",
        type: "uint256",
      },
    ],
    name: "Roll",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "previousHouseEdge",
        type: "uint16",
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "houseEdge",
        type: "uint16",
      },
    ],
    name: "SetAffiliateHouseEdge",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint16",
        name: "requestConfirmations",
        type: "uint16",
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "keyHash",
        type: "bytes32",
      },
      {
        indexed: false,
        internalType: "contract IVRFV2PlusWrapperCustom",
        name: "chainlinkWrapper",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "VRFCallbackGasExtraBet",
        type: "uint32",
      },
      {
        indexed: false,
        internalType: "bool",
        name: "nativePayment",
        type: "bool",
      },
    ],
    name: "SetChainlinkConfig",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "previousHouseEdge",
        type: "uint16",
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "houseEdge",
        type: "uint16",
      },
    ],
    name: "SetHouseEdge",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "previousMaxCallGas",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "maxCallGas",
        type: "uint256",
      },
    ],
    name: "SetMaxCallGas",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint8",
        name: "previousMaxColors",
        type: "uint8",
      },
      {
        indexed: false,
        internalType: "uint8",
        name: "maxColors",
        type: "uint8",
      },
    ],
    name: "SetMaxColors",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint64",
        name: "previousRefundTime",
        type: "uint64",
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "refundTime",
        type: "uint64",
      },
    ],
    name: "SetRefundTime",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "previousCallbackGasBase",
        type: "uint32",
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "callbackGasBase",
        type: "uint32",
      },
    ],
    name: "SetVRFCallbackGasBase",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "previousSubId",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "subId",
        type: "uint256",
      },
    ],
    name: "SetVRFSubId",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address",
      },
    ],
    name: "Unpaused",
    type: "event",
  },
  {
    inputs: [],
    name: "BANK",
    outputs: [
      {
        internalType: "contract IBankGame",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "WRAPPED",
    outputs: [
      {
        internalType: "contract IWrapped",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    name: "_affiliateHouseEdges",
    outputs: [
      {
        internalType: "uint16",
        name: "",
        type: "uint16",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "acceptOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint64[]",
        name: "weights_",
        type: "uint64[]",
      },
      {
        internalType: "uint64[]",
        name: "multipliers_",
        type: "uint64[]",
      },
      {
        internalType: "uint32",
        name: "gameId",
        type: "uint32",
      },
    ],
    name: "addGameConfig",
    outputs: [
      {
        internalType: "uint32",
        name: "configId",
        type: "uint32",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    name: "bets",
    outputs: [
      {
        internalType: "bool",
        name: "resolved",
        type: "bool",
      },
      {
        internalType: "address",
        name: "receiver",
        type: "address",
      },
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
      {
        internalType: "uint16",
        name: "houseEdge",
        type: "uint16",
      },
      {
        internalType: "uint32",
        name: "timestamp",
        type: "uint32",
      },
      {
        internalType: "uint256",
        name: "payout",
        type: "uint256",
      },
      {
        internalType: "uint16",
        name: "betCount",
        type: "uint16",
      },
      {
        internalType: "uint256",
        name: "stopGain",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "stopLoss",
        type: "uint256",
      },
      {
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "configsCount",
    outputs: [
      {
        internalType: "uint32",
        name: "",
        type: "uint32",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "configId",
        type: "uint32",
      },
    ],
    name: "gameConfigs",
    outputs: [
      {
        components: [
          {
            internalType: "uint72[]",
            name: "weightRanges",
            type: "uint72[]",
          },
          {
            internalType: "uint64[]",
            name: "multipliers",
            type: "uint64[]",
          },
          {
            internalType: "uint64",
            name: "maxMultiplier",
            type: "uint64",
          },
          {
            internalType: "uint32",
            name: "gameId",
            type: "uint32",
          },
        ],
        internalType: "struct IWheel.GameConfig",
        name: "",
        type: "tuple",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
    ],
    name: "getAffiliateHouseEdge",
    outputs: [
      {
        internalType: "uint16",
        name: "",
        type: "uint16",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "getChainlinkConfig",
    outputs: [
      {
        internalType: "uint16",
        name: "requestConfirmations",
        type: "uint16",
      },
      {
        internalType: "bytes32",
        name: "keyHash",
        type: "bytes32",
      },
      {
        internalType: "contract IVRFCoordinatorV2Plus",
        name: "chainlinkCoordinator",
        type: "address",
      },
      {
        internalType: "contract IVRFV2PlusWrapperCustom",
        name: "chainlinkWrapper",
        type: "address",
      },
      {
        internalType: "uint32",
        name: "VRFCallbackGasExtraBet",
        type: "uint32",
      },
      {
        internalType: "bool",
        name: "nativePayment",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint16",
        name: "betCount",
        type: "uint16",
      },
    ],
    name: "getChainlinkVRFCost",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
    ],
    name: "hasPendingBets",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "maxCallGas",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "maxColors",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "paused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "requestId",
        type: "uint256",
      },
      {
        internalType: "uint256[]",
        name: "randomWords",
        type: "uint256[]",
      },
    ],
    name: "rawFulfillRandomWords",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
    ],
    name: "refundBet",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "refundTime",
    outputs: [
      {
        internalType: "uint64",
        name: "",
        type: "uint64",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "s_vrfCoordinator",
    outputs: [
      {
        internalType: "contract IVRFCoordinatorV2Plus",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint16",
        name: "affiliateHouseEdge",
        type: "uint16",
      },
    ],
    name: "setAffiliateHouseEdge",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint16",
        name: "requestConfirmations",
        type: "uint16",
      },
      {
        internalType: "bytes32",
        name: "keyHash",
        type: "bytes32",
      },
      {
        internalType: "contract IVRFV2PlusWrapperCustom",
        name: "chainlinkWrapper",
        type: "address",
      },
      {
        internalType: "uint32",
        name: "VRFCallbackGasExtraBet",
        type: "uint32",
      },
      {
        internalType: "bool",
        name: "nativePayment",
        type: "bool",
      },
    ],
    name: "setChainlinkConfig",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_vrfCoordinator",
        type: "address",
      },
    ],
    name: "setCoordinator",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint16",
        name: "houseEdge",
        type: "uint16",
      },
    ],
    name: "setHouseEdge",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "maxCallGas_",
        type: "uint256",
      },
    ],
    name: "setMaxCallGas",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint8",
        name: "maxColors_",
        type: "uint8",
      },
    ],
    name: "setMaxColors",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint64",
        name: "refundTime_",
        type: "uint64",
      },
    ],
    name: "setRefundTime",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint32",
        name: "callbackGasBase",
        type: "uint32",
      },
    ],
    name: "setVRFCallbackGasBase",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "subId",
        type: "uint256",
      },
    ],
    name: "setVRFSubId",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "togglePause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    name: "tokens",
    outputs: [
      {
        internalType: "uint16",
        name: "houseEdge",
        type: "uint16",
      },
      {
        internalType: "uint64",
        name: "pendingCount",
        type: "uint64",
      },
      {
        internalType: "uint256",
        name: "vrfSubId",
        type: "uint256",
      },
      {
        internalType: "uint32",
        name: "VRFCallbackGasBase",
        type: "uint32",
      },
      {
        internalType: "uint256",
        name: "VRFFees",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "configId",
        type: "uint32",
      },
      {
        internalType: "address",
        name: "receiver",
        type: "address",
      },
      {
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
      {
        components: [
          {
            internalType: "address",
            name: "token",
            type: "address",
          },
          {
            internalType: "uint256",
            name: "betAmount",
            type: "uint256",
          },
          {
            internalType: "uint16",
            name: "betCount",
            type: "uint16",
          },
          {
            internalType: "uint256",
            name: "stopGain",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "stopLoss",
            type: "uint256",
          },
          {
            internalType: "uint16",
            name: "maxHouseEdge",
            type: "uint16",
          },
        ],
        internalType: "struct IGamePlayer.BetData",
        name: "betData",
        type: "tuple",
      },
    ],
    name: "wager",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "payable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "bet",
        type: "bytes",
      },
      {
        internalType: "address",
        name: "receiver",
        type: "address",
      },
      {
        internalType: "address",
        name: "affiliate",
        type: "address",
      },
      {
        components: [
          {
            internalType: "address",
            name: "token",
            type: "address",
          },
          {
            internalType: "uint256",
            name: "betAmount",
            type: "uint256",
          },
          {
            internalType: "uint16",
            name: "betCount",
            type: "uint16",
          },
          {
            internalType: "uint256",
            name: "stopGain",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "stopLoss",
            type: "uint256",
          },
          {
            internalType: "uint16",
            name: "maxHouseEdge",
            type: "uint16",
          },
        ],
        internalType: "struct IGamePlayer.BetData",
        name: "betData",
        type: "tuple",
      },
    ],
    name: "wagerWithData",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "payable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
    ],
    name: "wheelBets",
    outputs: [
      {
        components: [
          {
            internalType: "uint32",
            name: "configId",
            type: "uint32",
          },
          {
            internalType: "uint8[]",
            name: "rolled",
            type: "uint8[]",
          },
        ],
        internalType: "struct IWheel.WheelBet",
        name: "",
        type: "tuple",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
    ],
    name: "withdrawTokenVRFFees",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
] as const;

export const weightedGameAbi = wheelAbi;
</file>

<file path="packages/core/src/actions/casino/weightedGame.ts">
import { type TransactionReceipt, decodeEventLog } from "viem";
import { weightedGameAbi } from "../../abis/v2/casino/weightedGame";
import {
  type CasinoChainId,
  type WEIGHTED_CASINO_GAME_TYPE,
  labelCasinoGameByType,
} from "../../data/casino";
import {
  WeightedGame,
  type WeightedGameConfigId,
  type WeightedGameEncodedInput,
} from "../../entities";
import { ERROR_CODES } from "../../errors/codes";
import { TransactionError } from "../../errors/types";
import type { Token } from "../../interfaces";
import type { BetSwirlWallet } from "../../provider";
import type { WeightedGameConfiguration } from "../../read";
import {
  type CasinoBetParams,
  type CasinoPlaceBetOptions,
  type PlaceBetCallbacks,
  type WeightedCasinoPlacedBet,
  getPlacedBetFromReceipt,
  placeBet,
} from "./game";

export interface WeightedGameParams extends CasinoBetParams {
  weightedGameConfig: WeightedGameConfiguration;
  game: WEIGHTED_CASINO_GAME_TYPE;
}

export interface WeightedGamePlacedBet extends WeightedCasinoPlacedBet {
  configId: WeightedGameConfigId;
  configLabel: string;
  encodedConfigId: WeightedGameEncodedInput;
}

export async function placeWeightedGameBet(
  wallet: BetSwirlWallet,
  weightedGameParams: WeightedGameParams,
  options?: CasinoPlaceBetOptions,
  callbacks?: PlaceBetCallbacks,
): Promise<{ placedBet: WeightedGamePlacedBet; receipt: TransactionReceipt }> {
  const { placedBet, receipt } = await placeBet(
    wallet,
    {
      gameEncodedInput: WeightedGame.encodeInput(weightedGameParams.weightedGameConfig.configId),
      ...weightedGameParams,
    },
    options,
    callbacks,
  );
  const weightedGamePlacedBet = await getWeightedGamePlacedBetFromReceipt(
    wallet,
    receipt,
    placedBet.chainId,
    weightedGameParams.game,
    placedBet.token,
  );
  if (!weightedGamePlacedBet) {
    throw new TransactionError(
      `${labelCasinoGameByType[weightedGameParams.game]} PlaceBet event not found`,
      ERROR_CODES.GAME.PLACE_BET_EVENT_NOT_FOUND,
      {
        hash: receipt.transactionHash,
        chainId: placedBet.chainId,
      },
    );
  }
  return { placedBet: weightedGamePlacedBet, receipt };
}

export async function getWeightedGamePlacedBetFromReceipt(
  wallet: BetSwirlWallet,
  receipt: TransactionReceipt,
  chainId: CasinoChainId,
  game: WEIGHTED_CASINO_GAME_TYPE,
  usedToken?: Token,
  customWeightedGameConfigs?: WeightedGameConfiguration[],
): Promise<WeightedGamePlacedBet | null> {
  const gamePlacedBet = await getPlacedBetFromReceipt(wallet, receipt, game, chainId, usedToken);
  if (!gamePlacedBet) {
    return null;
  }

  // Read the Weighted game PlaceBet event from logs
  const decodedWeightedGamePlaceBetEvent = receipt.logs
    .map((log) => {
      try {
        return decodeEventLog({
          abi: weightedGameAbi,
          data: log.data,
          topics: log.topics,
        });
      } catch {
        return null;
      }
    })
    .find((log) => log?.eventName === "PlaceBet");

  if (!decodedWeightedGamePlaceBetEvent) {
    return null;
  }

  const { args } = decodedWeightedGamePlaceBetEvent;
  return {
    ...gamePlacedBet,
    game,
    encodedConfigId: args.configId,
    configId: WeightedGame.decodeInput(args.configId),
    configLabel: WeightedGame.getWeightedGameConfigLabel(
      WeightedGame.decodeInput(args.configId),
      chainId,
      customWeightedGameConfigs,
    ),
  };
}
</file>

<file path="packages/core/src/actions/casino/wheel.ts">
import { type TransactionReceipt } from "viem";
import { CASINO_GAME_TYPE, type CasinoChainId } from "../../data/casino";
import type { Token } from "../../interfaces";
import type { BetSwirlWallet } from "../../provider";
import type { WeightedGameConfiguration } from "../../read";
import { type CasinoPlaceBetOptions, type PlaceBetCallbacks } from "./game";
import {
  type WeightedGameParams,
  type WeightedGamePlacedBet,
  getWeightedGamePlacedBetFromReceipt,
  placeWeightedGameBet,
} from "./weightedGame";

export interface WheelParams extends Omit<WeightedGameParams, "game"> {}

export interface WheelPlacedBet extends WeightedGamePlacedBet {}

export async function placeWheelBet(
  wallet: BetSwirlWallet,
  wheelParams: WheelParams,
  options?: CasinoPlaceBetOptions,
  callbacks?: PlaceBetCallbacks,
): Promise<{ placedBet: WheelPlacedBet; receipt: TransactionReceipt }> {
  return await placeWeightedGameBet(
    wallet,
    {
      ...wheelParams,
      game: CASINO_GAME_TYPE.WHEEL,
    },
    options,
    callbacks,
  );
}

export async function getWheelPlacedBetFromReceipt(
  wallet: BetSwirlWallet,
  receipt: TransactionReceipt,
  chainId: CasinoChainId,
  usedToken?: Token,
  customWheelConfigs?: WeightedGameConfiguration[],
): Promise<WheelPlacedBet | null> {
  return await getWeightedGamePlacedBetFromReceipt(
    wallet,
    receipt,
    chainId,
    CASINO_GAME_TYPE.WHEEL,
    usedToken,
    customWheelConfigs,
  );
}
</file>

<file path="packages/core/src/data/subgraphs/protocol/documents/fragments/bet.graphql">
fragment Bet on Bet {
  id
  gameId
  gameAddress
  user {
    address: id
  }
  gameToken {
    id
    token {
      address: id
      symbol
      name
      decimals
    }
  }
  affiliate {
    address: id
  }
  encodedInput: inputValue
  betAmount
  betCount
  stopLoss
  stopGain
  houseEdge
  betTimestamp
  isResolved: resolved
  isRefunded: refunded
  chargedVRFFees
  betTxnHash
  rollTotalBetAmount: totalBetAmount
  payout
  payoutMultiplier
  rollTxnHash
  encodedRolled: rolled
  rollTimestamp
  weightedGameBet {
    config {
      id
      multipliers
      weights
    }
  }
}
</file>

<file path="packages/core/src/data/chains.ts">
import {
  type Chain,
  arbitrum,
  arbitrumSepolia,
  avalanche,
  avalancheFuji,
  base,
  baseSepolia,
  bsc,
  bscTestnet,
  gnosis,
  mainnet,
  polygon,
  polygonAmoy,
  sepolia,
} from "viem/chains";
import type { Token } from "../interfaces";

export type ChainId = keyof typeof chainById;

export const chainByKey = {
  polygon,
  polygonAmoy,
  avalanche,
  avalancheFuji,
  arbitrum,
  arbitrumSepolia,
  bsc,
  bscTestnet,
  mainnet,
  sepolia,
  base,
  baseSepolia,
  gnosis,
} as const;

export const chains = Object.values(chainByKey) as unknown as readonly [Chain, ...Chain[]];

export const chainById = {
  [polygon.id]: polygon,
  [polygonAmoy.id]: polygonAmoy,
  [avalanche.id]: avalanche,
  [avalancheFuji.id]: avalancheFuji,
  [arbitrum.id]: arbitrum,
  [arbitrumSepolia.id]: arbitrumSepolia,
  [bsc.id]: bsc,
  [bscTestnet.id]: bscTestnet,
  [mainnet.id]: mainnet,
  [sepolia.id]: sepolia,
  [base.id]: base,
  [baseSepolia.id]: baseSepolia,
  [gnosis.id]: gnosis,
} as const;

export const slugById = {
  [polygon.id as number]: "polygon",
  [polygonAmoy.id as number]: "amoy",
  [avalanche.id as number]: "avalanche",
  [avalancheFuji.id as number]: "fuji",
  [arbitrum.id as number]: "arbitrum",
  [arbitrumSepolia.id as number]: "arbitrum-sepolia",
  [bsc.id as number]: "bnb-chain",
  [bscTestnet.id as number]: "bnb-chain-testnet",
  [mainnet.id as number]: "ethereum",
  [sepolia.id as number]: "sepolia",
  [base.id as number]: "base",
  [baseSepolia.id as number]: "base-sepolia",
  [gnosis.id as number]: "gnosis",
} as const;

export const wrappedGasTokenById: Record<number, Token["address"]> = {
  [polygon.id]: "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270",
  [polygonAmoy.id]: "0x52eF3d68BaB452a294342DC3e5f464d7f610f72E",
  [avalanche.id]: "0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7",
  [avalancheFuji.id]: "0xd00ae08403B9bbb9124bB305C09058E32C39A48c",
  [arbitrum.id]: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
  [arbitrumSepolia.id]: "0x187De399100aA962F209Aa78621F5138ACA6111f",
  [bsc.id]: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
  [bscTestnet.id]: "0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd",
  [mainnet.id]: "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
  [sepolia.id]: "0x7b79995e5f793A07Bc00c21412e50Ecae098E7f9",
  [base.id]: "0x4200000000000000000000000000000000000006",
  [baseSepolia.id]: "0x4200000000000000000000000000000000000006",
  [gnosis.id]: "0x6a023ccd1ff6f2045c3309768ead9e68f978f6e1",
};
</file>

<file path="packages/core/src/entities/casino/cointoss.ts">
import { BP_VALUE } from "../../constants";
import { CASINO_GAME_TYPE } from "../../data/casino";
import { getFormattedNetMultiplier, getNetMultiplier } from "../../utils/bet";
import { AbstractCasinoGame, type ChoiceInput } from "./game";

export enum COINTOSS_FACE {
  TAILS = "TAILS",
  HEADS = "HEADS",
}

export interface CoinTossChoiceInput extends ChoiceInput<CASINO_GAME_TYPE.COINTOSS> {
  value: COINTOSS_FACE;
  id: COINTOSS_FACE;
}

export type CoinTossEncodedInput = boolean;
export type CoinTossEncodedRolled = boolean;

export class CoinToss extends AbstractCasinoGame<
  COINTOSS_FACE,
  CoinTossEncodedInput,
  COINTOSS_FACE,
  CoinTossEncodedRolled
> {
  static getWinChancePercent(_face: COINTOSS_FACE | string): number {
    return 50;
  }

  static getMultiplier(_face: COINTOSS_FACE | string): number {
    return 20000;
  }

  static getFormattedMultiplier(_face: COINTOSS_FACE | string): number {
    return Number((CoinToss.getMultiplier(_face) / BP_VALUE).toFixed(3));
  }

  static encodeInput(face: COINTOSS_FACE | string): CoinTossEncodedInput {
    return face === COINTOSS_FACE.HEADS || face.toLowerCase() === "true" || face === "1";
  }

  static decodeInput(encodedFace: CoinTossEncodedInput | string): COINTOSS_FACE {
    if (typeof encodedFace === "string") {
      const normalizedValue = encodedFace.toLowerCase();
      return normalizedValue === "true" || normalizedValue === "1"
        ? COINTOSS_FACE.HEADS
        : COINTOSS_FACE.TAILS;
    }
    return encodedFace ? COINTOSS_FACE.HEADS : COINTOSS_FACE.TAILS;
  }

  static decodeRolled(encodedFace: CoinTossEncodedRolled | string): COINTOSS_FACE {
    return CoinToss.decodeInput(encodedFace);
  }
  // houseEdge is a number between 0 and 10000
  static getChoiceInputs(houseEdge?: number): CoinTossChoiceInput[] {
    const multiplier = CoinToss.getMultiplier(COINTOSS_FACE.TAILS);
    const formattedMultiplier = CoinToss.getFormattedMultiplier(COINTOSS_FACE.TAILS);
    const netMultiplier = houseEdge ? getNetMultiplier(multiplier, houseEdge) : undefined;
    const formattedNetMultiplier = houseEdge
      ? getFormattedNetMultiplier(multiplier, houseEdge)
      : undefined;

    return [
      {
        value: COINTOSS_FACE.TAILS,
        id: COINTOSS_FACE.TAILS,
        game: CASINO_GAME_TYPE.COINTOSS,
        label: "Tails",
        winChancePercent: CoinToss.getWinChancePercent(COINTOSS_FACE.TAILS),
        multiplier: CoinToss.getMultiplier(COINTOSS_FACE.TAILS),
        formattedMultiplier,
        netMultiplier,
        formattedNetMultiplier,
      },
      {
        value: COINTOSS_FACE.HEADS,
        id: COINTOSS_FACE.HEADS,
        game: CASINO_GAME_TYPE.COINTOSS,
        label: "Heads",
        winChancePercent: CoinToss.getWinChancePercent(COINTOSS_FACE.HEADS),
        multiplier: multiplier,
        formattedMultiplier,
        netMultiplier,
        formattedNetMultiplier,
      },
    ];
  }
}
</file>

<file path="packages/core/src/entities/casino/game.ts">
import type {
  CoinTossChoiceInput,
  DiceChoiceInput,
  KenoChoiceInput,
  RouletteChoiceInput,
} from "..";
import { CASINO_GAME_TYPE, type WEIGHTED_CASINO_GAME_TYPE } from "../../data/casino";

type MayBeMultiOutputsValue<T extends CASINO_GAME_TYPE> = T extends
  | CASINO_GAME_TYPE.KENO
  | WEIGHTED_CASINO_GAME_TYPE
  ? number[]
  : number;

export interface ChoiceInput<T extends CASINO_GAME_TYPE = CASINO_GAME_TYPE> {
  game: CASINO_GAME_TYPE;
  label: string;
  winChancePercent: MayBeMultiOutputsValue<T>;
  multiplier: MayBeMultiOutputsValue<T>;
  formattedMultiplier: MayBeMultiOutputsValue<T>;
  netMultiplier?: MayBeMultiOutputsValue<T>;
  formattedNetMultiplier?: MayBeMultiOutputsValue<T>;
}

// Game should not know the game implementation details, but well..  it helps developers
export type NormalGameChoiceInput =
  | CoinTossChoiceInput
  | DiceChoiceInput
  | RouletteChoiceInput
  | KenoChoiceInput;

export abstract class AbstractCasinoGame<TInput, TEncodedInput, TRolled, TEncodedRolled> {
  getWinChancePercent(_input: TInput | string): number {
    throw new Error("Not implemented");
  }
  encodeInput(_input: TInput | string): TEncodedInput {
    throw new Error("Not implemented");
  }
  decodeInput(_encodedInput: TEncodedInput | string): TInput {
    throw new Error("Not implemented");
  }
  getMultiplier(_input: TInput | string): number {
    throw new Error("Not implemented");
  }
  getFormattedMultiplier(_input: TInput | string): number {
    throw new Error("Not implemented");
  }
  decodeRolled(_encodedRolledInput: TEncodedRolled | string): TRolled {
    throw new Error("Not implemented");
  }
}
</file>

<file path="packages/core/src/entities/casino/keno.ts">
import { getFormattedNetMultiplier } from "../..";
import { CASINO_GAME_TYPE, getNetMultiplier } from "../..";
import { BP_VALUE } from "../../constants";
import type { KenoConfiguration } from "../../read/casino/keno";
import { AbstractCasinoGame, type ChoiceInput } from "./game";

export type KenoBall =
  | 1
  | 2
  | 3
  | 4
  | 5
  | 6
  | 7
  | 8
  | 9
  | 10
  | 11
  | 12
  | 13
  | 14
  | 15
  | 16
  | 17
  | 18
  | 19
  | 20
  | 21
  | 22
  | 23
  | 24
  | 25
  | 26
  | 27
  | 28
  | 29
  | 30
  | 31
  | 32
  | 33
  | 34
  | 35
  | 36
  | 37
  | 38
  | 39
  | 40;
export enum KENO_INPUT_BUNDLE {
  MAX_FIRST_NUMBERS = "All last numbers",
  MAX_LAST_NUMBERS = "All first numbers",
  FIRST_AND_LAST = "The first and the last number",
}

export interface KenoChoiceInput extends ChoiceInput<CASINO_GAME_TYPE.KENO> {
  value: KenoBall[];
  config: KenoConfiguration;
  id: KenoBall[] | KENO_INPUT_BUNDLE;
}

export type KenoEncodedInput = number;
export type KenoEncodedRolled = bigint[];

export class Keno extends AbstractCasinoGame<
  KenoBall[],
  KenoEncodedInput,
  KenoBall[],
  KenoEncodedRolled[]
> {
  static getWinChancePercent(
    kenoConfig: KenoConfiguration,
    selectedBallsCount: number,
    matchedBallsCount: number,
  ): number {
    const multiplier = Keno.getMultiplier(kenoConfig, selectedBallsCount, matchedBallsCount);
    if (!multiplier) return 0;

    return (1 / multiplier / (selectedBallsCount + 1)) * BP_VALUE * 100;
  }

  static getMultiplier(
    kenoConfig: KenoConfiguration,
    selectedBallsCount: number,
    matchedBallsCount: number,
  ): number {
    return kenoConfig.mutliplierTable[selectedBallsCount]?.[matchedBallsCount] || 0;
  }

  static getFormattedMultiplier(
    kenoConfig: KenoConfiguration,
    selectedBallsCount: number,
    matchedBallsCount: number,
  ): number {
    return Number(
      (Keno.getMultiplier(kenoConfig, selectedBallsCount, matchedBallsCount) / BP_VALUE).toFixed(3),
    );
  }

  static encodeInput(balls: KenoBall[], kenoConfig: KenoConfiguration): KenoEncodedInput {
    // 1. Make the array unique
    const uniqueNumbers = [...new Set(balls)];
    // 2. Sort the array
    const sortedNumbers = uniqueNumbers.sort((a, b) => a - b);
    // 3. Create a boolean array
    const sortedBooleans: boolean[] = Array(kenoConfig.biggestSelectableBall).fill(false);
    for (const num of sortedNumbers) {
      sortedBooleans[num] = true;
    }
    // 4. Create a binary numbers
    const binaryNumbers = Object.values(sortedBooleans)
      .slice()
      .reverse()
      .reduce((numbers, isActive) => {
        return numbers + (isActive ? 1 : 0);
      }, "");
    // 5. Transform the binary numbers to a number
    return Number.parseInt(binaryNumbers, 2);
  }

  static decodeInput(encodedBalls: KenoEncodedInput | string): KenoBall[] {
    return Keno.maskToBalls(Number(encodedBalls));
  }

  static decodeRolled(encodedRolled: KenoEncodedRolled | string): KenoBall[] {
    return Keno.maskToBalls(Number(encodedRolled));
  }

  static getChoiceInputs(kenoConfig: KenoConfiguration, houseEdge?: number): KenoChoiceInput[] {
    const createChoiceInput = (
      balls: KenoBall[],
      id: KenoBall[] | KENO_INPUT_BUNDLE,
      selectedBallsCount: number,
      label: string,
    ): KenoChoiceInput => {
      // eg. selectedBallsCount = 2 => possibleMatchedCounts = [0, 1, 2]
      const possibleMatchedCounts = Array.from({ length: selectedBallsCount + 1 }, (_, i) => i);
      return {
        value: balls,
        config: kenoConfig,
        id,
        game: CASINO_GAME_TYPE.KENO,
        label,
        winChancePercent: possibleMatchedCounts.map((matchedCount) =>
          Keno.getWinChancePercent(kenoConfig, selectedBallsCount, matchedCount),
        ),
        multiplier: possibleMatchedCounts.map((matchedCount) =>
          Keno.getMultiplier(kenoConfig, selectedBallsCount, matchedCount),
        ),
        formattedMultiplier: possibleMatchedCounts.map((matchedCount) =>
          Keno.getFormattedMultiplier(kenoConfig, selectedBallsCount, matchedCount),
        ),
        netMultiplier: houseEdge
          ? possibleMatchedCounts.map((matchedCount) =>
              getNetMultiplier(
                Keno.getMultiplier(kenoConfig, selectedBallsCount, matchedCount),
                houseEdge,
              ),
            )
          : undefined,
        formattedNetMultiplier: houseEdge
          ? possibleMatchedCounts.map((matchedCount) =>
              getFormattedNetMultiplier(
                Keno.getMultiplier(kenoConfig, selectedBallsCount, matchedCount),
                houseEdge,
              ),
            )
          : undefined,
      };
    };

    // 1. Single numbers
    const choiceInputs: KenoChoiceInput[] = Array.from(
      { length: kenoConfig.biggestSelectableBall },
      (_, i) => {
        const kenoBall = (i + 1) as KenoBall;
        return createChoiceInput([kenoBall], [kenoBall], 1, `${kenoBall}`);
      },
    );

    // 2. First one and last one
    if (kenoConfig.maxSelectableBalls > 1 && kenoConfig.biggestSelectableBall > 1) {
      choiceInputs.push(
        createChoiceInput(
          [1, kenoConfig.biggestSelectableBall as KenoBall],
          KENO_INPUT_BUNDLE.FIRST_AND_LAST,
          2,
          `${KENO_INPUT_BUNDLE.FIRST_AND_LAST} (1 & ${kenoConfig.biggestSelectableBall})`,
        ),
      );
    }

    // 3. All first numbers
    const maxFirstNumbers = Array.from(
      { length: kenoConfig.maxSelectableBalls },
      (_, i) => (i + 1) as KenoBall,
    );
    choiceInputs.push(
      createChoiceInput(
        maxFirstNumbers,
        KENO_INPUT_BUNDLE.MAX_FIRST_NUMBERS,
        kenoConfig.maxSelectableBalls,
        `${KENO_INPUT_BUNDLE.MAX_FIRST_NUMBERS} (${maxFirstNumbers.join(", ")})`,
      ),
    );

    // 4. All last numbers
    const maxLastNumbers = Array.from(
      { length: kenoConfig.maxSelectableBalls },
      (_, i) => (kenoConfig.biggestSelectableBall - i) as KenoBall,
    );
    choiceInputs.push(
      createChoiceInput(
        maxLastNumbers,
        KENO_INPUT_BUNDLE.MAX_LAST_NUMBERS,
        kenoConfig.maxSelectableBalls,
        `${KENO_INPUT_BUNDLE.MAX_LAST_NUMBERS} (${maxLastNumbers.join(", ")})`,
      ),
    );

    return choiceInputs;
  }

  // Keno utilities

  static maskToBalls(encodedBalls: number) {
    return encodedBalls
      .toString(2)
      .split("")
      .reverse()
      .map((ball, i) => (ball === "1" ? i + 1 : 0))
      .filter((ball) => ball) as KenoBall[];
  }
}
</file>

<file path="packages/core/src/entities/casino/weightedGame.ts">
import {
  type CasinoChainId,
  type WEIGHTED_CASINO_GAME_TYPE,
  type WeightedGameConfiguration,
  getFormattedNetMultiplier,
  weightedGameCachedConfigurations,
} from "../..";
import { getNetMultiplier } from "../..";
import { BP_VALUE } from "../../constants";
import { AbstractCasinoGame, type ChoiceInput } from "./game";

export type WeightedGameConfigId = number;

export interface WeightedGameChoiceInput extends ChoiceInput<WEIGHTED_CASINO_GAME_TYPE> {
  value: WeightedGameConfigId;
  config: WeightedGameConfiguration;
  id: WeightedGameConfigId;
}

export type WeightedGameEncodedInput = number; // configId
export type WeightedGameEncodedRolled = number; // the position of the rolled multiplier

export class WeightedGame extends AbstractCasinoGame<
  string,
  WeightedGameEncodedInput,
  string,
  WeightedGameEncodedRolled
> {
  static getWinChancePercent(
    weightedGameConfig: WeightedGameConfiguration,
    position: number,
  ): number {
    /*const multipliersPositions = weightedGameConfig.multipliers.map((w, i) => w === multiplier ? i : null).filter(m => m !== null)

    const weights = weightedGameConfig.weights.filter((_, i) => multipliersPositions.includes(i))
    const totalWeight = weightedGameConfig.weights.reduce((acc, curr) => acc + curr, 0n)
    const totalWeightForMultiplier = weights.reduce((acc, curr) => acc + curr, 0n)

    return Number(totalWeightForMultiplier) / Number(totalWeight) * 100 */

    const weight = weightedGameConfig.weights[position];
    const totalWeight = weightedGameConfig.weights.reduce((acc, curr) => acc + curr, 0n);
    return (Number(weight) / Number(totalWeight)) * 100;
  }

  static getMultiplier(weightedGameConfig: WeightedGameConfiguration, position: number): number {
    return Number(weightedGameConfig.multipliers[position] ?? 0);
  }

  static getFormattedMultiplier(
    weightedGameConfig: WeightedGameConfiguration,
    position: number,
  ): number {
    return Number((WeightedGame.getMultiplier(weightedGameConfig, position) / BP_VALUE).toFixed(3));
  }

  static encodeInput(configId: WeightedGameConfigId): WeightedGameEncodedInput {
    return configId;
  }

  static decodeInput(configId: WeightedGameEncodedInput | string): WeightedGameConfigId {
    return Number(configId);
  }

  static decodeRolled(
    encodedRolled: WeightedGameEncodedRolled | string,
    weightedGameConfiguration: WeightedGameConfiguration,
    houseEdge: number,
  ): string {
    const multiplier = weightedGameConfiguration.multipliers[Number(encodedRolled)];
    const netMultiplier = (Number(multiplier) * (1 - houseEdge / BP_VALUE)) / BP_VALUE;
    return `x${netMultiplier.toFixed(2)}`;
  }

  static getChoiceInputs(
    chainId: CasinoChainId,
    houseEdge?: number,
    customWeightedGameConfigs?: WeightedGameConfiguration[],
  ): WeightedGameChoiceInput[] {
    const weightedGameConfigs = [
      ...weightedGameCachedConfigurations[chainId],
      ...(customWeightedGameConfigs ?? []),
    ];
    return weightedGameConfigs.map((config) => {
      const multipliers = config.multipliers;
      return {
        value: config.configId,
        config: config,
        id: config.configId,
        game: config.game,
        label: WeightedGame.getWeightedGameConfigLabel(
          config.configId,
          chainId,
          customWeightedGameConfigs,
        ),
        winChancePercent: multipliers.map((_, index) =>
          WeightedGame.getWinChancePercent(config, index),
        ),
        multiplier: multipliers.map((_, index) => WeightedGame.getMultiplier(config, index)),
        formattedMultiplier: multipliers.map((_, index) =>
          WeightedGame.getFormattedMultiplier(config, index),
        ),
        netMultiplier: houseEdge
          ? multipliers.map((_, index) =>
              getNetMultiplier(WeightedGame.getMultiplier(config, index), houseEdge),
            )
          : undefined,
        formattedNetMultiplier: houseEdge
          ? multipliers.map((_, index) =>
              getFormattedNetMultiplier(WeightedGame.getMultiplier(config, index), houseEdge),
            )
          : undefined,
      };
    });
  }

  // Weighted game utilies
  static getWeightedGameConfigLabel(
    configId: WeightedGameConfigId,
    chainId: CasinoChainId,
    customWeightedGameConfigs?: WeightedGameConfiguration[],
  ): string {
    const existingCachedConfig = weightedGameCachedConfigurations[chainId].find(
      (c) => c.configId === configId,
    );
    const existingCustomConfig = customWeightedGameConfigs?.find((c) => c.configId === configId);
    return existingCachedConfig?.label ?? existingCustomConfig?.label ?? `Config #${configId}`;
  }
}
</file>

<file path="packages/core/src/errors/codes.ts">
export const ERROR_CODES = {
  CHAIN: {
    UNSUPPORTED_CHAIN: "UNSUPPORTED_CHAIN",
    UNSUPPORTED_GAME: "UNSUPPORTED_GAME",
  },
  TRANSACTION: {
    TOKEN_APPROVAL_ERROR: "TOKEN_APPROVAL_ERROR",
    TOKEN_METADATA_ERROR: "TOKEN_METADATA_ERROR",
  },
  READ: {
    CHAINLINK_VRF_COST_ERROR: "CHAINLINK_VRF_COST_ERROR",
  },
  GAME: {
    PLACE_BET_ERROR: "PLACE_BET_ERROR",
    PLACE_BET_EVENT_NOT_FOUND: "PLACE_BET_EVENT_NOT_FOUND",
    ROLL_EVENT_ERROR: "ROLL_EVENT_ERROR",
    ROLL_EVENT_TIMEOUT: "ROLL_EVENT_TIMEOUT",
    GET_PAUSED_ERROR: "GET_PAUSED_ERROR",
    GET_TOKEN_ERROR: "GET_TOKEN_ERROR",
    GET_AFFILIATE_HOUSE_EDGE_ERROR: "GET_AFFILIATE_HOUSE_EDGE_ERROR",
    GET_KENO_CONFIGURATION_ERROR: "GET_KENO_CONFIGURATION_ERROR",
    GET_WEIGHTED_GAME_CONFIGURATION_ERROR: "GET_WEIGHTED_GAME_CONFIGURATION_ERROR",
  },
  BANK: {
    GET_TOKENS_ERROR: "GET_TOKENS_ERROR",
    GET_BET_REQUIREMENTS_ERROR: "GET_BET_REQUIREMENTS_ERROR",
  },
  SUBGRAPH: {
    FETCH_BET_ERROR: "FETCH_BET_ERROR",
    FETCH_BETS_ERROR: "FETCH_BETS_ERROR",
    FETCH_TOKENS_ERROR: "FETCH_TOKENS_ERROR",
    FETCH_TOKEN_ERROR: "FETCH_TOKEN_ERROR",
  },

  WALLET: {
    ACCOUNT_MISSING: "ACCOUNT_MISSING",
    GET_TRANSACTION_RECEIPT_ERROR: "GET_TRANSACTION_RECEIPT_ERROR",
  },
} as const;
</file>

<file path="packages/core/src/read/casino/cointoss.ts">
import { type TransactionReceipt } from "viem";
import { type CoinTossPlacedBet } from "../../actions/casino/cointoss";
import { type COINTOSS_FACE, CoinToss } from "../../entities/casino/cointoss";
import type { BetSwirlWallet } from "../../provider";
import { type CasinoRolledBet, type CasinoWaitRollOptions, waitRolledBet } from "./game";

export interface CoinTossRolledBet extends Omit<CasinoRolledBet, "decodedRoll"> {
  rolled: COINTOSS_FACE[];
}

export async function waitCoinTossRolledBet(
  wallet: BetSwirlWallet,
  placedBet: CoinTossPlacedBet,
  options?: CasinoWaitRollOptions,
): Promise<{
  rolledBet: CoinTossRolledBet;
  receipt: TransactionReceipt;
}> {
  const { rolledBet, receipt } = await waitRolledBet(wallet, placedBet, options);
  return {
    rolledBet: {
      ...rolledBet,
      rolled: rolledBet.encodedRolled.map(CoinToss.decodeRolled),
    },
    receipt,
  };
}
</file>

<file path="packages/core/src/read/casino/game.ts">
import {
  type Address,
  type Hash,
  type Hex,
  type TransactionReceipt,
  encodeFunctionData,
  formatUnits,
  parseAbiItem,
} from "viem";
import { getLogs } from "viem/actions";
import { casinoGameAbi } from "../../abis/v2/casino/game";
import type {
  CasinoPlacedBet,
  NormalCasinoPlacedBet,
  WeightedCasinoPlacedBet,
} from "../../actions/casino/game";
import {
  CASINO_GAME_ROLL_ABI,
  CASINO_GAME_TYPE,
  type CasinoChainId,
  type NORMAL_CASINO_GAME_TYPE,
  type WEIGHTED_CASINO_GAME_TYPE,
  casinoChainById,
  labelCasinoGameByType,
} from "../../data/casino";
import { ERROR_CODES } from "../../errors/codes";
import { ChainError } from "../../errors/types";
import { TransactionError } from "../../errors/types";
import type {
  BetSwirlFunctionData,
  CasinoGame,
  CasinoGameToken,
  CasinoToken,
  Token,
} from "../../interfaces";
import type { BetSwirlWallet } from "../../provider";
import {
  chainNativeCurrencyToToken,
  decodeNormalCasinoRolled,
  decodeWeightedCasinoRolled,
} from "../../utils";
import { getCasinoChainId } from "../../utils/chains";
import { FORMAT_TYPE, formatRawAmount } from "../../utils/format";
import { getTransactionReceiptWithRetry } from "../../utils/wallet";
import type { WeightedGameConfiguration } from "./weightedGame";

export type CasinoRolledBet = CasinoPlacedBet & {
  isWin: boolean;
  isLost: boolean;
  isStopLossTriggered: boolean;
  isStopGainTriggered: boolean;
  rollBetCount: number;
  rollTotalBetAmount: bigint;
  formattedRollTotalBetAmount: string;
  payout: bigint;
  formattedPayout: string;
  benefit: bigint;
  formattedBenefit: string;
  formattedPayoutMultiplier: string;
  rollTxnHash: Hash;
  encodedRolled: any[];
  decodedRolled: any[];
  nativeCurrency: Token;
  // Placed bet formatted properties
  formattedBetAmount: string;
  formattedTotalBetAmount: string;
  formattedStopLoss: string;
  formattedStopGain: string;
  formattedChargedVRFFees: string;
};

export interface CasinoWaitRollOptions {
  pollingInterval?: number;
  timeout?: number;
  formatType?: FORMAT_TYPE;
}

export const defaultCasinoWaiRollOptions = {
  timeout: 120000, // 2 mins
  //pollingInterval: => data in casino.ts
};

interface RollEventArgs {
  id?: bigint;
  payout?: bigint;
  totalBetAmount?: bigint;
  rolled?: any[];
}

interface RollEvent {
  args: RollEventArgs;
  transactionHash: Hash;
}

// Normal game
export function formatCasinoRolledBet(
  placedBet: NormalCasinoPlacedBet,
  rollEvent: RollEvent,
  formatType?: FORMAT_TYPE,
): CasinoRolledBet;

// Weighted game
export function formatCasinoRolledBet(
  placedBet: WeightedCasinoPlacedBet,
  rollEvent: RollEvent,
  formatType: FORMAT_TYPE | undefined,
  weightedGameConfiguration: WeightedGameConfiguration,
  houseEdge: number,
): CasinoRolledBet;

export function formatCasinoRolledBet(
  placedBet: CasinoPlacedBet,
  rollEvent: RollEvent,
  formatType: FORMAT_TYPE = FORMAT_TYPE.STANDARD,
  weightedGameConfiguration?: WeightedGameConfiguration,
  houseEdge?: number,
): CasinoRolledBet {
  const args = rollEvent.args;
  const isWin = args.payout! >= args.totalBetAmount!;
  const isStopTriggered = args.rolled!.length !== placedBet.betCount;
  const casinoChain = casinoChainById[placedBet.chainId];
  const nativeCurrency = chainNativeCurrencyToToken(casinoChain.viemChain.nativeCurrency);
  const tokenDecimals = placedBet.token.decimals;

  return {
    ...placedBet,
    isWin,
    isLost: !isWin,
    isStopGainTriggered: isStopTriggered && isWin,
    isStopLossTriggered: isStopTriggered && !isWin,
    rollBetCount: args.rolled!.length,
    rollTotalBetAmount: args.totalBetAmount!,
    formattedRollTotalBetAmount: formatRawAmount(
      args.totalBetAmount!,
      placedBet.token.decimals,
      formatType,
    ),
    payout: args.payout!,
    formattedPayout: formatRawAmount(args.payout!, placedBet.token.decimals, formatType),
    benefit: args.payout! - args.totalBetAmount!,
    formattedBenefit: formatRawAmount(
      args.payout! - args.totalBetAmount!,
      placedBet.token.decimals,
      formatType,
    ),
    formattedPayoutMultiplier: (
      Number(formatUnits(BigInt(args.payout!), tokenDecimals)) /
      Number(formatUnits(BigInt(args.totalBetAmount!), tokenDecimals))
    ).toFixed(3),
    rollTxnHash: rollEvent.transactionHash,
    encodedRolled: args.rolled! as any[],
    decodedRolled: args.rolled!.map((r) =>
      weightedGameConfiguration
        ? decodeWeightedCasinoRolled(r, weightedGameConfiguration, houseEdge)
        : decodeNormalCasinoRolled(r, placedBet.game as NORMAL_CASINO_GAME_TYPE),
    ),
    nativeCurrency,
    // Placed bet formatted properties
    formattedBetAmount: formatRawAmount(placedBet.betAmount, tokenDecimals, formatType),
    formattedTotalBetAmount: formatRawAmount(placedBet.totalBetAmount, tokenDecimals, formatType),
    formattedStopLoss: formatRawAmount(placedBet.stopLoss, tokenDecimals, formatType),
    formattedStopGain: formatRawAmount(placedBet.stopGain, tokenDecimals, formatType),
    formattedChargedVRFFees: formatRawAmount(
      placedBet.chargedVRFCost,
      nativeCurrency.decimals,
      formatType,
    ),
  };
}

// Only need weightedGameConfiguration if game from placeBet is a WEIGHTED_CASINO_GAME_TYPE
export async function waitRolledBet(
  wallet: BetSwirlWallet,
  placedBet: NormalCasinoPlacedBet,
  options?: CasinoWaitRollOptions,
): Promise<{ rolledBet: CasinoRolledBet; receipt: TransactionReceipt }>;

export async function waitRolledBet(
  wallet: BetSwirlWallet,
  placedBet: WeightedCasinoPlacedBet,
  options: CasinoWaitRollOptions | undefined,
  weightedGameConfiguration: WeightedGameConfiguration,
  houseEdge: number,
): Promise<{ rolledBet: CasinoRolledBet; receipt: TransactionReceipt }>;

export async function waitRolledBet(
  wallet: BetSwirlWallet,
  placedBet: CasinoPlacedBet,
  options?: CasinoWaitRollOptions,
  weightedGameConfiguration?: WeightedGameConfiguration,
  houseEdge?: number,
): Promise<{
  rolledBet: CasinoRolledBet;
  receipt: TransactionReceipt;
}> {
  const casinoChain = casinoChainById[placedBet.chainId];
  const game = casinoChain.contracts.games[placedBet.game];
  if (!game) {
    throw new ChainError(
      `Game ${placedBet.game} not found for chain ${placedBet.chainId}`,
      ERROR_CODES.CHAIN.UNSUPPORTED_GAME,
      {
        chainId: placedBet.chainId,
        game: placedBet.game,
      },
    );
  }

  return new Promise((resolve, reject) => {
    let isResolved = false;

    const onRollEvent = async (log: RollEvent) => {
      if (isResolved) return;
      isResolved = true;
      unwatch?.();

      try {
        const receipt = await getTransactionReceiptWithRetry(wallet, log.transactionHash);

        resolve({
          rolledBet: weightedGameConfiguration
            ? formatCasinoRolledBet(
                placedBet as { game: WEIGHTED_CASINO_GAME_TYPE } & CasinoPlacedBet,
                log,
                options?.formatType,
                weightedGameConfiguration,
                houseEdge!,
              )
            : formatCasinoRolledBet(
                placedBet as { game: NORMAL_CASINO_GAME_TYPE } & CasinoPlacedBet,
                log,
                options?.formatType,
              ),
          receipt,
        });
      } catch (error) {
        reject(
          new TransactionError("Error processing Roll event", ERROR_CODES.GAME.ROLL_EVENT_ERROR, {
            betId: placedBet.id,
            chainId: placedBet.chainId,
            cause: error,
          }),
        );
      }
    };
    // Subcribe to Roll event
    const unwatch = wallet.watchContractEvent({
      data: {
        to: game.address,
        abi: game.abi,
        eventName: "Roll",
        args: { id: placedBet.id },
        pollingInterval: options?.pollingInterval || casinoChain.options.pollingInterval,
      },
      callbacks: {
        onLogs: async (logs) => {
          const matchingLog = (logs as unknown as { args: { id: bigint } }[]).find(
            (log) => log.args.id === placedBet.id,
          );
          if (matchingLog) {
            await onRollEvent(matchingLog as unknown as RollEvent);
          }
        },
        onError: (_error) => {
          // Nothing to do, the watching continues...
          /*reject(
            new TransactionError(
              "Error watching Roll event",
              ERROR_CODES.GAME.ROLL_EVENT_ERROR,
              {
                betId: placedBet.id,
                chainId: placedBet.chainId,
                cause: error,
              }
            )
          ); */
        },
      },
    });

    const publicClient = wallet.getPublicClient(placedBet.chainId);

    // Check in the past blocks if the bet has been rolled
    getLogs(publicClient, {
      address: game.address,
      event: parseAbiItem(CASINO_GAME_ROLL_ABI[placedBet.game]),
      args: { id: placedBet.id },
      fromBlock: placedBet.betBlock,
      toBlock: "latest",
    })
      .then((pastLogs) => {
        const matchingPastLog = pastLogs.find((log) => log.args.id === placedBet.id);
        if (matchingPastLog) {
          onRollEvent(matchingPastLog as RollEvent);
        }
      })
      .catch((error) => {
        if (!isResolved) {
          console.warn("Error checking past Roll events", error);
          /*reject(
            new TransactionError(
              "Error checking past Roll events",
              ERROR_CODES.GAME.ROLL_EVENT_ERROR,
              {
                betId: placedBet.id,
                chainId: placedBet.chainId,
                cause: error,
              }
            )
          ); */
        }
      });

    setTimeout(() => {
      if (!isResolved) {
        unwatch?.();
        reject(
          new TransactionError(
            "Timeout waiting for Roll event",
            ERROR_CODES.GAME.ROLL_EVENT_TIMEOUT,
            {
              betId: placedBet.id,
              chainId: placedBet.chainId,
            },
          ),
        );
      }
    }, options?.timeout || defaultCasinoWaiRollOptions.timeout);
  });
}

export type RawPaused = boolean;

export async function getCasinoGames(
  wallet: BetSwirlWallet,
  onlyActive = false,
): Promise<CasinoGame[]> {
  const casinoChainId = getCasinoChainId(wallet);

  const casinoChain = casinoChainById[casinoChainId];

  const games = casinoChain.contracts.games;

  const functionDatas = Object.keys(games).map((game) =>
    getGamePausedFunctionData(game as CASINO_GAME_TYPE, casinoChainId),
  );
  const rawPauseds = await wallet.readContracts<typeof functionDatas, RawPaused[]>(functionDatas);

  return Object.entries(games)
    .map(([gameType, game], index) => ({
      gameAddress: game.address,
      abi: game.abi,
      paused: Boolean(rawPauseds[index]),
      chainId: casinoChainId,
      game: gameType as CASINO_GAME_TYPE,
      label: labelCasinoGameByType[gameType as CASINO_GAME_TYPE],
      bankAddress: casinoChain.contracts.bank,
    }))
    .filter((game) => !onlyActive || !game.paused);
}

export async function getCasinoGamePaused(wallet: BetSwirlWallet, game: CASINO_GAME_TYPE) {
  const casinoChainId = getCasinoChainId(wallet);
  const casinoChain = casinoChainById[casinoChainId];
  const gameAddress = casinoChain.contracts.games[game]?.address;
  if (!gameAddress) {
    throw new ChainError(
      `Game ${game} not found for chain ${casinoChainId}`,
      ERROR_CODES.CHAIN.UNSUPPORTED_GAME,
    );
  }
  const functionData = getGamePausedFunctionData(game, casinoChainId);
  const rawPaused = await wallet.readContract<typeof functionData, RawPaused>(functionData);
  return rawPaused;
}

export function getGamePausedFunctionData(
  game: CASINO_GAME_TYPE,
  casinoChainId: CasinoChainId,
): BetSwirlFunctionData<typeof casinoGameAbi, "paused", readonly []> {
  const casinoChain = casinoChainById[casinoChainId];

  const gameAddress = casinoChain.contracts.games[game]?.address;
  if (!gameAddress) {
    throw new ChainError(
      `Game ${game} not found for chain ${casinoChainId}`,
      ERROR_CODES.CHAIN.UNSUPPORTED_GAME,
    );
  }

  const abi = casinoGameAbi;
  const functionName = "paused" as const;
  const args = [] as const;
  return {
    data: { to: gameAddress, abi, functionName, args },
    encodedData: encodeFunctionData({
      abi,
      functionName,
      args,
    }),
  };
}

/**
 * Raw token info data returned by the smart contract
 * [0] - houseEdge: House edge rate (BP_VALUE)
 * [1] - pendingCount: Number of pending bets
 * [2] - vrfSubId: Chainlink VRF v2.5 subscription ID
 * [3] - VRFCallbackGasBase: How much gas is needed in the Chainlink VRF callback
 * [4] - VRFFees: Chainlink's VRF collected fees amount.
 */
export type RawTokenInfo = [number, bigint, bigint, number, bigint];

export type RawAffiliateHouseEdge = bigint;

export function parseRawTokenInfoAndAffiliateHouseEdge(
  rawTokenInfo: RawTokenInfo,
  rawAffiliateHouseEdge: RawAffiliateHouseEdge,
  casinoToken: CasinoToken,
  game: CASINO_GAME_TYPE,
): CasinoGameToken {
  const defaultHouseEdge = rawTokenInfo[0];
  return {
    ...casinoToken,
    game,
    defaultHouseEdge: defaultHouseEdge,
    defaultHouseEdgePercent: defaultHouseEdge / 100,
    chainlinkVrfSubscriptionId: rawTokenInfo[2],
    affiliateHouseEdge: Number(rawAffiliateHouseEdge),
    affiliateHouseEdgePercent: Number(rawAffiliateHouseEdge) / 100,
  };
}

export async function getCasinoGameToken(
  wallet: BetSwirlWallet,
  casinoToken: CasinoToken,
  game: CASINO_GAME_TYPE,
  affiliate: Hex,
): Promise<CasinoGameToken> {
  const chainId = casinoToken.chainId;

  const tokenInfoFunctionData = getTokenInfoFunctionData(game, casinoToken.address, chainId);
  const affiliateHouseEdgeFunctionData = getAffiliateHouseEdgeFunctionData(
    game,
    casinoToken.address,
    affiliate,
    chainId,
  );

  const functionDatas = [tokenInfoFunctionData, affiliateHouseEdgeFunctionData];
  const [rawTokenData, rawAffiliateHouseEdge] = await wallet.readContracts<
    typeof functionDatas,
    [RawTokenInfo, RawAffiliateHouseEdge]
  >(functionDatas);

  return parseRawTokenInfoAndAffiliateHouseEdge(
    rawTokenData,
    rawAffiliateHouseEdge,
    casinoToken,
    game,
  );
}

export function getTokenInfoFunctionData(
  game: CASINO_GAME_TYPE,
  tokenAddress: Address,
  casinoChainId: CasinoChainId,
): BetSwirlFunctionData<typeof casinoGameAbi, "tokens", readonly [Hex]> {
  const casinoChain = casinoChainById[casinoChainId];

  const gameAddress = casinoChain.contracts.games[game]?.address;
  if (!gameAddress) {
    throw new ChainError(
      `Game ${game} not found for chain ${casinoChainId}`,
      ERROR_CODES.CHAIN.UNSUPPORTED_GAME,
    );
  }

  const abi = casinoGameAbi;
  const functionName = "tokens" as const;
  const args = [tokenAddress] as const;
  return {
    data: { to: gameAddress, abi, functionName, args },
    encodedData: encodeFunctionData({
      abi,
      functionName,
      args,
    }),
  };
}

export function getAffiliateHouseEdgeFunctionData(
  game: CASINO_GAME_TYPE,
  tokenAddress: Address,
  affiliate: Hex,
  casinoChainId: CasinoChainId,
): BetSwirlFunctionData<typeof casinoGameAbi, "getAffiliateHouseEdge", readonly [Hex, Hex]> {
  const casinoChain = casinoChainById[casinoChainId];

  const gameAddress = casinoChain.contracts.games[game]?.address;
  if (!gameAddress) {
    throw new ChainError(
      `Game ${game} not found for chain ${casinoChainId}`,
      ERROR_CODES.CHAIN.UNSUPPORTED_GAME,
    );
  }

  const abi = casinoGameAbi;
  const functionName = "getAffiliateHouseEdge" as const;
  const args = [affiliate, tokenAddress] as const;
  return {
    data: { to: gameAddress, abi, functionName, args },
    encodedData: encodeFunctionData({
      abi,
      functionName,
      args,
    }),
  };
}
</file>

<file path="packages/core/src/read/casino/wheel.ts">
import { type TransactionReceipt } from "viem";
import type { WheelPlacedBet } from "../../actions";
import { Wheel } from "../../entities";
import type { BetSwirlWallet } from "../../provider";
import { type CasinoWaitRollOptions, waitRolledBet } from "./game";
import type { WeightedGameConfiguration, WeightedGameRolledBet } from "./weightedGame";

export interface WheelRolledBet extends WeightedGameRolledBet {}
export async function waitWheelRolledBet(
  wallet: BetSwirlWallet,
  placedBet: WheelPlacedBet,
  weightedGameConfig: WeightedGameConfiguration,
  houseEdge: number,
  options?: CasinoWaitRollOptions,
): Promise<{
  rolledBet: WheelRolledBet;
  receipt: TransactionReceipt;
}> {
  const { rolledBet, receipt } = await waitRolledBet(
    wallet,
    placedBet,
    options,
    weightedGameConfig,
    houseEdge,
  );
  return {
    rolledBet: {
      ...rolledBet,
      rolled: rolledBet.encodedRolled.map((rolledBet) =>
        Wheel.decodeRolled(rolledBet, weightedGameConfig, houseEdge),
      ),
    },
    receipt,
  };
}
</file>

<file path="packages/core/src/utils/index.ts">
import type { Address, Hash } from "viem";
import { BETSWIRL_BASE_URL } from "../constants";
import { CASINO_GAME_TYPE, type ChainId, chainById, slugById } from "../data";

export * from "./chains";
export * from "./tokens";
export * from "./bet";
export * from "./format";
export * from "./wallet";

export function bigIntFormatter(_key: string | number, value: any) {
  if (typeof value === "bigint") {
    return value.toString();
  }
  return value;
}

export function truncate(fullStr: string, strLen: number, separator = "...") {
  if (fullStr.length <= strLen) return fullStr;

  const frontChars = Math.ceil(strLen / 2);
  const backChars = Math.floor(strLen / 2);

  return fullStr.slice(0, frontChars) + separator + fullStr.slice(fullStr.length - backChars);
}

export function formatAccountUrl(account: Address, chainId: ChainId) {
  const chain = chainById[chainId];
  return `${chain.blockExplorers?.default.url}/address/${account}`;
}

export function formatTxnUrl(tx: Hash, chainId: ChainId) {
  const chain = chainById[chainId];
  return `${chain.blockExplorers?.default.url}/tx/${tx}`;
}

export function getBetSwirlBetUrl(
  betId: bigint | string,
  game: CASINO_GAME_TYPE,
  chainId: ChainId,
) {
  return `${BETSWIRL_BASE_URL}/${slugById[chainId]}/casino/${game}/${betId.toString()}`;
}

export function generateRandomHexColor(): string {
  const randomRGBValue = () =>
    Math.floor(Math.random() * 256)
      .toString(16)
      .padStart(2, "0");
  return `#${randomRGBValue()}${randomRGBValue()}${randomRGBValue()}`;
}
</file>

<file path="packages/providers/wagmi/src/wallet.ts">
import {
  type BetSwirlEventData,
  type BetSwirlFunctionData,
  BetSwirlWallet,
  wrappedGasTokenById,
} from "@betswirl/sdk-core";
import {
  type Config as WagmiConfig,
  call,
  getPublicClient,
  getTransactionReceipt,
  readContract,
  readContracts,
  simulateContract,
  waitForTransactionReceipt,
  watchContractEvent,
  writeContract,
} from "@wagmi/core";
import type { Abi, CallReturnType, Hash, PublicClient, TransactionReceipt } from "viem";

export class WagmiBetSwirlWallet extends BetSwirlWallet {
  private wagmiConfig: WagmiConfig;

  constructor(wagmiConfig: WagmiConfig) {
    super();
    this.wagmiConfig = wagmiConfig;
  }

  getChainId() {
    return this.wagmiConfig.state.chainId;
  }

  // Wagmi currently does not support hosting Private Key & Mnemonic Accounts to the top-level Wagmi Config – meaning we have to explicitly pass through the account to every Action
  // If at least one connector exists, then do not return an account
  getAccount(chainId?: number) {
    if (this.wagmiConfig.connectors.length > 0) return undefined;
    return this.wagmiConfig.getClient({ chainId }).account;
  }

  getPublicClient(chainId?: number) {
    return getPublicClient(this.wagmiConfig, { chainId }) as PublicClient;
  }

  async readContract<TFunctionData extends BetSwirlFunctionData<Abi, string, readonly any[]>>(
    functionData: TFunctionData,
    gasPrice: bigint,
  ): Promise<CallReturnType>;

  async readContract<
    TFunctionData extends BetSwirlFunctionData<Abi, string, readonly any[]>,
    TReturnType = any,
  >(functionData: TFunctionData, gasPrice?: undefined): Promise<TReturnType>;

  override async readContract<
    TFunctionData extends BetSwirlFunctionData<Abi, string, readonly any[]>,
    TReturnType = any,
  >(functionData: TFunctionData, gasPrice?: bigint): Promise<CallReturnType | TReturnType> {
    if (gasPrice && typeof gasPrice === "bigint") {
      return call(this.wagmiConfig, {
        to: functionData.data.to,
        data: functionData.encodedData,
        gasPrice,
        gas: 3000000n, // workaround to avoid not enough gas issue
        account: wrappedGasTokenById[this.getChainId()], // workaround to avoid not enough gas issue
      }) as Promise<CallReturnType>;
    }
    return readContract(this.wagmiConfig, {
      address: functionData.data.to,
      abi: functionData.data.abi,
      functionName: functionData.data.functionName,
      args: functionData.data.args,
    }) as Promise<TReturnType>;
  }

  async readContracts<
    TFunctionDatas extends BetSwirlFunctionData<Abi, string, readonly any[]>[],
    TReturnTypes extends any[],
  >(functionDatas: [...TFunctionDatas]): Promise<TReturnTypes> {
    const contracts = functionDatas.map((functionData) => ({
      address: functionData.data.to,
      abi: functionData.data.abi,
      functionName: functionData.data.functionName,
      args: functionData.data.args,
    }));

    const states = await readContracts(this.wagmiConfig, {
      contracts,
    });

    if (states.some((state) => state.status === "failure" || state === undefined)) {
      throw new Error("[wagmiWallet] An error occured while reading contracts");
    }

    return states.map((state) => state.result) as TReturnTypes;
  }

  async getTransactionReceipt(txHash: Hash): Promise<TransactionReceipt> {
    return getTransactionReceipt(this.wagmiConfig, { hash: txHash });
  }

  watchContractEvent<TEventData extends BetSwirlEventData<Abi, string, any>>(
    eventData: TEventData,
  ): () => void {
    return watchContractEvent(this.wagmiConfig, {
      address: eventData.data.to,
      abi: eventData.data.abi,
      eventName: eventData.data.eventName,
      args: eventData.data.args,
      pollingInterval: eventData.data.pollingInterval,
      onLogs: (logs) => eventData.callbacks.onLogs?.(logs),
      onError: (error) => eventData.callbacks.onError?.(error),
    });
  }

  async writeContract<TFunctionData extends BetSwirlFunctionData<Abi, string, readonly any[]>>(
    functionData: TFunctionData,
    value?: bigint,
    gasPrice?: bigint,
  ): Promise<Hash> {
    const { request } = await simulateContract(this.wagmiConfig, {
      address: functionData.data.to,
      abi: functionData.data.abi,
      functionName: functionData.data.functionName,
      args: functionData.data.args,
      gasPrice,
      account: this.getAccount(),
      value,
    });
    return await writeContract(this.wagmiConfig, request);
  }

  async waitTransaction(txHash: Hash, pollingInterval?: number): Promise<TransactionReceipt> {
    return await waitForTransactionReceipt(this.wagmiConfig, { hash: txHash, pollingInterval });
  }
}
</file>

<file path="packages/providers/wagmi/tsconfig.build.json">
{
  "extends": "../../../tsconfig.base.json",
  "include": ["src/**/*.ts"],
  "exclude": ["src/**/*.test.ts", "src/**/*.test-d.ts"],
  "compilerOptions": {
    "sourceMap": true, 
    "paths": { 
      "@betswirl/sdk-core": ["./node_modules/@chainhackers/sdk-core"]
    }
  }
}
</file>

<file path="packages/providers/wagmi/tsup.config.ts">
import { defineConfig } from "tsup";

declare const process: {
  env: {
    NODE_ENV: string;
  };
};

export default defineConfig({
  entry: ["src/index.ts"],
  format: ["esm", "cjs"],
  dts: {
    compilerOptions: {
      incremental: false,
      noUnusedLocals: false,
    },
  },
  splitting: true,
  clean: true,
  shims: true,
  outDir: "dist",
  minify: process.env.NODE_ENV === "production",
  sourcemap: true,
  bundle: true,
  outExtension: ({ format }) => ({
    js: format === "esm" ? ".mjs" : ".cjs",
  }),
  treeshake: true,
  esbuildOptions(options) {
    options.alias = {
      "@betswirl/sdk-core": "@chainhackers/sdk-core",
    };
  },
});
</file>

<file path=".gitignore">
.DS_Store
.next
.nuxt
.pnpm-debug.log*
cache
coverage
dist
node_modules
tsconfig.tsbuildinfo
*.vitest-temp.json
.turbo

# local env files
.env
.env.local
.env.development.local
.env.test.local
.env.production.local
.envrc
**/test**

# subgraph type generation
**/subgraphs/**/documents/**/*.ts
.npmrc
</file>

<file path=".husky/pre-commit">
#!/bin/sh

echo "Running pre-commit checks..."

echo "Running linter and fixing issues..."
# Run linter and fix issues
pnpm lint:fix 

# Add files modified by the linter
git add .

echo "Building the project..."
# Build the project
pnpm build

echo "Pre-commit checks completed." 

# Exit with an error if any of the above commands fail
if [ $? -ne 0 ]; then
    echo "Pre-commit checks failed."
    exit 1
fi
</file>

<file path="examples/mini-app/.storybook/main.ts">
import type { StorybookConfig } from "@storybook/react-vite"

const config: StorybookConfig = {
  stories: ["../src/**/*.mdx", "../src/**/*.stories.@(js|jsx|mjs|ts|tsx)"],
  addons: [
    "@storybook/addon-essentials",
    "@storybook/addon-onboarding",
    "@chromatic-com/storybook",
    "@storybook/experimental-addon-test",
  ],
  framework: {
    name: "@storybook/react-vite",
    options: {},
  },
}
export default config
</file>

<file path="examples/mini-app/.storybook/preview.tsx">
import React from "react"
import type { Preview, Decorator } from "@storybook/react"
import "../src/index.css"

const withAppProviders: Decorator = (StoryComponent) => {
  return <StoryComponent />
}

const preview: Preview = {
  parameters: {
    controls: {
      matchers: {
        color: /(background|color)$/i,
        date: /Date$/i,
      },
    },
  },
  decorators: [withAppProviders],
}

export default preview
</file>

<file path="examples/mini-app/.storybook/vitest.setup.ts">
import { setProjectAnnotations } from "@storybook/react"
import { beforeAll } from "vitest"
import * as projectAnnotations from "./preview"

// This is an important step to apply the right configuration when testing your stories.
// More info at: https://storybook.js.org/docs/api/portable-stories/portable-stories-vitest#setprojectannotations
const project = setProjectAnnotations([projectAnnotations])

beforeAll(project.beforeAll)
</file>

<file path="examples/mini-app/src/components/ui/button.stories.tsx">
import type { Meta, StoryObj } from "@storybook/react"
import { Info } from "lucide-react"
import { Button } from "./button"

const meta = {
  title: "UI/Button",
  component: Button,
  parameters: {
    layout: "centered",
  },
  tags: ["autodocs"],
  argTypes: {
    variant: {
      control: "select",
      options: [
        "default",
        "destructive",
        "outline",
        "secondary",
        "ghost",
        "link",
        "iconRound",
        "iconTransparent",
      ],
    },
    size: {
      control: "select",
      options: ["default", "sm", "lg", "icon", "iconRound"],
    },
    disabled: { control: "boolean" },
  },
  args: {
    variant: "default",
    size: "default",
    disabled: false,
    children: "Button Text",
  },
} satisfies Meta<typeof Button>

export default meta
type Story = StoryObj<typeof meta>

export const Default: Story = {
  args: {
    variant: "default",
    children: "Default Button",
  },
}

export const Secondary: Story = {
  args: {
    variant: "secondary",
    children: "Secondary Button",
  },
}

export const Destructive: Story = {
  args: {
    variant: "destructive",
    children: "Destructive Button",
  },
}

export const Outline: Story = {
  args: {
    variant: "outline",
    children: "Outline Button",
  },
}

export const Ghost: Story = {
  args: {
    variant: "ghost",
    children: "Ghost Button",
  },
}

export const Link: Story = {
  args: {
    variant: "link",
    children: "Link Button",
  },
}

export const Icon: Story = {
  args: {
    variant: "outline",
    size: "icon",
    children: <Info className="h-4 w-4" />,
  },
}

export const IconRound: Story = {
  args: {
    variant: "iconRound",
    size: "iconRound",
    children: <Info className="h-4 w-4" />,
  },
}

export const IconTransparent: Story = {
  args: {
    variant: "iconTransparent",
    size: "iconRound",
    children: <Info className="h-4 w-4" />,
  },
}

export const Disabled: Story = {
  args: {
    disabled: true,
    children: "Disabled Button",
  },
}
</file>

<file path="examples/mini-app/src/components/ui/card.stories.tsx">
import type { Meta, StoryObj } from "@storybook/react"
import { BellRing, Check } from "lucide-react"
import { Button } from "./button"
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "./card"

const meta = {
  title: "UI/Card",
  component: Card,
  parameters: {
    layout: "centered",
  },
  tags: ["autodocs"],
} satisfies Meta<typeof Card>

export default meta
type Story = StoryObj<typeof meta>

export const Default: Story = {
  render: (args) => (
    <Card {...args} className="w-[380px]">
      <CardHeader>
        <CardTitle>Card Title</CardTitle>
        <CardDescription>Card Description</CardDescription>
      </CardHeader>
      <CardContent>
        <p>Card Content</p>
      </CardContent>
      <CardFooter>
        <p>Card Footer</p>
      </CardFooter>
    </Card>
  ),
}

export const ExampleWithContent: Story = {
  render: (args) => (
    <Card {...args} className="w-[380px]">
      <CardHeader>
        <CardTitle>Notifications</CardTitle>
        <CardDescription>You have 3 unread messages.</CardDescription>
      </CardHeader>
      <CardContent className="grid gap-4">
        <div className=" flex items-center space-x-4 rounded-md border p-4">
          <BellRing />
          <div className="flex-1 space-y-1">
            <p className="text-sm font-medium leading-none">
              Push Notifications
            </p>
            <p className="text-sm text-muted-foreground">
              Send notifications to device.
            </p>
          </div>
        </div>
      </CardContent>
      <CardFooter>
        <Button className="w-full">
          <Check className="mr-2 h-4 w-4" /> Mark all as read
        </Button>
      </CardFooter>
    </Card>
  ),
}
</file>

<file path="examples/mini-app/src/components/ui/slider.stories.tsx">
import type { Meta, StoryObj } from "@storybook/react"
import { useState } from "react"
import { Slider } from "./slider"

const meta = {
  title: "UI/Slider",
  component: Slider,
  parameters: {
    layout: "centered",
    backgrounds: {
      default: "dark",
      values: [{ name: "dark", value: "oklch(0.15 0 0)" }],
    },
  },
  tags: ["autodocs"],
  argTypes: {
    disabled: { control: "boolean" },
    min: { control: "number" },
    max: { control: "number" },
    step: { control: "number" },
    value: { control: "object" },
    defaultValue: { control: "object" },
    className: { control: "text" },
  },
  args: {
    min: 0,
    max: 100,
    step: 1,
    disabled: false,
    className: "w-60",
  },
} satisfies Meta<typeof Slider>

export default meta
type Story = StoryObj<typeof meta>

function SliderWithState({
  defaultValue,
  ...args
}: React.ComponentProps<typeof Slider>) {
  const [value, setValue] = useState(defaultValue || [50])

  return (
    <div className="w-80 p-4">
      <Slider {...args} value={value} onValueChange={setValue} />
      <div className="mt-2 text-center text-sm">Value: {value.join(", ")}</div>
    </div>
  )
}

export const Default: Story = {
  render: (args) => <SliderWithState {...args} />,
  args: {
    defaultValue: [25],
  },
}

export const GreenAccent: Story = {
  render: (args) => <SliderWithState {...args} />,
  args: {
    defaultValue: [25],
    max: 99,
  },
}

export const Range: Story = {
  render: (args) => <SliderWithState {...args} />,
  args: {
    defaultValue: [25, 75],
  },
}

export const Disabled: Story = {
  render: (args) => {
    return (
      <div className="w-80 p-4">
        <Slider {...args} />
        <div className="mt-2 text-center text-sm text-muted-foreground">
          Value: {args.value?.join(", ")} (disabled)
        </div>
      </div>
    )
  },
  args: {
    value: [60],
    disabled: true,
  },
}
</file>

<file path="examples/mini-app/src/components/ui/slider.tsx">
import * as SliderPrimitive from "@radix-ui/react-slider"
import * as React from "react"

import { cn } from "../../lib/utils"

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className,
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2.5 w-full grow overflow-hidden rounded-full bg-green-500">
      <SliderPrimitive.Range className="absolute h-full bg-red-500" />
    </SliderPrimitive.Track>
    {(props.value ?? props.defaultValue ?? []).map((_, index) => (
      <SliderPrimitive.Thumb
        key={index}
        className={cn(
          "block h-5 w-5 rounded-full border-0",
          "bg-green-500",
          "ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
          "disabled:pointer-events-none disabled:opacity-50",
          "shadow-[0_2px_4px_rgba(0,0,0,0.5)]",
        )}
      />
    ))}
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }
</file>

<file path="examples/mini-app/src/components/ui/table.tsx">
import * as React from "react"

import { cn } from "../../lib/utils"

function Table({ className, ...props }: React.ComponentProps<"table">) {
  return (
    <div
      data-slot="table-container"
      className="relative w-full overflow-x-auto"
    >
      <table
        data-slot="table"
        className={cn("w-full caption-bottom text-sm", className)}
        {...props}
      />
    </div>
  )
}

function TableHeader({ className, ...props }: React.ComponentProps<"thead">) {
  return (
    <thead
      data-slot="table-header"
      className={cn("[&_tr]:border-b", className)}
      {...props}
    />
  )
}

function TableBody({ className, ...props }: React.ComponentProps<"tbody">) {
  return (
    <tbody
      data-slot="table-body"
      className={cn("[&_tr:last-child]:border-0", className)}
      {...props}
    />
  )
}

function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn(
        "bg-muted/50 border-t font-medium [&>tr]:last:border-b-0",
        className,
      )}
      {...props}
    />
  )
}

function TableRow({ className, ...props }: React.ComponentProps<"tr">) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
        className,
      )}
      {...props}
    />
  )
}

function TableHead({ className, ...props }: React.ComponentProps<"th">) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        "text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className,
      )}
      {...props}
    />
  )
}

function TableCell({ className, ...props }: React.ComponentProps<"td">) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className,
      )}
      {...props}
    />
  )
}

function TableCaption({
  className,
  ...props
}: React.ComponentProps<"caption">) {
  return (
    <caption
      data-slot="table-caption"
      className={cn("text-muted-foreground mt-4 text-sm", className)}
      {...props}
    />
  )
}

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
</file>

<file path="examples/mini-app/src/lib/utils.ts">
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="examples/mini-app/src/stories/Configure.mdx">
import { Meta } from "@storybook/blocks"

import Github from "./assets/github.svg"
import Discord from "./assets/discord.svg"
import Youtube from "./assets/youtube.svg"
import Tutorials from "./assets/tutorials.svg"
import Styling from "./assets/styling.png"
import Context from "./assets/context.png"
import Assets from "./assets/assets.png"
import Docs from "./assets/docs.png"
import Share from "./assets/share.png"
import FigmaPlugin from "./assets/figma-plugin.png"
import Testing from "./assets/example-testing.png"
import Accessibility from "./assets/accessibility.png"
import Theming from "./assets/theming.png"
import AddonLibrary from "./assets/addon-library.png"

export const RightArrow = () => (
  <svg
    viewBox="0 0 14 14"
    width="8px"
    height="14px"
    style={{
      marginLeft: "4px",
      display: "inline-block",
      shapeRendering: "inherit",
      verticalAlign: "middle",
      fill: "currentColor",
      "path fill": "currentColor",
    }}
  >
    <path d="m11.1 7.35-5.5 5.5a.5.5 0 0 1-.7-.7L10.04 7 4.9 1.85a.5.5 0 1 1 .7-.7l5.5 5.5c.2.2.2.5 0 .7Z" />
  </svg>
)

<Meta title="Configure your project" />

<div className="sb-container">
  <div className='sb-section-title'>
    # Configure your project

    Because Storybook works separately from your app, you'll need to configure it for your specific stack and setup. Below, explore guides for configuring Storybook with popular frameworks and tools. If you get stuck, learn how you can ask for help from our community.

  </div>
  <div className="sb-section">
    <div className="sb-section-item">
      <img
        src={Styling}
        alt="A wall of logos representing different styling technologies"
      />
      <h4 className="sb-section-item-heading">Add styling and CSS</h4>
      <p className="sb-section-item-paragraph">Like with web applications, there are many ways to include CSS within Storybook. Learn more about setting up styling within Storybook.</p>
      <a
        href="https://storybook.js.org/docs/configure/styling-and-css/?renderer=react"
        target="_blank"
      >Learn more<RightArrow /></a>
    </div>
    <div className="sb-section-item">
      <img
        src={Context}
        alt="An abstraction representing the composition of data for a component"
      />
      <h4 className="sb-section-item-heading">Provide context and mocking</h4>
      <p className="sb-section-item-paragraph">Often when a story doesn't render, it's because your component is expecting a specific environment or context (like a theme provider) to be available.</p>
      <a
        href="https://storybook.js.org/docs/writing-stories/decorators/?renderer=react#context-for-mocking"
        target="_blank"
      >Learn more<RightArrow /></a>
    </div>
    <div className="sb-section-item">
      <img src={Assets} alt="A representation of typography and image assets" />
      <div>
        <h4 className="sb-section-item-heading">Load assets and resources</h4>
        <p className="sb-section-item-paragraph">To link static files (like fonts) to your projects and stories, use the
        `staticDirs` configuration option to specify folders to load when
        starting Storybook.</p>
        <a
          href="https://storybook.js.org/docs/configure/images-and-assets/?renderer=react"
          target="_blank"
        >Learn more<RightArrow /></a>
      </div>
    </div>
  </div>
</div>
<div className="sb-container">
  <div className='sb-section-title'>
    # Do more with Storybook

    Now that you know the basics, let's explore other parts of Storybook that will improve your experience. This list is just to get you started. You can customise Storybook in many ways to fit your needs.

  </div>

  <div className="sb-section">
    <div className="sb-features-grid">
      <div className="sb-grid-item">
        <img src={Docs} alt="A screenshot showing the autodocs tag being set, pointing a docs page being generated" />
        <h4 className="sb-section-item-heading">Autodocs</h4>
        <p className="sb-section-item-paragraph">Auto-generate living,
          interactive reference documentation from your components and stories.</p>
        <a
          href="https://storybook.js.org/docs/writing-docs/autodocs/?renderer=react"
          target="_blank"
        >Learn more<RightArrow /></a>
      </div>
      <div className="sb-grid-item">
        <img src={Share} alt="A browser window showing a Storybook being published to a chromatic.com URL" />
        <h4 className="sb-section-item-heading">Publish to Chromatic</h4>
        <p className="sb-section-item-paragraph">Publish your Storybook to review and collaborate with your entire team.</p>
        <a
          href="https://storybook.js.org/docs/sharing/publish-storybook/?renderer=react#publish-storybook-with-chromatic"
          target="_blank"
        >Learn more<RightArrow /></a>
      </div>
      <div className="sb-grid-item">
        <img src={FigmaPlugin} alt="Windows showing the Storybook plugin in Figma" />
        <h4 className="sb-section-item-heading">Figma Plugin</h4>
        <p className="sb-section-item-paragraph">Embed your stories into Figma to cross-reference the design and live
          implementation in one place.</p>
        <a
          href="https://storybook.js.org/docs/sharing/design-integrations/?renderer=react#embed-storybook-in-figma-with-the-plugin"
          target="_blank"
        >Learn more<RightArrow /></a>
      </div>
      <div className="sb-grid-item">
        <img src={Testing} alt="Screenshot of tests passing and failing" />
        <h4 className="sb-section-item-heading">Testing</h4>
        <p className="sb-section-item-paragraph">Use stories to test a component in all its variations, no matter how
          complex.</p>
        <a
          href="https://storybook.js.org/docs/writing-tests/?renderer=react"
          target="_blank"
        >Learn more<RightArrow /></a>
      </div>
      <div className="sb-grid-item">
        <img src={Accessibility} alt="Screenshot of accessibility tests passing and failing" />
        <h4 className="sb-section-item-heading">Accessibility</h4>
        <p className="sb-section-item-paragraph">Automatically test your components for a11y issues as you develop.</p>
        <a
          href="https://storybook.js.org/docs/writing-tests/accessibility-testing/?renderer=react"
          target="_blank"
        >Learn more<RightArrow /></a>
      </div>
      <div className="sb-grid-item">
        <img src={Theming} alt="Screenshot of Storybook in light and dark mode" />
        <h4 className="sb-section-item-heading">Theming</h4>
        <p className="sb-section-item-paragraph">Theme Storybook's UI to personalize it to your project.</p>
        <a
          href="https://storybook.js.org/docs/configure/theming/?renderer=react"
          target="_blank"
        >Learn more<RightArrow /></a>
      </div>
    </div>
  </div>
</div>
<div className='sb-addon'>
  <div className='sb-addon-text'>
    <h4>Addons</h4>
    <p className="sb-section-item-paragraph">Integrate your tools with Storybook to connect workflows.</p>
    <a
        href="https://storybook.js.org/addons/"
        target="_blank"
      >Discover all addons<RightArrow /></a>
  </div>
  <div className='sb-addon-img'>
    <img src={AddonLibrary} alt="Integrate your tools with Storybook to connect workflows." />
  </div>
</div>

<div className="sb-section sb-socials">
    <div className="sb-section-item">
      <img src={Github} alt="Github logo" className="sb-explore-image"/>
      Join our contributors building the future of UI development.

      <a
        href="https://github.com/storybookjs/storybook"
        target="_blank"
      >Star on GitHub<RightArrow /></a>
    </div>
    <div className="sb-section-item">
      <img src={Discord} alt="Discord logo" className="sb-explore-image"/>
      <div>
        Get support and chat with frontend developers.

        <a
          href="https://discord.gg/storybook"
          target="_blank"
        >Join Discord server<RightArrow /></a>
      </div>
    </div>
    <div className="sb-section-item">
      <img src={Youtube} alt="Youtube logo" className="sb-explore-image"/>
      <div>
        Watch tutorials, feature previews and interviews.

        <a
          href="https://www.youtube.com/@chromaticui"
          target="_blank"
        >Watch on YouTube<RightArrow /></a>
      </div>
    </div>
    <div className="sb-section-item">
      <img src={Tutorials} alt="A book" className="sb-explore-image"/>
      <p>Follow guided walkthroughs on for key workflows.</p>

      <a
          href="https://storybook.js.org/tutorials/"
          target="_blank"
        >Discover tutorials<RightArrow /></a>
    </div>

</div>

<style>
  {`
  .sb-container {
    margin-bottom: 48px;
  }

  .sb-section {
    width: 100%;
    display: flex;
    flex-direction: row;
    gap: 20px;
  }

  img {
    object-fit: cover;
  }

  .sb-section-title {
    margin-bottom: 32px;
  }

  .sb-section a:not(h1 a, h2 a, h3 a) {
    font-size: 14px;
  }

  .sb-section-item, .sb-grid-item {
    flex: 1;
    display: flex;
    flex-direction: column;
  }

  .sb-section-item-heading {
    padding-top: 20px !important;
    padding-bottom: 5px !important;
    margin: 0 !important;
  }
  .sb-section-item-paragraph {
    margin: 0;
    padding-bottom: 10px;
  }

  .sb-chevron {
    margin-left: 5px;
  }

  .sb-features-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    grid-gap: 32px 20px;
  }

  .sb-socials {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
  }

  .sb-socials p {
    margin-bottom: 10px;
  }

  .sb-explore-image {
    max-height: 32px;
    align-self: flex-start;
  }

  .sb-addon {
    width: 100%;
    display: flex;
    align-items: center;
    position: relative;
    background-color: #EEF3F8;
    border-radius: 5px;
    border: 1px solid rgba(0, 0, 0, 0.05);
    background: #EEF3F8;
    height: 180px;
    margin-bottom: 48px;
    overflow: hidden;
  }

  .sb-addon-text {
    padding-left: 48px;
    max-width: 240px;
  }

  .sb-addon-text h4 {
    padding-top: 0px;
  }

  .sb-addon-img {
    position: absolute;
    left: 345px;
    top: 0;
    height: 100%;
    width: 200%;
    overflow: hidden;
  }

  .sb-addon-img img {
    width: 650px;
    transform: rotate(-15deg);
    margin-left: 40px;
    margin-top: -72px;
    box-shadow: 0 0 1px rgba(255, 255, 255, 0);
    backface-visibility: hidden;
  }

  @media screen and (max-width: 800px) {
    .sb-addon-img {
      left: 300px;
    }
  }

  @media screen and (max-width: 600px) {
    .sb-section {
      flex-direction: column;
    }

    .sb-features-grid {
      grid-template-columns: repeat(1, 1fr);
    }

    .sb-socials {
      grid-template-columns: repeat(2, 1fr);
    }

    .sb-addon {
      height: 280px;
      align-items: flex-start;
      padding-top: 32px;
      overflow: hidden;
    }

    .sb-addon-text {
      padding-left: 24px;
    }

    .sb-addon-img {
      right: 0;
      left: 0;
      top: 130px;
      bottom: 0;
      overflow: hidden;
      height: auto;
      width: 124%;
    }

    .sb-addon-img img {
      width: 1200px;
      transform: rotate(-12deg);
      margin-left: 0;
      margin-top: 48px;
      margin-bottom: -40px;
      margin-left: -24px;
    }
  }
  `}
</style>
</file>

<file path="examples/mini-app/src/index.ts">
export * from "./hooks/usePlaceBet";
export * from "./components/game/CoinTossGame";
export * from "./components/game/HistorySheetPanel";
export * from "./components/game/InfoSheetPanel";
export * from "./components/game/GameResultWindow";
</file>

<file path="examples/mini-app/.gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

*storybook.log
storybook-static

# Environment files
.env
.env.*
!/.env.example
</file>

<file path="examples/mini-app/eslint.config.js">
import js from "@eslint/js"
import reactHooks from "eslint-plugin-react-hooks"
import reactRefresh from "eslint-plugin-react-refresh"
import globals from "globals"
import tseslint from "typescript-eslint"

export default tseslint.config(
  { ignores: ["dist"] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ["**/*.{ts,tsx}"],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      "react-hooks": reactHooks,
      "react-refresh": reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      "react-refresh/only-export-components": [
        "warn",
        { allowConstantExport: true },
      ],
    },
  },
)
</file>

<file path="examples/mini-app/vite.config.ts">
import path from "path"
import tailwindcss from "@tailwindcss/vite"
import react from "@vitejs/plugin-react"
import { defineConfig } from "vite"

// https://vite.dev/config/
export default defineConfig({
  plugins: [react(), tailwindcss()],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
})
</file>

<file path="examples/mini-app/vitest.workspace.ts">
import path from "node:path"
import { fileURLToPath } from "node:url"

import { defineWorkspace } from "vitest/config"

import { storybookTest } from "@storybook/experimental-addon-test/vitest-plugin"

const dirname =
  typeof __dirname !== "undefined"
    ? __dirname
    : path.dirname(fileURLToPath(import.meta.url))

// More info at: https://storybook.js.org/docs/writing-tests/test-addon
export default defineWorkspace([
  "vite.config.ts",
  {
    extends: "vite.config.ts",
    plugins: [
      // The plugin will run tests for the stories defined in your Storybook config
      // See options at: https://storybook.js.org/docs/writing-tests/test-addon#storybooktest
      storybookTest({ configDir: path.join(dirname, ".storybook") }),
    ],
    test: {
      name: "storybook",
      browser: {
        enabled: true,
        headless: true,
        name: "chromium",
        provider: "playwright",
      },
      setupFiles: [".storybook/vitest.setup.ts"],
    },
  },
])
</file>

<file path="examples/node/src/functionalities/showHistoryBets.ts">
import { InMemoryCache } from "@apollo/client/core/index.js";
import {
  BetSwirlError,
  Bet_OrderBy,
  type CasinoBet,
  type CasinoChain,
  FORMAT_TYPE,
  OrderDirection,
  WEIGHTED_CASINO_GAME_TYPES,
  WeightedGame,
  bigIntFormatter,
  casinoChains,
  formatTxnUrl,
  getBetSwirlBetUrl,
  labelCasinoGameByType,
} from "@betswirl/sdk-core";
import { WagmiBetSwirlClient, initWagmiBetSwirlClient } from "@betswirl/wagmi-provider";
import { select } from "@inquirer/prompts";
import chalk from "chalk";
import type { Hex } from "viem/_types/types/misc";
import { checkEnvVariables, getWagmiConfigFromCasinoChain } from "../../utils";

let wagmiBetSwirlClient: WagmiBetSwirlClient;

export async function startShowHistoryBetsProcess() {
  try {
    // 0. Check if env variables are set
    checkEnvVariables();
    // 1. Select chain
    const selectedChain = await _selectChain();

    // 2. Fetch the last 10 bets placed by the connected user
    const bets = await _getLastBets(10, selectedChain);

    // 3. Show the bets

    await _showBets(bets);
  } catch (error) {
    if (error instanceof BetSwirlError) {
      console.error(
        chalk.red(
          `[${error.code}] BetSwirl error occured while showing bets history: ${
            error.message
          } ${JSON.stringify(error.context, bigIntFormatter)}`,
        ),
      );
    } else {
      console.error(chalk.red("Node example error occured:", error));
    }
  }
}

async function _selectChain(): Promise<CasinoChain> {
  const selectedChain = await select({
    message: "Select a chain on which to bet",
    loop: false,
    choices: casinoChains.map((c) => ({ name: c.viemChain.name, value: c })),
  });
  const wagmiConfig = getWagmiConfigFromCasinoChain(selectedChain);
  wagmiBetSwirlClient = initWagmiBetSwirlClient(wagmiConfig, {
    chainId: selectedChain.id,
    affiliate: process.env.AFFILIATE_ADDRESS as Hex,
    formatType: FORMAT_TYPE.PRECISE,
    subgraphClient: {
      graphqlKey: process.env.GRAPHQL_KEY as string,
      cache: new InMemoryCache(),
    },
  });
  return selectedChain;
}

async function _getLastBets(count: number, casinoChain: CasinoChain): Promise<CasinoBet[]> {
  const { bets, error } = await wagmiBetSwirlClient.fetchBets(
    casinoChain.id,
    {
      bettor: wagmiBetSwirlClient.betSwirlWallet.getAccount()?.address,
    },
    1,
    count,
    { key: Bet_OrderBy.BetTimestamp, order: OrderDirection.Desc },
  );

  if (error) throw error;
  return bets;
}

function _showBets(bets: CasinoBet[]) {
  // User has placed bets
  if (bets.length) {
    console.log(`==== Your last ${bets.length} bets ====\n`);
    for (const bet of bets) {
      _showBet(bet);
    }
  }
  // User has never placed any bets
  else {
    console.log(chalk.yellow("You have never placed any bets with this account"));
  }
}

function _showBet(bet: CasinoBet) {
  // Id
  console.log(chalk.bold(`=== ID ${bet.id.toString()} ===`));
  // Common place bet info
  // TODO replace "Input" and "Rolled" by the game input/output labels
  const placeBetInfo = `Game: ${labelCasinoGameByType[bet.game]}\nInput: ${
    WEIGHTED_CASINO_GAME_TYPES.includes(bet.game)
      ? WeightedGame.getWeightedGameConfigLabel(bet.decodedInput, bet.chainId)
      : bet.decodedInput
  }\nBet amount: ${bet.formattedBetAmount} ${bet.token.symbol}\nBet count: ${bet.betCount}\n${
    bet.betCount > 1 ? `Total bet amount ${bet.formattedTotalBetAmount} ${bet.token.symbol}\n` : ""
  }Bet date: ${bet.betDate.toLocaleString()}\nBet txn: ${formatTxnUrl(bet.betTxnHash, bet.chainId)}\n`;
  // Pending state
  if (!bet.isResolved) {
    console.log("Status:", chalk.yellow("Pending"));
    console.log(placeBetInfo);
  } else {
    // Refunded state
    if (bet.isRefunded) {
      console.log("Status:", chalk.gray("Refunded"));
      console.log(placeBetInfo);
    } else {
      const benefitInfo = `${bet.formattedBenefit} ${bet.token.symbol}`;
      const rollBetInfo = `Payout: ${bet.formattedPayout} ${
        bet.token.symbol
      }\nMultiplier: x${bet.formattedPayoutMultiplier}\nResult: ${
        bet.isWin ? chalk.green(`+${benefitInfo}`) : chalk.red(benefitInfo)
      }\nRolled: ${bet.decodedRolled}\nRoll date: ${bet.rollDate?.toLocaleString()}\nRoll txn: ${formatTxnUrl(
        bet.rollTxnHash!,
        bet.chainId,
      )}\nBetSwirl url: ${getBetSwirlBetUrl(bet.id, bet.game, bet.chainId)}\n${
        bet.isStopGainTriggered || bet.isStopLossTriggered
          ? chalk.yellow(
              `\n=> Only ${bet.rollBetCount}/${bet.betCount} have been rolled because stop ${
                bet.isStopGainTriggered ? "gain" : "loss"
              } has been triggered`,
            )
          : ""
      }`;
      // Won state
      if (bet.isWin) {
        console.log("Status:", chalk.green("Won"));
        console.log(placeBetInfo);
        console.log(rollBetInfo);
      }
      // Lost state
      else {
        console.log("Status:", chalk.red("Lost"));
        console.log(placeBetInfo);
        console.log(rollBetInfo);
      }
    }
  }
}
</file>

<file path="packages/core/src/abis/v2/index.ts">
export * from "./casino/bank";
export * from "./casino/cointoss";
export * from "./casino/dice";
export * from "./casino/roulette";
export * from "./casino/keno";
export * from "./casino/game";
export * from "./casino/weightedGame";
</file>

<file path="packages/core/src/actions/casino/cointoss.ts">
import { type TransactionReceipt, decodeEventLog } from "viem";
import { coinTossAbi } from "../../abis/v2/casino/cointoss";
import { CASINO_GAME_TYPE, type CasinoChainId } from "../../data/casino";
import {
  type COINTOSS_FACE,
  CoinToss,
  type CoinTossEncodedInput,
} from "../../entities/casino/cointoss";
import { ERROR_CODES } from "../../errors/codes";
import { TransactionError } from "../../errors/types";
import type { Token } from "../../interfaces";
import type { BetSwirlWallet } from "../../provider";
import {
  type CasinoBetParams,
  type CasinoPlaceBetOptions,
  type NormalCasinoPlacedBet,
  type PlaceBetCallbacks,
  getPlacedBetFromReceipt,
  placeBet,
} from "./game";

export interface CoinTossParams extends CasinoBetParams {
  face: COINTOSS_FACE;
}

export interface CoinTossPlacedBet extends NormalCasinoPlacedBet {
  face: COINTOSS_FACE;
  encodedFace: CoinTossEncodedInput;
  game: CASINO_GAME_TYPE.COINTOSS;
}

export async function placeCoinTossBet(
  wallet: BetSwirlWallet,
  coinTossParams: CoinTossParams,
  options?: CasinoPlaceBetOptions,
  callbacks?: PlaceBetCallbacks,
): Promise<{ placedBet: CoinTossPlacedBet; receipt: TransactionReceipt }> {
  const { placedBet, receipt } = await placeBet(
    wallet,
    {
      game: CASINO_GAME_TYPE.COINTOSS,
      gameEncodedInput: CoinToss.encodeInput(coinTossParams.face),
      ...coinTossParams,
    },
    options,
    callbacks,
  );
  const coinTossPlacedBet = await getCoinTossPlacedBetFromReceipt(
    wallet,
    receipt,
    placedBet.chainId,
    placedBet.token,
  );
  if (!coinTossPlacedBet) {
    throw new TransactionError(
      "CoinToss PlaceBet event not found",
      ERROR_CODES.GAME.PLACE_BET_EVENT_NOT_FOUND,
      {
        hash: receipt.transactionHash,
        chainId: placedBet.chainId,
      },
    );
  }
  return { placedBet: coinTossPlacedBet, receipt };
}

export async function getCoinTossPlacedBetFromReceipt(
  wallet: BetSwirlWallet,
  receipt: TransactionReceipt,
  chainId: CasinoChainId,
  usedToken?: Token,
): Promise<CoinTossPlacedBet | null> {
  const gamePlacedBet = await getPlacedBetFromReceipt(
    wallet,
    receipt,
    CASINO_GAME_TYPE.COINTOSS,
    chainId,
    usedToken,
  );
  if (!gamePlacedBet) {
    return null;
  }

  // Read the CoinToss PlaceBet event from logs
  const decodedCoinTossPlaceBetEvent = receipt.logs
    .map((log) => {
      try {
        return decodeEventLog({
          abi: coinTossAbi,
          data: log.data,
          topics: log.topics,
        });
      } catch {
        return null;
      }
    })
    .find((log) => log?.eventName === "PlaceBet");

  if (!decodedCoinTossPlaceBetEvent) {
    return null;
  }

  const { args } = decodedCoinTossPlaceBetEvent;
  return {
    ...gamePlacedBet,
    game: CASINO_GAME_TYPE.COINTOSS,
    encodedFace: args.face,
    face: CoinToss.decodeInput(args.face),
  };
}
</file>

<file path="packages/core/src/actions/casino/dice.ts">
import { type TransactionReceipt, decodeEventLog } from "viem";
import { diceAbi } from "../../abis/v2/casino/dice";
import { CASINO_GAME_TYPE, type CasinoChainId } from "../../data/casino";
import { Dice, type DiceEncodedInput, type DiceNumber } from "../../entities/casino/dice";
import { ERROR_CODES } from "../../errors/codes";
import { TransactionError } from "../../errors/types";
import type { Token } from "../../interfaces";
import type { BetSwirlWallet } from "../../provider";
import {
  type CasinoBetParams,
  type CasinoPlaceBetOptions,
  type NormalCasinoPlacedBet,
  type PlaceBetCallbacks,
  getPlacedBetFromReceipt,
  placeBet,
} from "./game";

export interface DiceParams extends CasinoBetParams {
  cap: DiceNumber;
}

export interface DicePlacedBet extends NormalCasinoPlacedBet {
  cap: DiceNumber;
  encodedCap: DiceEncodedInput;
  game: CASINO_GAME_TYPE.DICE;
}

export async function placeDiceBet(
  wallet: BetSwirlWallet,
  diceParams: DiceParams,
  options?: CasinoPlaceBetOptions,
  callbacks?: PlaceBetCallbacks,
): Promise<{ placedBet: DicePlacedBet; receipt: TransactionReceipt }> {
  const { placedBet, receipt } = await placeBet(
    wallet,
    {
      game: CASINO_GAME_TYPE.DICE,
      gameEncodedInput: Dice.encodeInput(diceParams.cap),
      ...diceParams,
    },
    options,
    callbacks,
  );
  const dicePlacedBet = await getDicePlacedBetFromReceipt(
    wallet,
    receipt,
    placedBet.chainId,
    placedBet.token,
  );
  if (!dicePlacedBet) {
    throw new TransactionError(
      "Dice PlaceBet event not found",
      ERROR_CODES.GAME.PLACE_BET_EVENT_NOT_FOUND,
      {
        hash: receipt.transactionHash,
        chainId: placedBet.chainId,
      },
    );
  }

  return { placedBet: dicePlacedBet, receipt };
}

export async function getDicePlacedBetFromReceipt(
  wallet: BetSwirlWallet,
  receipt: TransactionReceipt,
  chainId: CasinoChainId,
  usedToken?: Token,
): Promise<DicePlacedBet | null> {
  const gamePlacedBet = await getPlacedBetFromReceipt(
    wallet,
    receipt,
    CASINO_GAME_TYPE.DICE,
    chainId,
    usedToken,
  );
  if (!gamePlacedBet) {
    return null;
  }
  // Read the Dice PlaceBet event from logs
  const decodedDicePlaceBetEvent = receipt.logs
    .map((log) => {
      try {
        return decodeEventLog({
          abi: diceAbi,
          data: log.data,
          topics: log.topics,
        });
      } catch {
        return null;
      }
    })
    .find((log) => log?.eventName === "PlaceBet");

  if (!decodedDicePlaceBetEvent) {
    return null;
  }

  const { args } = decodedDicePlaceBetEvent;
  return {
    ...gamePlacedBet,
    game: CASINO_GAME_TYPE.DICE,
    encodedCap: args.cap,
    cap: Dice.decodeInput(args.cap),
  };
}
</file>

<file path="packages/core/src/actions/casino/game.ts">
import { type Hash, type Hex, type TransactionReceipt, encodeFunctionData } from "viem";
import { decodeEventLog } from "viem";
import { coinTossAbi } from "../../abis/v2/casino/cointoss";
import { GAS_TOKEN_ADDRESS } from "../../constants";
import {
  CASINO_GAME_TYPE,
  type CasinoChain,
  type CasinoChainId,
  MAX_SDK_HOUSE_EGDE,
  type NORMAL_CASINO_GAME_TYPE,
  type WEIGHTED_CASINO_GAME_TYPE,
  casinoChainById,
} from "../../data/casino";
import type { KenoEncodedInput } from "../../entities";
import type { CoinTossEncodedInput } from "../../entities/casino/cointoss";
import type { DiceEncodedInput } from "../../entities/casino/dice";
import type { RouletteEncodedInput } from "../../entities/casino/roulette";
import { ERROR_CODES } from "../../errors/codes";
import { ChainError, ConfigurationError, TransactionError } from "../../errors/types";
import type { BetSwirlFunctionData, Token } from "../../interfaces";
import type { BetSwirlWallet } from "../../provider";
import { getChainlinkVrfCost } from "../../read/common/chainlinkVrfCost";
import { GAS_PRICE_TYPE, getGasPrices } from "../../read/common/gasPrice";
import { getTokenMetadata } from "../../read/common/tokenMetadata";
import { getCasinoChainId } from "../../utils";
import { chainNativeCurrencyToToken } from "../../utils/tokens";
import { ALLOWANCE_TYPE, type ApproveResult, approve } from "../common/approve";

export interface CasinoBetParams {
  betAmount: bigint;
  betCount?: number;
  token?: Token;
  stopGain?: bigint;
  stopLoss?: bigint;
  vrfFees?: bigint;
  receiver?: Hex;
  affiliate?: Hex;
}

export const defaultCasinoGameParams = {
  betCount: 1,
  //token: zeroAddress, => chain.nativeCurrency
  stopGain: 0n,
  stopLoss: 0n,
  vrfFees: 0n, // When 0, VRF fees are calculated on the fly
  //pollingInterval: => data in casino.ts
};

export interface CasinoPlaceBetOptions {
  gasPriceType?: GAS_PRICE_TYPE;
  gasPrice?: bigint; // wei
  allowanceType?: ALLOWANCE_TYPE;
  pollingInterval?: number;
}

export const defaultCasinoPlaceBetOptions = {
  gasPriceType: GAS_PRICE_TYPE.NORMAL,
  gasPrice: 0n,
  allowanceType: ALLOWANCE_TYPE.AUTO,
};
// Game should not know the game implementation details, but well..  it helps developers
export type GameEncodedInput =
  | CoinTossEncodedInput
  | DiceEncodedInput
  | RouletteEncodedInput
  | KenoEncodedInput;
export interface GenericCasinoBetParams extends CasinoBetParams {
  game: CASINO_GAME_TYPE;
  gameEncodedInput: GameEncodedInput;
}

interface CommonCasinoPlacedBet {
  id: bigint;
  betAmount: bigint;
  betCount: number;
  totalBetAmount: bigint;
  chargedVRFCost: bigint;
  token: Token;
  affiliate: Hex;
  receiver: Hex;
  stopGain: bigint;
  stopLoss: bigint;
  betTxnHash: Hash;
  betBlock: bigint;
  chainId: CasinoChainId;
}
export interface NormalCasinoPlacedBet extends CommonCasinoPlacedBet {
  game: NORMAL_CASINO_GAME_TYPE;
}
export interface WeightedCasinoPlacedBet extends CommonCasinoPlacedBet {
  game: WEIGHTED_CASINO_GAME_TYPE;
}

export type CasinoPlacedBet = NormalCasinoPlacedBet | WeightedCasinoPlacedBet;

export interface PlaceBetCallbacks {
  onApprovePending?: (tx: Hash, result: ApproveResult) => void | Promise<void>;
  onApproved?: (receipt: TransactionReceipt, result: ApproveResult) => void | Promise<void>;
  onBetPlacedPending?: (tx: Hash) => void | Promise<void>;
}

export async function placeBet(
  wallet: BetSwirlWallet,
  betParams: GenericCasinoBetParams,
  options?: CasinoPlaceBetOptions,
  callbacks?: PlaceBetCallbacks,
): Promise<{ placedBet: CasinoPlacedBet; receipt: TransactionReceipt }> {
  const casinoChainId = getCasinoChainId(wallet);
  const casinoChain = casinoChainById[casinoChainId];
  const game = casinoChain.contracts.games[betParams.game];

  if (!game) {
    throw new ChainError(
      `${betParams.game} is not available for chain ${casinoChain.viemChain.name} (${casinoChainId})`,
      ERROR_CODES.CHAIN.UNSUPPORTED_GAME,
      {
        chainId: casinoChainId,
        supportedChains: Object.keys(casinoChainById),
      },
    );
  }

  const accountAddress = betParams.receiver || wallet.getAccount(casinoChainId)?.address;
  if (!accountAddress) {
    throw new ConfigurationError(
      `No configured account in the wallet for chain ${casinoChain.viemChain.name} (${casinoChainId})`,
      ERROR_CODES.WALLET.ACCOUNT_MISSING,
      {
        chainId: casinoChainId,
      },
    );
  }
  try {
    // Get gas price if needed
    const gasPrice =
      options?.gasPrice ||
      (await getGasPrices(wallet, casinoChainId))[
        options?.gasPriceType || defaultCasinoPlaceBetOptions.gasPriceType
      ];
    const token =
      betParams.token || chainNativeCurrencyToToken(casinoChain.viemChain.nativeCurrency);

    // Generate function data
    const receiver = betParams.receiver || accountAddress;
    const functionData = getPlaceBetFunctionData(
      { ...betParams, receiver, tokenAddress: token.address },
      casinoChainId,
    );

    // Approve if needed

    const allowanceType = options?.allowanceType || defaultCasinoPlaceBetOptions.allowanceType;
    const pollingInterval = options?.pollingInterval || casinoChain.options.pollingInterval;

    const { receipt: approveReceipt, result: approveResult } = await approve(
      wallet,
      token.address,
      accountAddress,
      game.address,
      functionData.extraData.totalBetAmount,
      gasPrice,
      pollingInterval,
      allowanceType,
      callbacks?.onApprovePending,
    );

    if (approveReceipt) await callbacks?.onApproved?.(approveReceipt, approveResult);

    // Get VRF fees
    const vrfFees =
      betParams.vrfFees ||
      (await getChainlinkVrfCost(
        wallet,
        betParams.game,
        token.address,
        functionData.extraData.betCount,
        gasPrice,
      ));
    // Execute place bet tx
    const hash = await wallet.writeContract(
      functionData,
      functionData.extraData.getValue(vrfFees),
      gasPrice,
    );
    await callbacks?.onBetPlacedPending?.(hash);
    const receipt = await wallet.waitTransaction(hash, pollingInterval);

    const placedBet = await getPlacedBetFromReceipt(wallet, receipt, betParams.game);
    if (!placedBet) {
      throw new TransactionError(
        "PlaceBet event not found",
        ERROR_CODES.GAME.PLACE_BET_EVENT_NOT_FOUND,
        {
          gameAddress: game.address,
          gameType: betParams.game,
          chainId: casinoChainId,
          token,
        },
      );
    }

    return { placedBet, receipt };
  } catch (error) {
    throw new TransactionError(
      `An error occured while placing the bet: ${error}`,
      ERROR_CODES.GAME.PLACE_BET_ERROR,
      {
        gameAddress: game.address,
        gameType: betParams.game,
        chainId: casinoChainId,
        token: betParams.token,
        betAmount: betParams.betAmount,
        betCount: betParams.betCount,
        stopGain: betParams.stopGain,
        stopLoss: betParams.stopLoss,
      },
    );
  }
}
type GameAbi<T extends CASINO_GAME_TYPE> = NonNullable<CasinoChain["contracts"]["games"][T]>["abi"];

export function getPlaceBetFunctionData(
  gameParams: Omit<GenericCasinoBetParams, "receiver" | "vrfFees" | "token"> & {
    receiver: Hex;
    tokenAddress?: Hex;
  },
  chainId: CasinoChainId,
): BetSwirlFunctionData<
  GameAbi<typeof gameParams.game>,
  "wager",
  readonly [
    ...GameEncodedInput[],
    Hex,
    Hex,
    {
      readonly token: Hex;
      readonly betAmount: bigint;
      readonly betCount: number;
      readonly stopGain: bigint;
      readonly stopLoss: bigint;
      readonly maxHouseEdge: number;
    },
  ]
> & {
  extraData: {
    totalBetAmount: bigint;
    tokenAddress: Hex;
    betCount: number;
    stopGain: bigint;
    stopLoss: bigint;
    maxHouseEdge: number;
    affiliate: Hex;
    getValue: (vrfFees: bigint) => bigint;
  };
} {
  const casinoChain = casinoChainById[chainId];
  const game = casinoChain.contracts.games[gameParams.game];

  if (!game) {
    throw new ChainError(
      `${gameParams.game} is not available for chain ${casinoChain.viemChain.name} (${chainId})`,
      ERROR_CODES.CHAIN.UNSUPPORTED_GAME,
      {
        chainId,
        supportedChains: Object.keys(casinoChainById),
      },
    );
  }

  const affiliate = gameParams.affiliate || casinoChain.defaultAffiliate;
  const tokenAddress = gameParams.tokenAddress || GAS_TOKEN_ADDRESS;
  const betCount = gameParams.betCount || defaultCasinoGameParams.betCount;
  const stopGain = gameParams.stopGain || defaultCasinoGameParams.stopGain;
  const stopLoss = gameParams.stopLoss || defaultCasinoGameParams.stopLoss;
  const maxHouseEdge = MAX_SDK_HOUSE_EGDE;

  const abi = game.abi;
  const functionName = "wager" as const;
  const args = [
    ...(Array.isArray(gameParams.gameEncodedInput)
      ? gameParams.gameEncodedInput
      : [gameParams.gameEncodedInput]),
    gameParams.receiver,
    affiliate,
    {
      token: tokenAddress,
      betAmount: gameParams.betAmount,
      betCount,
      stopGain,
      stopLoss,
      maxHouseEdge,
    },
  ] as const;

  const totalBetAmount = gameParams.betAmount * BigInt(betCount);
  return {
    data: { to: game.address, abi, functionName, args },
    encodedData: encodeFunctionData({ abi, functionName, args }),
    extraData: {
      totalBetAmount,
      tokenAddress,
      betCount,
      stopGain,
      stopLoss,
      maxHouseEdge,
      affiliate,
      getValue: (vrfFees: bigint) =>
        tokenAddress === GAS_TOKEN_ADDRESS ? totalBetAmount + vrfFees : vrfFees,
    },
  };
}

export async function getPlacedBetFromReceipt(
  wallet: BetSwirlWallet,
  receipt: TransactionReceipt,
  game: CASINO_GAME_TYPE,
  chainId?: CasinoChainId,
  usedToken?: Token, // to avoid to fetch the token metadata from the chain if the token used is already known
): Promise<CasinoPlacedBet | null> {
  const casinoChainId = getCasinoChainId(wallet, chainId);
  const casinoChain = casinoChainById[casinoChainId];
  // Read the Placedbet event from logs
  const decodedPlaceBetEvent = receipt.logs
    .map((log) => {
      try {
        return decodeEventLog<typeof coinTossAbi>({
          //@ts-ignore coinTossAbi is used because PlaceBet event is the same for all games (expect input param)
          abi: casinoChain.contracts.games[game]?.abi!,
          //@ts-ignore
          data: log.data,
          topics: log.topics,
        });
      } catch {
        return null;
      }
    })
    .find((log) => log?.eventName === "PlaceBet");

  if (!decodedPlaceBetEvent) {
    return null;
  }

  const { args } = decodedPlaceBetEvent;

  let token = usedToken;
  if (!token) {
    token = await getTokenMetadata(wallet, args.token!, casinoChainId);
  }
  return {
    id: args.id,
    betAmount: args.amount,
    betCount: args.betCount,
    totalBetAmount: args.amount * BigInt(args.betCount),
    chargedVRFCost: args.chargedVRFCost,
    token,
    affiliate: args.affiliate,
    receiver: args.receiver,
    stopGain: args.stopGain,
    stopLoss: args.stopLoss,
    betTxnHash: receipt.transactionHash,
    betBlock: receipt.blockNumber,
    chainId: casinoChainId,
    game,
  };
}
</file>

<file path="packages/core/src/actions/casino/keno.ts">
import { type TransactionReceipt, decodeEventLog } from "viem";
import { kenoAbi } from "../../abis/v2/casino/keno";
import { CASINO_GAME_TYPE, type CasinoChainId } from "../../data/casino";
import { Keno, type KenoBall, type KenoEncodedInput } from "../../entities/casino/keno";
import { ERROR_CODES } from "../../errors/codes";
import { TransactionError } from "../../errors/types";
import type { Token } from "../../interfaces";
import type { BetSwirlWallet } from "../../provider";
import type { KenoConfiguration } from "../../read";
import {
  type CasinoBetParams,
  type CasinoPlaceBetOptions,
  type NormalCasinoPlacedBet,
  type PlaceBetCallbacks,
  getPlacedBetFromReceipt,
  placeBet,
} from "./game";

export interface KenoParams extends CasinoBetParams {
  balls: KenoBall[];
  kenoConfig: KenoConfiguration;
}

export interface KenoPlacedBet extends NormalCasinoPlacedBet {
  balls: KenoBall[];
  encodedBalls: KenoEncodedInput;
  game: CASINO_GAME_TYPE.KENO;
}

export async function placeKenoBet(
  wallet: BetSwirlWallet,
  kenoParams: KenoParams,
  options?: CasinoPlaceBetOptions,
  callbacks?: PlaceBetCallbacks,
): Promise<{ placedBet: KenoPlacedBet; receipt: TransactionReceipt }> {
  const { placedBet, receipt } = await placeBet(
    wallet,
    {
      game: CASINO_GAME_TYPE.KENO,
      gameEncodedInput: Keno.encodeInput(kenoParams.balls, kenoParams.kenoConfig),
      ...kenoParams,
    },
    options,
    callbacks,
  );
  const kenoPlacedBet = await getKenoPlacedBetFromReceipt(
    wallet,
    receipt,
    placedBet.chainId,
    placedBet.token,
  );
  if (!kenoPlacedBet) {
    throw new TransactionError(
      "Keno PlaceBet event not found",
      ERROR_CODES.GAME.PLACE_BET_EVENT_NOT_FOUND,
      {
        hash: receipt.transactionHash,
        chainId: placedBet.chainId,
      },
    );
  }
  return { placedBet: kenoPlacedBet, receipt };
}

export async function getKenoPlacedBetFromReceipt(
  wallet: BetSwirlWallet,
  receipt: TransactionReceipt,
  chainId: CasinoChainId,
  usedToken?: Token,
): Promise<KenoPlacedBet | null> {
  const gamePlacedBet = await getPlacedBetFromReceipt(
    wallet,
    receipt,
    CASINO_GAME_TYPE.KENO,
    chainId,
    usedToken,
  );
  if (!gamePlacedBet) {
    return null;
  }

  // Read the Keno PlaceBet event from logs
  const decodedKenoPlaceBetEvent = receipt.logs
    .map((log) => {
      try {
        return decodeEventLog({
          abi: kenoAbi,
          data: log.data,
          topics: log.topics,
        });
      } catch {
        return null;
      }
    })
    .find((log) => log?.eventName === "PlaceBet");

  if (!decodedKenoPlaceBetEvent) {
    return null;
  }

  const { args } = decodedKenoPlaceBetEvent;
  return {
    ...gamePlacedBet,
    game: CASINO_GAME_TYPE.KENO,
    encodedBalls: args.numbers,
    balls: Keno.decodeInput(args.numbers),
  };
}
</file>

<file path="packages/core/src/actions/casino/roulette.ts">
import { type TransactionReceipt, decodeEventLog } from "viem";
import { rouletteAbi } from "../../abis/v2/casino/roulette";
import { CASINO_GAME_TYPE, type CasinoChainId } from "../../data/casino";
import {
  Roulette,
  type RouletteEncodedInput,
  type RouletteNumber,
} from "../../entities/casino/roulette";
import { ERROR_CODES } from "../../errors/codes";
import { TransactionError } from "../../errors/types";
import type { Token } from "../../interfaces";
import type { BetSwirlWallet } from "../../provider";
import {
  type CasinoBetParams,
  type CasinoPlaceBetOptions,
  type NormalCasinoPlacedBet,
  type PlaceBetCallbacks,
  getPlacedBetFromReceipt,
  placeBet,
} from "./game";

export interface RouletteParams extends CasinoBetParams {
  numbers: RouletteNumber[];
}

export interface RoulettePlacedBet extends NormalCasinoPlacedBet {
  numbers: RouletteNumber[];
  encodedNumbers: RouletteEncodedInput;
  game: CASINO_GAME_TYPE.ROULETTE;
}

export async function placeRouletteBet(
  wallet: BetSwirlWallet,
  rouletteParams: RouletteParams,
  options?: CasinoPlaceBetOptions,
  callbacks?: PlaceBetCallbacks,
): Promise<{ placedBet: RoulettePlacedBet; receipt: TransactionReceipt }> {
  const { placedBet, receipt } = await placeBet(
    wallet,
    {
      game: CASINO_GAME_TYPE.ROULETTE,
      gameEncodedInput: Roulette.encodeInput(rouletteParams.numbers),
      ...rouletteParams,
    },
    options,
    callbacks,
  );
  const roulettePlacedBet = await getRoulettePlacedBetFromReceipt(
    wallet,
    receipt,
    placedBet.chainId,
    placedBet.token,
  );
  if (!roulettePlacedBet) {
    throw new TransactionError(
      "Roulette PlaceBet event not found",
      ERROR_CODES.GAME.PLACE_BET_EVENT_NOT_FOUND,
      {
        hash: receipt.transactionHash,
        chainId: placedBet.chainId,
      },
    );
  }
  return { placedBet: roulettePlacedBet, receipt };
}

export async function getRoulettePlacedBetFromReceipt(
  wallet: BetSwirlWallet,
  receipt: TransactionReceipt,
  chainId: CasinoChainId,
  usedToken?: Token,
): Promise<RoulettePlacedBet | null> {
  const gamePlacedBet = await getPlacedBetFromReceipt(
    wallet,
    receipt,
    CASINO_GAME_TYPE.ROULETTE,
    chainId,
    usedToken,
  );
  if (!gamePlacedBet) {
    return null;
  }

  // Read the Roulette PlaceBet event from logs
  const decodedRoulettePlaceBetEvent = receipt.logs
    .map((log) => {
      try {
        return decodeEventLog({
          abi: rouletteAbi,
          data: log.data,
          topics: log.topics,
        });
      } catch {
        return null;
      }
    })
    .find((log) => log?.eventName === "PlaceBet");

  if (!decodedRoulettePlaceBetEvent) {
    return null;
  }

  const { args } = decodedRoulettePlaceBetEvent;
  return {
    ...gamePlacedBet,
    game: CASINO_GAME_TYPE.ROULETTE,
    encodedNumbers: args.numbers,
    numbers: Roulette.decodeInput(args.numbers),
  };
}
</file>

<file path="packages/core/src/actions/index.ts">
/* Casino */
export * from "./casino/cointoss";
export * from "./casino/dice";
export * from "./casino/roulette";
export * from "./casino/keno";
export * from "./casino/game";
export * from "./casino/wheel";
export * from "./casino/weightedGame";

/* Common */
export * from "./common/approve";
export * from "../read/common/tokenMetadata";
</file>

<file path="packages/core/src/data/subgraphs/protocol/clients/bet.ts">
import { ApolloClient } from "@apollo/client/core/index.js";
import { type Address, type Hash, getAddress, zeroAddress } from "viem";
import type { NORMAL_CASINO_GAME_TYPE, WeightedGameConfiguration } from "../../../..";
import { DEFAULT_ITEMS_PER_PAGE, DEFAULT_PAGE } from "../../../../constants";
import { ERROR_CODES } from "../../../../errors";
import { SubgraphError } from "../../../../errors/types";
import type { CasinoBet, Token } from "../../../../interfaces";
import {
  chainNativeCurrencyToToken,
  decodeNormalCasinoInput,
  decodeNormalCasinoRolled,
  decodeWeightedCasinoInput,
  decodeWeightedCasinoRolled,
} from "../../../../utils";
import { FORMAT_TYPE, formatRawAmount } from "../../../../utils/format";
import {
  CASINO_GAME_SUBGRAPH_TYPE,
  CASINO_GAME_TYPE,
  type CasinoChainId,
  casinoChainById,
  subgraphGameByType,
  typeBySubgraphCasinoGame,
} from "../../../casino";
import { BetDocument, type BetQuery, type BetQueryVariables } from "../documents/bet";
import { BetsDocument, type BetsQuery, type BetsQueryVariables } from "../documents/bets";
import type { BetFragment } from "../documents/fragments/bet";
import { Bet_OrderBy, OrderDirection } from "../documents/types";
import {
  type SubgraphCasinoClient,
  defaultSubgraphCasinoClient,
  getGraphqlEndpoint,
} from "./common";

export function formatCasinoBet(
  bet: BetFragment,
  chainId: CasinoChainId,
  formatType: FORMAT_TYPE = FORMAT_TYPE.STANDARD,
): CasinoBet {
  const casinoChain = casinoChainById[chainId];
  const betAmount = bet.betAmount ? BigInt(bet.betAmount) : 0n;
  const nativeCurrency = casinoChain.viemChain.nativeCurrency;
  const token =
    bet.gameToken.token.address === zeroAddress
      ? chainNativeCurrencyToToken(nativeCurrency)
      : {
          address: getAddress(bet.gameToken.token.address),
          symbol: bet.gameToken.token.symbol,
          decimals: bet.gameToken.token.decimals,
        };
  const game = typeBySubgraphCasinoGame[bet.gameId as CASINO_GAME_SUBGRAPH_TYPE];
  const totalBetAmount = betAmount * BigInt(bet.betCount);
  const rollTotalBetAmount = bet.rollTotalBetAmount ? BigInt(bet.rollTotalBetAmount) : undefined;
  const benefit =
    rollTotalBetAmount && bet.payout ? BigInt(bet.payout) - BigInt(rollTotalBetAmount) : undefined;
  const encodedRolled = bet.encodedRolled ? bet.encodedRolled : undefined;
  const isWin =
    rollTotalBetAmount && bet.payout ? BigInt(bet.payout) >= rollTotalBetAmount : undefined;
  const isStopTriggered = encodedRolled ? encodedRolled.length !== Number(bet.betCount) : undefined;

  const weightedGameConfiguration: WeightedGameConfiguration | undefined = bet.weightedGameBet
    ? {
        configId: Number(bet.weightedGameBet.config.id),
        multipliers: bet.weightedGameBet.config.multipliers.map((multiplier) => BigInt(multiplier)),
        weights: bet.weightedGameBet.config.weights.map((weight) => BigInt(weight)),
        game,
        chainId,
      }
    : undefined;
  return {
    id: BigInt(bet.id),
    token,
    nativeCurrency: chainNativeCurrencyToToken(nativeCurrency),
    chainId,
    game,
    gameAddress: getAddress(bet.gameAddress),
    bettor: getAddress(bet.user.address),
    betAmount,
    formattedBetAmount: formatRawAmount(betAmount, token.decimals, formatType),
    betCount: Number(bet.betCount),
    totalBetAmount: totalBetAmount,
    formattedTotalBetAmount: formatRawAmount(totalBetAmount, token.decimals, formatType),
    stopLoss: BigInt(bet.stopLoss),
    formattedStopLoss: formatRawAmount(BigInt(bet.stopLoss), token.decimals, formatType),
    stopGain: BigInt(bet.stopGain),
    formattedStopGain: formatRawAmount(BigInt(bet.stopGain), token.decimals, formatType),
    houseEdge: bet.houseEdge, // BP
    betTimestampSecs: Number(bet.betTimestamp), // secs
    betDate: new Date(Math.round(Number(bet.betTimestamp) * 1000)),
    chargedVRFFees: BigInt(bet.chargedVRFFees),
    formattedChargedVRFFees: formatRawAmount(
      BigInt(bet.chargedVRFFees),
      nativeCurrency.decimals,
      formatType,
    ),
    betTxnHash: bet.betTxnHash,
    encodedInput: bet.encodedInput,
    decodedInput: weightedGameConfiguration
      ? decodeWeightedCasinoInput(bet.encodedInput, weightedGameConfiguration, bet.houseEdge)
      : decodeNormalCasinoInput(bet.encodedInput, game as NORMAL_CASINO_GAME_TYPE),
    payout: bet.payout ? BigInt(bet.payout) : undefined,
    formattedPayout: bet.payout
      ? formatRawAmount(BigInt(bet.payout), token.decimals, formatType)
      : undefined,
    formattedPayoutMultiplier: bet.payoutMultiplier ? Number(bet.payoutMultiplier) : undefined,
    benefit,
    formattedBenefit: benefit ? formatRawAmount(benefit, token.decimals, formatType) : undefined,
    rollTxnHash: bet.rollTxnHash,
    rollTimestampSecs: bet.rollTimestamp ? Number(bet.rollTimestamp) : undefined, // secs
    rollDate: bet.rollTimestamp
      ? new Date(Math.round(Number(bet.rollTimestamp) * 1000))
      : undefined,
    isResolved: bet.isResolved,
    isRefunded: bet.isRefunded,
    rollTotalBetAmount,
    fomattedRollTotalBetAmount: rollTotalBetAmount
      ? formatRawAmount(rollTotalBetAmount, token.decimals, formatType)
      : undefined,
    rollBetCount: encodedRolled?.length,
    encodedRolled,
    decodedRolled: encodedRolled?.map((encoded) =>
      weightedGameConfiguration
        ? decodeWeightedCasinoRolled(encoded, weightedGameConfiguration, bet.houseEdge)
        : decodeNormalCasinoRolled(encoded, game as NORMAL_CASINO_GAME_TYPE),
    ),
    affiliate: bet.affiliate?.address ? bet.affiliate.address : undefined,
    isWin,
    isLost: isWin === undefined ? undefined : !isWin,
    isStopLossTriggered: isStopTriggered === undefined ? undefined : isStopTriggered && !isWin,
    isStopGainTriggered: isStopTriggered === undefined ? undefined : isStopTriggered && isWin,
  };
}

export enum CasinoBetFilterStatus {
  RESOLVED = "RESOLVED",
  PENDING = "PENDING",
}

export async function fetchBets(
  client: SubgraphCasinoClient,
  filter?: {
    bettor?: Address;
    game?: CASINO_GAME_TYPE;
    token?: Token;
    status?: CasinoBetFilterStatus;
    affiliates?: Address[];
  },
  page = DEFAULT_PAGE,
  itemsPerPage = DEFAULT_ITEMS_PER_PAGE,
  sortBy: { key: Bet_OrderBy; order: OrderDirection } = {
    key: Bet_OrderBy.BetTimestamp,
    order: OrderDirection.Desc,
  },
): Promise<{ bets: CasinoBet[]; error: SubgraphError | undefined }> {
  const apolloClient = new ApolloClient({
    uri: getGraphqlEndpoint(client),
    cache: client.cache ?? defaultSubgraphCasinoClient.cache,
  });

  const variables: BetsQueryVariables = {
    first: itemsPerPage,
    skip: itemsPerPage * (page - 1),
    where: {
      ...(filter?.bettor && { user: filter.bettor.toLowerCase() }),
      ...(filter?.game && { gameId: subgraphGameByType[filter.game] }),
      ...(filter?.token && {
        gameToken_: { token: filter.token.address.toLowerCase() },
      }),
      ...(filter?.status !== undefined && {
        resolved: filter.status === CasinoBetFilterStatus.RESOLVED,
      }),
      ...(filter?.affiliates?.length && {
        affiliate_in: filter.affiliates.map((a) => a.toLowerCase()),
      }),
    },
    orderBy: sortBy?.key,
    orderDirection: sortBy?.order,
  };

  const { data, error } = await apolloClient.query<BetsQuery, BetsQueryVariables>({
    query: BetsDocument,
    variables,
  });

  return {
    bets:
      data?.bets.map((bet) =>
        formatCasinoBet(
          bet,
          client.chainId,
          client.formatType ?? defaultSubgraphCasinoClient.formatType,
        ),
      ) ?? [],
    error: error
      ? new SubgraphError("Error fetching bets", ERROR_CODES.SUBGRAPH.FETCH_BETS_ERROR, error)
      : undefined,
  };
}

export async function fetchBet(
  id: string | bigint,
  client: SubgraphCasinoClient,
): Promise<{ bet: CasinoBet | undefined; error: SubgraphError | undefined }> {
  const apolloClient = new ApolloClient({
    uri: getGraphqlEndpoint(client),
    cache: client.cache ?? defaultSubgraphCasinoClient.cache,
  });

  const { data, error } = await apolloClient.query<BetQuery, BetQueryVariables>({
    query: BetDocument,
    variables: {
      id: id.toString(),
    },
  });

  return {
    bet: data.bet
      ? formatCasinoBet(
          data.bet,
          client.chainId,
          client.formatType ?? defaultSubgraphCasinoClient.formatType,
        )
      : undefined,
    error: error
      ? new SubgraphError("Error fetching bet", ERROR_CODES.SUBGRAPH.FETCH_BET_ERROR, error)
      : undefined,
  };
}

export async function fetchBetByHash(
  placeBetHash: Hash,
  client: SubgraphCasinoClient,
): Promise<{ bet: CasinoBet | undefined; error: SubgraphError | undefined }> {
  const apolloClient = new ApolloClient({
    uri: getGraphqlEndpoint(client),
    cache: client.cache ?? defaultSubgraphCasinoClient.cache,
    defaultOptions: client.defaultOptions ?? defaultSubgraphCasinoClient.defaultOptions,
  });

  const variables: BetsQueryVariables = {
    first: 1,
    where: {
      betTxnHash: placeBetHash.toLowerCase(),
    },
  };

  const { data, error } = await apolloClient.query<BetsQuery, BetsQueryVariables>({
    query: BetsDocument,
    variables,
  });
  return {
    bet: data.bets[0]
      ? formatCasinoBet(
          data.bets[0],
          client.chainId,
          client.formatType ?? defaultSubgraphCasinoClient.formatType,
        )
      : undefined,
    error: error
      ? new SubgraphError("Error fetching bet", ERROR_CODES.SUBGRAPH.FETCH_BET_ERROR, error)
      : undefined,
  };
}
</file>

<file path="packages/core/src/entities/casino/wheel.ts">
import { type WeightedGameConfiguration, generateRandomHexColor, getNetMultiplier } from "../..";
import { WeightedGame, type WeightedGameChoiceInput } from "./weightedGame";

export interface WheelChoiceInput extends WeightedGameChoiceInput {}

export class Wheel extends WeightedGame {
  // Wheel utilities

  /**
   * Computes and returns the list of unique wheel outputs for a given weighted game configuration.
   * It is particularly useful to display all the unique possible outputs above/below the wheel in the UI.
   *
   * This function groups wheel segments that have the same net multiplier (netMultiplier),
   * sums their weights, and returns for each unique multiplier:
   *   - the net multiplier (rounded to 2 decimals)
   *   - the raw multiplier (before house edge)
   *   - the chance to win this multiplier (as a percentage)
   *   - the color associated with this segment (or a randomly generated color if not provided)
   *
   * @param weightedGameConfig The wheel configuration (weights, multipliers, colors, etc.)
   * @param houseEdge The house edge to apply for net multiplier calculation
   * @returns An array of objects representing each unique wheel output:
   *   - multiplier: the net multiplier (rounded to 2 decimals)
   *   - rawMultiplier: the raw multiplier (before house edge)
   *   - chanceToWin: the probability of landing on this multiplier (in %)
   *   - color: the color associated with this segment
   *
   * @example
   * const outputs = Wheel.getUniqueWheelOutputs(config, 200);
   * // [
   * //   { multiplier: 1.95, rawMultiplier: 19500, chanceToWin: 10.5, color: "#29384C" },
   * //   ...
   * // ]
   */
  static getUniqueWheelOutputs(
    weightedGameConfig: WeightedGameConfiguration,
    houseEdge: number,
  ): {
    multiplier: number;
    rawMultiplier: number;
    chanceToWin: number;
    color: string;
  }[] {
    const uniqueMultipliers = new Map<number, { color: string; weight: bigint }>();
    const totalWeight = weightedGameConfig.weights.reduce((acc, curr) => acc + curr, 0n);
    weightedGameConfig.multipliers.forEach((_, index) => {
      const netMultiplier = getNetMultiplier(
        WeightedGame.getMultiplier(weightedGameConfig, index),
        houseEdge,
      );
      if (!uniqueMultipliers.has(netMultiplier)) {
        uniqueMultipliers.set(netMultiplier, {
          color: weightedGameConfig.colors?.[index] || generateRandomHexColor(),
          weight: weightedGameConfig.weights[index]!,
        });
      } else {
        uniqueMultipliers.get(netMultiplier)!.weight =
          uniqueMultipliers.get(netMultiplier)!.weight + weightedGameConfig.weights[index]!;
      }
    });

    return Array.from(uniqueMultipliers.entries()).map(([multiplier, config]) => ({
      multiplier: Number(multiplier.toFixed(2)),
      rawMultiplier: multiplier,
      chanceToWin: Number(((Number(config.weight) / Number(totalWeight)) * 100).toFixed(2)),
      color: config.color,
    }));
  }
}
</file>

<file path="packages/core/src/entities/index.ts">
/* Casino */
export * from "./casino/cointoss";
export * from "./casino/dice";
export * from "./casino/roulette";
export * from "./casino/game";
export * from "./casino/keno";
export * from "./casino/weightedGame";
export * from "./casino/wheel";
</file>

<file path="packages/core/src/read/casino/keno.ts">
import { type Address, type Hex, type TransactionReceipt, encodeFunctionData } from "viem";
import { kenoAbi } from "../../abis";
import type { KenoPlacedBet } from "../../actions/casino/keno";
import { CASINO_GAME_TYPE, type CasinoChainId, casinoChainById } from "../../data/casino";
import { Keno, type KenoBall } from "../../entities/casino/keno";
import { ERROR_CODES, TransactionError } from "../../errors";
import { ChainError } from "../../errors";
import type { BetSwirlFunctionData, Token } from "../../interfaces";
import type { BetSwirlWallet } from "../../provider";
import { getCasinoChainId } from "../../utils";
import type { CasinoRolledBet, CasinoWaitRollOptions } from "./game";

export interface KenoRolledBet extends Omit<CasinoRolledBet, "decodedRoll"> {
  rolled: KenoBall[][];
}

export async function waitKenoRolledBet(
  wallet: BetSwirlWallet,
  placedBet: KenoPlacedBet,
  options?: CasinoWaitRollOptions,
): Promise<{
  rolledBet: KenoRolledBet;
  receipt: TransactionReceipt;
}> {
  const { rolledBet, receipt } = await waitKenoRolledBet(wallet, placedBet, options);
  return {
    rolledBet: {
      ...rolledBet,
      rolled: rolledBet.encodedRolled.map(Keno.decodeRolled),
    },
    receipt,
  };
}

/**
 * Raw Keno configuration data returned by the smart contract
 * [0] - biggestNumber: The biggest selectable number
 * [1] - maxNumbersPlayed: Maximum selectable numbers
 * [2] - gainsTable: The gain multipliers (gain multiplier = gains[numbers played][numbers matched]) (BP)
 */
export type RawKenoConfiguration = [bigint, bigint, readonly (readonly bigint[])[]];

export function parseRawKenoConfiguration(
  rawConfiguration: RawKenoConfiguration,
  token: Token,
  casinoChainId: CasinoChainId,
): KenoConfiguration {
  return {
    token,
    chainId: casinoChainId,
    biggestSelectableBall: Number(rawConfiguration[0]),
    maxSelectableBalls: Number(rawConfiguration[1]),
    mutliplierTable: [
      [0],
      ...rawConfiguration[2].map((row) => row.map((multiplier) => Number(multiplier))),
    ],
  };
}

export interface KenoConfiguration {
  token: Token;
  chainId: CasinoChainId;
  biggestSelectableBall: number;
  maxSelectableBalls: number;
  mutliplierTable: number[][]; // BP
}

export async function getKenoConfiguration(
  wallet: BetSwirlWallet,
  token: Token,
): Promise<KenoConfiguration> {
  const casinoChainId = getCasinoChainId(wallet);

  try {
    const functionData = getKenoConfigurationFunctionData(token.address, casinoChainId);
    const rawConfiguration = await wallet.readContract<typeof functionData, RawKenoConfiguration>(
      functionData,
    );

    return parseRawKenoConfiguration(rawConfiguration, token, casinoChainId);
  } catch (error) {
    throw new TransactionError(
      "Error getting keno configuration",
      ERROR_CODES.GAME.GET_KENO_CONFIGURATION_ERROR,
      {
        chainId: casinoChainId,
        token,
        cause: error,
      },
    );
  }
}

export function getKenoConfigurationFunctionData(
  tokenAddress: Address,
  casinoChainId: CasinoChainId,
): BetSwirlFunctionData<typeof kenoAbi, "gains", readonly [Hex]> {
  const casinoChain = casinoChainById[casinoChainId];

  const gameAddress = casinoChain.contracts.games[CASINO_GAME_TYPE.KENO]?.address;
  if (!gameAddress) {
    throw new ChainError(
      `Game ${CASINO_GAME_TYPE.KENO} not found for chain ${casinoChainId}`,
      ERROR_CODES.CHAIN.UNSUPPORTED_GAME,
    );
  }

  const abi = kenoAbi;
  const functionName = "gains" as const;
  const args = [tokenAddress] as const;
  return {
    data: { to: gameAddress, abi, functionName, args },
    encodedData: encodeFunctionData({
      abi,
      functionName,
      args,
    }),
  };
}
</file>

<file path="packages/core/src/read/casino/weightedGame.ts">
import { encodeFunctionData } from "viem";
import { weightedGameAbi } from "../../abis";
import { chainByKey } from "../../data";
import { CASINO_GAME_TYPE, type CasinoChainId, casinoChainById } from "../../data/casino";
import { ChainError, ERROR_CODES, TransactionError } from "../../errors";
import type { BetSwirlFunctionData } from "../../interfaces";
import type { BetSwirlWallet } from "../../provider/wallet";
import { getCasinoChainId } from "../../utils/chains";
import type { CasinoRolledBet } from "./game";

const normalWheelConfiguration = {
  configId: 0,
  weights: [1n, 1n, 1n, 1n, 1n, 1n, 1n, 1n, 1n, 1n],
  multipliers: [0n, 14580n, 0n, 18760n, 0n, 20830n, 0n, 14580n, 0n, 31250n],
  colors: [
    "#29384C",
    "#55DC36",
    "#29384C",
    "#15A2D8",
    "#29384C",
    "#7340F4",
    "#29384C",
    "#55DC36",
    "#29384C",
    "#EC9E3C",
  ],
  label: "Normal",
  game: CASINO_GAME_TYPE.WHEEL,
};

type WeightedGameCachedConfigurationsPerChain = {
  [chainId in CasinoChainId]: CachedWeightedGameConfiguration[];
};

export const wheelCachedConfigurations: WeightedGameCachedConfigurationsPerChain = {
  [chainByKey.arbitrumSepolia.id]: [
    { ...normalWheelConfiguration, chainId: chainByKey.arbitrumSepolia.id },
  ],
  [chainByKey.avalancheFuji.id]: [
    { ...normalWheelConfiguration, chainId: chainByKey.avalancheFuji.id },
  ],
  [chainByKey.polygonAmoy.id]: [
    { ...normalWheelConfiguration, chainId: chainByKey.polygonAmoy.id },
  ],
  [chainByKey.baseSepolia.id]: [
    { ...normalWheelConfiguration, chainId: chainByKey.baseSepolia.id },
  ],
  [chainByKey.arbitrum.id]: [{ ...normalWheelConfiguration, chainId: chainByKey.arbitrum.id }],
  [chainByKey.avalanche.id]: [{ ...normalWheelConfiguration, chainId: chainByKey.avalanche.id }],
  [chainByKey.polygon.id]: [{ ...normalWheelConfiguration, chainId: chainByKey.polygon.id }],
  [chainByKey.bsc.id]: [{ ...normalWheelConfiguration, chainId: chainByKey.bsc.id }],
  [chainByKey.base.id]: [{ ...normalWheelConfiguration, chainId: chainByKey.base.id }],
};

export const weightedGameCachedConfigurations: WeightedGameCachedConfigurationsPerChain = {
  [chainByKey.arbitrumSepolia.id]: [...wheelCachedConfigurations[chainByKey.arbitrumSepolia.id]],
  [chainByKey.avalancheFuji.id]: [...wheelCachedConfigurations[chainByKey.avalancheFuji.id]],
  [chainByKey.polygonAmoy.id]: [...wheelCachedConfigurations[chainByKey.polygonAmoy.id]],
  [chainByKey.baseSepolia.id]: [...wheelCachedConfigurations[chainByKey.baseSepolia.id]],
  [chainByKey.arbitrum.id]: [...wheelCachedConfigurations[chainByKey.arbitrum.id]],
  [chainByKey.avalanche.id]: [...wheelCachedConfigurations[chainByKey.avalanche.id]],
  [chainByKey.polygon.id]: [...wheelCachedConfigurations[chainByKey.polygon.id]],
  [chainByKey.bsc.id]: [...wheelCachedConfigurations[chainByKey.bsc.id]],
  [chainByKey.base.id]: [...wheelCachedConfigurations[chainByKey.base.id]],
};

export const gameIdByWeightedGameId = {
  [1]: CASINO_GAME_TYPE.WHEEL,
  /*[2]: Plinko,
  [3]: Mines,
  [4]: Diamonds,
  [5]: SLIDE,
  [6]: Slot,*/
} as const;

/**
 * Raw weighted game config data returned by the smart contract
 * [0] - weightRanges: The weight of each segment (sorted by ranges). e.g. [100, 250, 300] means the first segment has 100 weight, the second one has 150 weight, and the last one has 50 weight.
 * [1] - multipliers: The multiplier of each segment (BP)
 * [2] - maxMultiplier: The highest multiplier of the configuration (BP)
 * [3] - gameId: The weighted game id (used to identify the weighted game the configuration has been created for)
 */
export type RawWeightedGameConfiguration = {
  weightRanges: bigint[];
  multipliers: bigint[];
  maxMultiplier: bigint;
  gameId: number;
};

export function parseRawWeightedGameConfiguration(
  rawConfiguration: RawWeightedGameConfiguration,
  configId: number | string,
  casinoChainId: CasinoChainId,
): WeightedGameConfiguration {
  return {
    chainId: casinoChainId,
    configId: Number(configId),
    // Convert weight ranges into weights
    weights: rawConfiguration.weightRanges.map((v, i) =>
      i === 0 ? v : v - rawConfiguration.weightRanges[i - 1]!,
    ),
    multipliers: rawConfiguration.multipliers,
    game: gameIdByWeightedGameId[rawConfiguration.gameId as keyof typeof gameIdByWeightedGameId],
  };
}

export interface WeightedGameConfiguration {
  configId: number;
  game: CASINO_GAME_TYPE;
  chainId: CasinoChainId;
  weights: bigint[]; // BP
  multipliers: bigint[]; // BP
  colors?: string[];
  label?: string;
}

export interface CachedWeightedGameConfiguration extends WeightedGameConfiguration {
  colors: string[];
  label: string;
}

export async function getWeightedGameConfiguration(
  wallet: BetSwirlWallet,
  configId: number | string,
): Promise<WeightedGameConfiguration> {
  const casinoChainId = getCasinoChainId(wallet);

  try {
    // Check if the configuration is in the cached configurations to save a fetch is it is the case.
    const cachedConfigurations = weightedGameCachedConfigurations[casinoChainId];
    if (cachedConfigurations) {
      const existingCachedConfiguration = cachedConfigurations.find(
        (c) => c.configId === Number(configId),
      );
      if (existingCachedConfiguration) {
        return existingCachedConfiguration;
      }
    }
    const functionData = getWeightedGameConfigurationFunctionData(configId, casinoChainId);
    const rawConfiguration = await wallet.readContract<
      typeof functionData,
      RawWeightedGameConfiguration
    >(functionData);

    return parseRawWeightedGameConfiguration(rawConfiguration, configId, casinoChainId);
  } catch (error) {
    throw new TransactionError(
      "Error getting weighted game configuration",
      ERROR_CODES.GAME.GET_WEIGHTED_GAME_CONFIGURATION_ERROR,
      {
        chainId: casinoChainId,
        configId,
        cause: error,
      },
    );
  }
}

export function getWeightedGameConfigurationFunctionData(
  configId: number | string,
  casinoChainId: CasinoChainId,
): BetSwirlFunctionData<typeof weightedGameAbi, "gameConfigs", readonly [number]> {
  const casinoChain = casinoChainById[casinoChainId];
  // Use WHEEL address here because Wheel is the first created weighted game
  const gameAddress = casinoChain.contracts.games[CASINO_GAME_TYPE.WHEEL]?.address;
  if (!gameAddress) {
    throw new ChainError(
      `Weighted game contract not found for chain ${casinoChainId}`,
      ERROR_CODES.CHAIN.UNSUPPORTED_GAME,
    );
  }

  const abi = weightedGameAbi;
  const functionName = "gameConfigs" as const;
  const args = [Number(configId)] as const;
  return {
    data: { to: gameAddress, abi, functionName, args },
    encodedData: encodeFunctionData({
      abi,
      functionName,
      args,
    }),
  };
}

export interface WeightedGameRolledBet extends Omit<CasinoRolledBet, "decodedRoll"> {
  rolled: string[]; // multipliers (eg. x3.24)
}

// waitRolledBet and formatCasinoRolledBet are in game.ts
</file>

<file path="packages/core/src/utils/bet.ts">
import { BP_VALUE } from "../constants";
import { CASINO_GAME_TYPE, type ChainId, type NORMAL_CASINO_GAME_TYPE, slugById } from "../data";
import { CoinToss } from "../entities/casino/cointoss";
import { Dice } from "../entities/casino/dice";
import { Keno } from "../entities/casino/keno";
import { Roulette } from "../entities/casino/roulette";
import { WeightedGame } from "../entities/casino/weightedGame";
import type { WeightedGameConfiguration } from "../read";

//houseEdge is in BP_VALUE
export function getBetSwirlFees(payout: bigint, houseEdge: number): bigint {
  return (payout * BigInt(houseEdge)) / BigInt(BP_VALUE);
}
export function getGrossPayout(amount: bigint, betCount: number, multiplier: number): bigint {
  return (amount * BigInt(betCount) * BigInt(multiplier)) / BigInt(BP_VALUE);
}
// mulitplier and houseEdge are in BP_VALUE
export function getNetPayout(
  amount: bigint,
  betCount: number,
  multiplier: number,
  houseEdge: number,
): bigint {
  const grossPayout = getGrossPayout(amount, betCount, multiplier);
  return grossPayout - getBetSwirlFees(grossPayout, houseEdge);
}
// multiplier and houseEdge are in BP_VALUE
export function getNetMultiplier(multiplier: number, houseEdge: number): number {
  return Math.round(
    (Number(getNetPayout(BigInt(10 ** 18), 1, multiplier, houseEdge)) / 10 ** 18) * BP_VALUE,
  );
}
// multiplier and houseEdge are BP_VALUE
export function getFormattedNetMultiplier(multiplier: number, houseEdge: number): number {
  return Number((getNetMultiplier(multiplier, houseEdge) / BP_VALUE).toFixed(3));
}

export function decodeNormalCasinoInput(encodedInput: string, game: NORMAL_CASINO_GAME_TYPE): any {
  switch (game) {
    case CASINO_GAME_TYPE.DICE:
      return Dice.decodeInput(encodedInput);
    case CASINO_GAME_TYPE.COINTOSS:
      return CoinToss.decodeInput(encodedInput);
    case CASINO_GAME_TYPE.ROULETTE:
      return Roulette.decodeInput(encodedInput);
    case CASINO_GAME_TYPE.KENO:
      return Keno.decodeInput(encodedInput);
  }
}

// houseEdge is in BP_VALUE
export function decodeWeightedCasinoInput(
  encodedInput: string,
  _weightedGameConfiguration: WeightedGameConfiguration,
  _houseEdge = 0,
) {
  return WeightedGame.decodeInput(encodedInput);
}
export function decodeNormalCasinoRolled(
  encodedRolled: string,
  game: NORMAL_CASINO_GAME_TYPE,
): any {
  switch (game) {
    case CASINO_GAME_TYPE.DICE:
      return Dice.decodeRolled(encodedRolled);
    case CASINO_GAME_TYPE.COINTOSS:
      return CoinToss.decodeRolled(encodedRolled);
    case CASINO_GAME_TYPE.ROULETTE:
      return Roulette.decodeRolled(encodedRolled);
    case CASINO_GAME_TYPE.KENO:
      return Keno.decodeRolled(encodedRolled);
  }
}
// houseEdge is in BP_VALUE
export function decodeWeightedCasinoRolled(
  encodedRolled: string,
  weightedGameConfiguration: WeightedGameConfiguration,
  houseEdge = 0,
): any {
  return WeightedGame.decodeRolled(encodedRolled, weightedGameConfiguration, houseEdge);
}

export function formatChainlinkSubscriptionUrl(subscriptionId: string | bigint, chainId: ChainId) {
  return `https://vrf.chain.link/${slugById[chainId]}#/side-drawer/subscription/${
    slugById[chainId]
  }/${subscriptionId.toString()}`;
}
</file>

<file path="packages/core/CHANGELOG.md">
# @betswirl/sdk-core

## 0.1.0

### Minor Changes

- Add Wheel game with weighted gamr logic

## 0.0.9

### Patch Changes

- Add Keno Game

## 0.0.8

### Patch Changes

- Update encodeInput from CoinToss

## 0.0.7

### Patch Changes

- Update formatCasinoRolledBet

## 0.0.6

### Patch Changes

- Update subgraph urls

## 0.0.5

### Patch Changes

- Add getBetSwirlBetUrl util

- Make options in wait functions optional

- Improve waitRoll return type

- Add getCasinoGamePaused

## 0.0.4

### Patch Changes

- Make walletClient optional from ViemClient and ViemWallet

## 0.0.3

### Patch Changes

- Add Viem client and wallet

## 0.0.2

### Patch Changes

- Update parseRawBetRequirements to include isAllowed

## 0.0.1

### Patch Changes

- Initial release
</file>

<file path="packages/providers/wagmi/CHANGELOG.md">
# @betswirl/wagmi-provider

## 0.1.0

### Minor Changes

- Add Wheel game with weighted gamr logic

### Patch Changes

- Updated dependencies []:
  - @betswirl/sdk-core@0.1.0

## 0.0.9

### Patch Changes

- Add Keno Game

- Updated dependencies []:
  - @betswirl/sdk-core@0.0.9

## 0.0.8

### Patch Changes

- Updated dependencies []:
  - @betswirl/sdk-core@0.0.8

## 0.0.7

### Patch Changes

- Updated dependencies []:
  - @betswirl/sdk-core@0.0.7

## 0.0.6

### Patch Changes

- Updated dependencies []:
  - @betswirl/sdk-core@0.0.6

## 0.0.5

### Patch Changes

- Make options in wait functions optional

- Improve waitRoll return type

- Updated dependencies []:
  - @betswirl/sdk-core@0.0.5

## 0.0.4

### Patch Changes

- Updated dependencies []:
  - @betswirl/sdk-core@0.0.4

## 0.0.3

### Patch Changes

- Rename Client

- Updated dependencies []:
  - @betswirl/sdk-core@0.0.3

## 0.0.2

### Patch Changes

- Updated dependencies []:
  - @betswirl/sdk-core@0.0.2

## 0.0.1

### Patch Changes

- Initial release

- Updated dependencies []:
  - @betswirl/sdk-core@0.0.1
</file>

<file path="examples/mini-app/src/components/game/GameResultWindow.stories.tsx">
import type { Meta, StoryObj } from "@storybook/react"
import { GameResultWindow } from "./GameResultWindow"

const meta = {
  title: "Game/GameResultWindow",
  component: GameResultWindow,
  parameters: {
    layout: "centered",
    backgrounds: {
      default: "light",
      values: [
        { name: "light", value: "#FFFFFF" },
        { name: "dark", value: "oklch(0.15 0 0)" },
      ],
    },
  },
  tags: ["autodocs"],
  argTypes: {
    isVisible: {
      control: "boolean",
    },
    isWin: {
      control: "boolean",
    },
    amount: {
      control: "number",
    },
    payout: {
      control: "number",
    },
    currency: {
      control: "text",
    },
  },
} satisfies Meta<typeof GameResultWindow>

export default meta
type Story = StoryObj<typeof meta>

const Template: Story = {
  args: {
    isVisible: false,
    amount: 0.094,
    rolled: "HEADS",
    currency: "ETH",
  },
  render: (args) => (
    <div className="w-[302px] h-[160px] relative rounded-[16px] overflow-hidden">
      <GameResultWindow {...args} />
    </div>
  ),
}

export const WinLight: Story = {
  ...Template,
  args: {
    ...Template.args,
    isVisible: true,
    isWin: true,
    payout: 1.094,
  },
  render: (args) => (
    <div className="light">
      <div className="w-[302px] h-[160px] relative rounded-[16px] overflow-hidden">
        <GameResultWindow {...args} />
      </div>
    </div>
  ),
}

export const LossLight: Story = {
  ...Template,
  args: {
    ...Template.args,
    isVisible: true,
    isWin: false,
    payout: 0,
    rolled: "TAILS",
  },
  render: (args) => (
    <div className="light">
      <div className="w-[302px] h-[160px] relative rounded-[16px] overflow-hidden">
        <GameResultWindow {...args} />
      </div>
    </div>
  ),
}

export const WinDark: Story = {
  ...Template,
  parameters: {
    backgrounds: { default: "dark" },
  },
  args: {
    ...Template.args,
    isVisible: true,
    isWin: true,
    payout: 1.094,
  },
  render: (args) => (
    <div className="dark">
      <div className="w-[302px] h-[160px] relative rounded-[16px] overflow-hidden">
        <GameResultWindow {...args} />
      </div>
    </div>
  ),
}

export const LossDark: Story = {
  ...Template,
  parameters: {
    backgrounds: { default: "dark" },
  },
  args: {
    ...Template.args,
    isVisible: true,
    isWin: false,
    payout: 0,
    rolled: "TAILS",
  },
  render: (args) => (
    <div className="dark">
      <div className="w-[302px] h-[160px] relative rounded-[16px] overflow-hidden">
        <GameResultWindow {...args} />
      </div>
    </div>
  ),
}
</file>

<file path="examples/mini-app/src/components/game/GameResultWindow.tsx">
import winIcon from "../../assets/game/game-result/win-icon.svg"
import lossIcon from "../../assets/game/game-result/loss-icon.svg"
import winBgWebp from "../../assets/game/game-result/win-bg.webp"
import lossBgWebp from "../../assets/game/game-result/loss-bg.webp"
import { useEffect } from "react"

const images = {
  win: {
    bg: winBgWebp,
    icon: winIcon,
  },
  loss: {
    bg: lossBgWebp,
    icon: lossIcon,
  },
} as const

interface GameResultWindowProps {
  isWin?: boolean
  isVisible: boolean
  amount: number
  payout?: number
  currency: string
  rolled: string
  className?: string
}

export function GameResultWindow({
  isWin = false,
  isVisible,
  amount,
  payout = 0,
  currency,
  rolled,
  className,
}: GameResultWindowProps) {
  const resultType = isWin ? "win" : "loss"
  const currentImages = images[resultType]
  const sign = isWin ? "+" : "-"

  useEffect(() => {
    const preloadImg = (imgSrc: string) => {
      const img = new Image()
      img.src = imgSrc
    }

    Object.values(images).forEach(({ bg, icon }) => {
      preloadImg(bg)
      preloadImg(icon)
    })
  }, [])

  if (!isVisible) {
    return null
  }

  return (
    <div
      className={`w-full h-full flex flex-col items-center py-[12px] px-[42px] absolute left-0 top-0 text-white ${className}`}
    >
      <img
        src={currentImages.bg}
        className="absolute left-0 top-0 w-full h-full"
        alt={`${resultType} background`}
      />

      <div className="flex flex-col items-center gap-[8px] text-center relative">
        <div className="w-[48px] h-[44px] flex items-center justify-center bg-game-result-icon-bg relative rounded-[6px]">
          <img
            className="absolute"
            src={currentImages.icon}
            alt={`${resultType} icon`}
          />
        </div>
        <p className="text-[16px] leading-[150%] font-bold">
          {sign}
          {amount}
          <span className="uppercase"> {currency}</span>
        </p>
        <p className="text-[14px] leading-[157%] font-semibold">
          Payout: {payout}
          <span className="uppercase"> {currency}</span>
        </p>
        <p className="text-[12px] leading-[167%] font-medium uppercase">
          Draw: {rolled}
        </p>
      </div>
    </div>
  )
}
</file>

<file path="examples/mini-app/src/components/ui/card.tsx">
import * as React from "react"

import { cn } from "../../lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground",
        "flex flex-col rounded-[20px]",
        "px-3 py-4",
        "gap-3",
        "w-[328px] h-[512px]",
        "border-border",
        className,
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn("flex flex-col space-y-1.5 h-[44px] w-[304px]", className)}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"h3">) {
  return (
    <h3
      data-slot="card-title"
      className={cn("text-lg font-bold leading-none tracking-tight", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"p">) {
  return (
    <p
      data-slot="card-description"
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className,
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div data-slot="card-content" className={cn("", className)} {...props} />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}
</file>

<file path="examples/mini-app/src/components/ui/label.tsx">
import * as LabelPrimitive from "@radix-ui/react-label"
import * as React from "react"

import { cn } from "../../lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className,
      )}
      {...props}
    />
  )
}

export { Label }
</file>

<file path="examples/mini-app/src/components/ui/scroll-area.tsx">
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"
import * as React from "react"

import { cn } from "../../lib/utils"

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn("relative", className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  )
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className,
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  )
}

export { ScrollArea, ScrollBar }
</file>

<file path="examples/node/src/functionalities/placeBet.ts">
import {
  type ApproveResult,
  type BetRequirements,
  BetSwirlError,
  CASINO_GAME_TYPE,
  type CasinoChain,
  type CasinoGame,
  type CasinoGameToken,
  type CasinoPlacedBet,
  type CasinoRolledBet,
  type CasinoToken,
  type ChoiceInput,
  CoinToss,
  type CoinTossChoiceInput,
  Dice,
  type DiceChoiceInput,
  FORMAT_TYPE,
  GAS_PRICE_TYPE,
  Keno,
  type KenoChoiceInput,
  type NormalCasinoPlacedBet,
  type NormalGameChoiceInput,
  Roulette,
  type RouletteChoiceInput,
  WEIGHTED_CASINO_GAME_TYPES,
  type WeightedCasinoPlacedBet,
  type WeightedGameChoiceInput,
  type WeightedGameConfiguration,
  Wheel,
  type WheelChoiceInput,
  bigIntFormatter,
  casinoChains,
  chainById,
  formatRawAmount,
  formatTxnUrl,
  getBetSwirlBetUrl,
  labelCasinoGameByType,
} from "@betswirl/sdk-core";
import { WagmiBetSwirlClient, initWagmiBetSwirlClient } from "@betswirl/wagmi-provider";
import { checkbox, input, select } from "@inquirer/prompts";
import { getBalance } from "@wagmi/core";
import chalk from "chalk";
import { type Hash, type Hex, type TransactionReceipt, parseUnits, zeroAddress } from "viem";
import { checkEnvVariables, getWagmiConfigFromCasinoChain } from "../../utils";
let wagmiBetSwirlClient: WagmiBetSwirlClient;

export async function startPlaceBetProcess() {
  try {
    // 0. Check if env variables are set
    checkEnvVariables();
    // 1. Select chain
    const selectedChain = await _selectChain();
    // 2. Select game
    const selectedGame = await _selectGame(selectedChain);
    // 3. Select token
    const selectedToken = await _selectToken(selectedGame);
    // 4. Get token info (user balance, house edge, etc)
    const { gameToken, userTokenBalance, userGasBalance } = await _getTokenInfo(
      selectedToken,
      selectedGame,
    );
    // 5. Select input
    const selectedInput = await _selectInput(gameToken);
    // 6. Get bet requirements
    const betRequirements = await _getBetRequirements(selectedInput, gameToken);
    // 7. Get bet count
    const betCount = await _selectBetCount(betRequirements);
    // 8. Get bet amount
    const betAmount = await _selectBetAmount(
      betRequirements,
      gameToken,
      betCount,
      userTokenBalance,
      userGasBalance,
    );
    // 9. Place bet
    const placedBet = await _placeBet(gameToken, selectedInput, betCount, betAmount);

    // 10. Wait for the roll
    if (WEIGHTED_CASINO_GAME_TYPES.includes(placedBet.game)) {
      await _waitWeightedRoll(
        placedBet as WeightedCasinoPlacedBet,
        (selectedInput as WeightedGameChoiceInput).config,
        gameToken.affiliateHouseEdge,
      );
    } else {
      await _waitRoll(placedBet as NormalCasinoPlacedBet);
    }
  } catch (error) {
    if (error instanceof BetSwirlError) {
      console.error(
        chalk.red(
          `[${error.code}] BetSwirl error occured while placing bet: ${
            error.message
          } ${JSON.stringify(error.context, bigIntFormatter)}`,
        ),
      );
    } else {
      console.error(chalk.red("Node example error occured:", error));
    }
  }
}

async function _selectChain(): Promise<CasinoChain> {
  const selectedChain = await select({
    message: "Select a chain on which to bet",
    loop: false,
    choices: casinoChains.map((c) => ({ name: c.viemChain.name, value: c })),
  });
  const wagmiConfig = getWagmiConfigFromCasinoChain(selectedChain);
  wagmiBetSwirlClient = initWagmiBetSwirlClient(wagmiConfig, {
    chainId: selectedChain.id,
    affiliate: process.env.AFFILIATE_ADDRESS as Hex,
    gasPriceType: GAS_PRICE_TYPE.FAST,
  });
  return selectedChain;
}

async function _selectGame(selectedChain: CasinoChain): Promise<CasinoGame> {
  const casinoGames = await wagmiBetSwirlClient.getCasinoGames(false, selectedChain.id);
  const selectedGame = await select({
    message: "Select a game",
    loop: false,
    choices: casinoGames
      .map((g) => ({
        name: g.label,
        value: g,
        disabled: g.paused,
      }))
      .filter((g) => g.value.game !== CASINO_GAME_TYPE.CUSTOM_WEIGHTED_GAME),
  });
  return selectedGame;
}

async function _selectToken(selectedGame: CasinoGame): Promise<CasinoToken> {
  const tokens = await wagmiBetSwirlClient.getCasinoTokens(false, selectedGame.chainId);
  const selectedToken = await select({
    message: "Select a token",
    loop: false,
    choices: tokens.map((g) => ({
      name: g.symbol,
      value: g,
      disabled: g.paused,
    })),
  });
  return selectedToken;
}

async function _getTokenInfo(
  token: CasinoToken,
  casinoGame: CasinoGame,
): Promise<{
  gameToken: CasinoGameToken;
  userTokenBalance: bigint;
  userGasBalance: bigint;
}> {
  const userAddress = wagmiBetSwirlClient.betSwirlWallet.getAccount()!.address;
  const tokenInfo = await wagmiBetSwirlClient.getCasinoGameToken(token, casinoGame.game);
  const userGasBalanceData = await getBalance(wagmiBetSwirlClient.wagmiConfig, {
    address: userAddress,
    chainId: tokenInfo.chainId,
  });
  let userTokenBalance = 0n;
  if (token.address === zeroAddress) {
    userTokenBalance = userGasBalanceData.value;
  } else {
    userTokenBalance = (
      await getBalance(wagmiBetSwirlClient.wagmiConfig, {
        address: userAddress,
        token: token.address,
        chainId: tokenInfo.chainId,
      })
    ).value;
  }

  console.log(
    chalk.blue(
      `House edge: ${tokenInfo.affiliateHouseEdgePercent}%\nYour gas balance: ${formatRawAmount(
        userGasBalanceData.value,
        userGasBalanceData.decimals,
        FORMAT_TYPE.PRECISE,
      )} ${userGasBalanceData.symbol}\nYour token balance: ${formatRawAmount(
        userTokenBalance,
        tokenInfo.decimals,
        FORMAT_TYPE.PRECISE,
      )} ${tokenInfo.symbol}`,
    ),
  );

  return {
    gameToken: tokenInfo,
    userTokenBalance,
    userGasBalance: userGasBalanceData.value,
  };
}

async function _selectInput(
  gameToken: CasinoGameToken,
): Promise<NormalGameChoiceInput | WeightedGameChoiceInput> {
  let input: NormalGameChoiceInput | WeightedGameChoiceInput;

  switch (gameToken.game) {
    case CASINO_GAME_TYPE.DICE:
      input = await select({
        message: "Select a number",
        loop: false,
        choices: Dice.getChoiceInputs(gameToken.affiliateHouseEdge).map((i) => ({
          name: `${i.label} (x${i.formattedNetMultiplier}) - ${i.winChancePercent}% chance to win`,
          value: i,
        })),
      });
      break;
    case CASINO_GAME_TYPE.COINTOSS:
      input = await select({
        message: "Select a face",
        loop: false,
        choices: CoinToss.getChoiceInputs(gameToken.affiliateHouseEdge).map((i) => ({
          name: `${i.label} (x${i.formattedNetMultiplier}) - ${i.winChancePercent}% chance to win`,
          value: i,
        })),
      });
      break;
    case CASINO_GAME_TYPE.ROULETTE: {
      const inputChoices = await checkbox({
        message: "Select a number or a bundle of numbers (space bar to select)",
        loop: false,
        required: true,
        choices: Roulette.getChoiceInputs(gameToken.affiliateHouseEdge).map((i) => ({
          name: `${i.label} (x${i.formattedNetMultiplier}) - ${i.winChancePercent}% chance to win`,
          value: i,
        })),
      });
      // Combine all the choices into one
      input = Roulette.combineChoiceInputs(inputChoices, gameToken.affiliateHouseEdge);
      if (inputChoices.length > 1) {
        console.log(
          chalk.blue(
            `Selected numbers: ${input.label}\nMultiplier: ${input.formattedNetMultiplier}x\nChance to win: ${input.winChancePercent}%`,
          ),
        );
      }
      break;
    }
    case CASINO_GAME_TYPE.KENO: {
      // Get Keno config for the selected token
      const kenoConfig = await wagmiBetSwirlClient.getKenoConfiguration(
        gameToken,
        gameToken.chainId,
      );
      input = await select({
        message: "Select some balls",
        loop: false,
        choices: Keno.getChoiceInputs(kenoConfig, gameToken.affiliateHouseEdge).map((i) => ({
          name: `${i.label} (${i.winChancePercent
            .map(
              (chance, index) =>
                `${i.formattedNetMultiplier?.[index]}x - ${chance.toFixed(2)}% to win ${index !== i.winChancePercent.length - 1 ? "|" : ""}`,
            )
            .join("\n")})`,
          value: i,
        })),
      });
      break;
    }
    // Wheel
    default: {
      input = await select({
        message: "Select a configuration",
        loop: false,
        // You could bring your own configurations here by passing customConfigurations in getChoiceInputs
        choices: Wheel.getChoiceInputs(gameToken.chainId, gameToken.affiliateHouseEdge).map(
          (i) => ({
            name: `${i.label} (${i.winChancePercent
              .map(
                (chance, index) =>
                  `${i.formattedNetMultiplier?.[index]}x - ${chance.toFixed(2)}% to win ${index !== i.winChancePercent.length - 1 ? "|" : ""}`,
              )
              .join("\n")})`,
            value: i,
          }),
        ),
      });
    }
  }
  return input;
}

async function _getBetRequirements(choiceInput: ChoiceInput, gameToken: CasinoGameToken) {
  const betRequirements = await wagmiBetSwirlClient.getBetRequirements(
    gameToken,
    choiceInput.multiplier,
    choiceInput.game,
  );
  return betRequirements;
}

async function _selectBetCount(betRequirements: BetRequirements) {
  const betCount = await input({
    message: `Enter a bet count between 1 and ${betRequirements.maxBetCount}`,
    default: "1",
    validate: (input) => {
      const roundedNumber = Math.round(Number(input));
      if (roundedNumber < 1 || Number(betRequirements.maxBetCount) < roundedNumber) {
        return `Bet count must be between 1 and ${betRequirements.maxBetCount}`;
      }
      return true;
    },
    transformer: (input) => {
      return Math.round(Number(input)).toString();
    },
  });
  return Number(betCount);
}

async function _selectBetAmount(
  betRequirements: BetRequirements,
  casinoGameToken: CasinoGameToken,
  betCount: number,
  userTokenBalance: bigint,
  userGasBalance: bigint,
) {
  const chainlinkVrfCostEstimation = await wagmiBetSwirlClient.getChainlinkVrfCost(
    casinoGameToken.game,
    casinoGameToken.address,
    betCount,
    undefined, // We let the SDK manage the gas price itself
    undefined, // We already define the gas price type in the client options
    casinoGameToken.chainId,
  );
  const userAddress = wagmiBetSwirlClient.betSwirlWallet.getAccount()!.address;
  const chain = chainById[casinoGameToken.chainId];
  const gasDecimals = chain.nativeCurrency.decimals;
  const gasSymbol = chain.nativeCurrency.symbol;
  // TODO Add simulate gas fee (function does not yet exist in sdk)
  const gasBalanceRemainingAfterFees = userGasBalance - chainlinkVrfCostEstimation;
  // User needs to have at least 1 gwei for each betCount after substracting gas fees. For production apps, it's better to keep a buffer because VRF and gas fee can change.
  if (gasBalanceRemainingAfterFees < BigInt(betCount)) {
    throw Error(
      `You don't have enough gas to pay VRF and gas fees, please send at least ${formatRawAmount(
        BigInt(betCount) - gasBalanceRemainingAfterFees,
        gasDecimals,
        FORMAT_TYPE.FULL_PRECISE,
      )} ${gasSymbol} to ${userAddress}`,
    );
  }
  // If token is gas balance, substract the fees
  const availableTokenBalance =
    casinoGameToken.address === zeroAddress ? gasBalanceRemainingAfterFees : userTokenBalance;
  // Take into consideration the max bet amount for the balance user but also max bet amount of the bet
  const maxAmountPerBetFormatted = Math.min(
    Number(
      formatRawAmount(
        availableTokenBalance / BigInt(betCount),
        casinoGameToken.decimals,
        FORMAT_TYPE.FULL_PRECISE,
      ),
    ),
    Number(
      formatRawAmount(
        betRequirements.maxBetAmount,
        casinoGameToken.decimals,
        FORMAT_TYPE.FULL_PRECISE,
      ),
    ),
  );
  // User needs to have at least 1 gwei of token for each betCount.
  if (maxAmountPerBetFormatted <= 0) {
    throw Error(
      `You don't have enough token to place the bet, please send at least ${formatRawAmount(
        BigInt(betCount) - availableTokenBalance,
        casinoGameToken.decimals,
        FORMAT_TYPE.FULL_PRECISE,
      )} ${casinoGameToken.symbol} to ${userAddress}`,
    );
  }
  console.log(
    chalk.blue(
      `VRF cost estimation: ${formatRawAmount(
        chainlinkVrfCostEstimation,
        gasDecimals,
        FORMAT_TYPE.PRECISE,
      )} ${gasSymbol} \nYour token balance: ${formatRawAmount(
        userTokenBalance,
        casinoGameToken.decimals,
        FORMAT_TYPE.PRECISE,
      )} ${casinoGameToken.symbol}\nYour gas balance: ${formatRawAmount(
        userGasBalance,
        gasDecimals,
        FORMAT_TYPE.PRECISE,
      )} ${gasSymbol}\nBet count: ${betCount}`,
    ),
  );
  const betAmountFormatted = await input({
    message: `Enter a bet amount up to ${maxAmountPerBetFormatted} ${casinoGameToken.symbol}`,
    validate: (_input) => {
      const input = Number(_input);
      if (input <= 0 || input > maxAmountPerBetFormatted) {
        return "Not valid amount";
      }
      return true;
    },
  });
  return parseUnits(betAmountFormatted, casinoGameToken.decimals);
}

async function _placeBet(
  casinoGameToken: CasinoGameToken,
  inputChoice: NormalGameChoiceInput | WeightedGameChoiceInput,
  betCount: number,
  betAmount: bigint,
): Promise<CasinoPlacedBet> {
  const commonParams = {
    betCount,
    betAmount,
    token: casinoGameToken,
  };
  const callbacks = {
    onApprovePending: (_tx: Hash, _result: ApproveResult) => {
      console.log(chalk.blue(`⌛ ${casinoGameToken.symbol} is approving...`));
    },
    onApproved: (receipt: TransactionReceipt, _result: ApproveResult) => {
      console.log(
        chalk.green(
          `✅ ${casinoGameToken.symbol} has been approved successfully!\nApproval txn: ${formatTxnUrl(
            receipt.transactionHash,
            casinoGameToken.chainId,
          )}`,
        ),
      );
    },
    onBetPlacedPending: (_tx: Hash) => {
      console.log(chalk.blue("⌛ Waiting the bet to be placed..."));
    },
  };
  let placedBetData: {
    receipt: TransactionReceipt;
    placedBet: CasinoPlacedBet;
    weightedGameConfig?: WeightedGameConfiguration;
  };
  if (inputChoice.game === CASINO_GAME_TYPE.DICE) {
    const diceCap = (inputChoice as DiceChoiceInput).value;
    placedBetData = await wagmiBetSwirlClient.playDice(
      { ...commonParams, cap: diceCap },
      undefined,
      callbacks,
      casinoGameToken.chainId,
    );
  } else if (inputChoice.game === CASINO_GAME_TYPE.COINTOSS) {
    const coinTossFace = (inputChoice as CoinTossChoiceInput).value;
    placedBetData = await wagmiBetSwirlClient.playCoinToss(
      { ...commonParams, face: coinTossFace },
      undefined,
      callbacks,
      casinoGameToken.chainId,
    );
  } else if (inputChoice.game === CASINO_GAME_TYPE.ROULETTE) {
    const rouletteNumbers = (inputChoice as RouletteChoiceInput).value;
    placedBetData = await wagmiBetSwirlClient.playRoulette(
      { ...commonParams, numbers: rouletteNumbers },
      undefined,
      callbacks,
      casinoGameToken.chainId,
    );
  } else if (inputChoice.game === CASINO_GAME_TYPE.KENO) {
    const kenoChoice = inputChoice as KenoChoiceInput;
    placedBetData = await wagmiBetSwirlClient.playKeno(
      { ...commonParams, balls: kenoChoice.value, kenoConfig: kenoChoice.config },
      undefined,
      callbacks,
      casinoGameToken.chainId,
    );
  }
  // Wheel
  else {
    const weightedGameChoice = inputChoice as WheelChoiceInput;
    placedBetData = await wagmiBetSwirlClient.playWheel(
      { ...commonParams, weightedGameConfig: weightedGameChoice.config },
      undefined,
      callbacks,
      casinoGameToken.chainId,
    );
  }
  console.log(
    chalk.green(
      `✅ Your ${
        labelCasinoGameByType[casinoGameToken.game]
      } bet has been placed successfully!\n Place bet txn: ${formatTxnUrl(
        placedBetData.receipt.transactionHash,
        casinoGameToken.chainId,
      )}`,
    ),
  );
  return placedBetData.placedBet;
}

async function _waitRoll(placedBet: NormalCasinoPlacedBet) {
  console.log(chalk.blue("⌛ Waiting the bet to be rolled..."));
  const rolledBetData = await wagmiBetSwirlClient.waitRolledBet(placedBet, {
    timeout: 300000, //5min
    pollingInterval: process.env.RPC_URL ? 500 : 2500,
    formatType: FORMAT_TYPE.FULL_PRECISE,
  });

  const rolledBet = rolledBetData.rolledBet;
  _displayRolledBet(rolledBet);
}

async function _waitWeightedRoll(
  placedBet: WeightedCasinoPlacedBet,
  weightedGameConfig: WeightedGameConfiguration,
  houseEdge: number,
) {
  console.log(chalk.blue("⌛ Waiting the bet to be rolled..."));
  const rolledBetData = await wagmiBetSwirlClient.waitRolledBet(
    placedBet,
    {
      timeout: 300000, //5min
      pollingInterval: process.env.RPC_URL ? 500 : 2500,
      formatType: FORMAT_TYPE.FULL_PRECISE,
    },
    weightedGameConfig,
    houseEdge,
  );

  const rolledBet = rolledBetData.rolledBet;
  _displayRolledBet(rolledBet);
}

function _displayRolledBet(rolledBet: CasinoRolledBet) {
  const chain = chainById[rolledBet.chainId];
  const commonMessage = chalk.blue(
    `Payout: ${rolledBet.formattedPayout} ${
      rolledBet.token.symbol
    }\nTotal bet amount: ${rolledBet.formattedRollTotalBetAmount} ${rolledBet.token.symbol}\nBet count: ${rolledBet.rollBetCount}\nCharged VRF cost: ${formatRawAmount(
      rolledBet.chargedVRFCost,
      chain.nativeCurrency.decimals,
      FORMAT_TYPE.PRECISE,
    )} ${chain.nativeCurrency.symbol}\nRolled: ${JSON.stringify(
      rolledBet.decodedRolled,
    )}\nRoll txn: ${formatTxnUrl(rolledBet.rollTxnHash, rolledBet.chainId)}\nBetSwirl url: ${getBetSwirlBetUrl(rolledBet.id, rolledBet.game, rolledBet.chainId)}`,
  );
  // Win
  if (rolledBet.isWin) {
    console.log(
      chalk.green(
        `🥳 Congrats you won ${rolledBet.formattedBenefit} ${rolledBet.token.symbol} (x${rolledBet.formattedPayoutMultiplier})\n`,
        commonMessage,
      ),
    );
  }
  // Loss
  else {
    console.log(
      chalk.red(
        `😔 Arf, you lost ${rolledBet.formattedBenefit} ${rolledBet.token.symbol} (x${rolledBet.formattedPayoutMultiplier})\n`,
        commonMessage,
      ),
    );
  }
}
</file>

<file path="examples/node/package.json">
{
  "name": "@examples/node",
  "private": true,
  "repository": {
    "type": "git",
    "url": "https://github.com/chainhackers/sdk.git",
    "directory": "examples/node"
  },
  "version": "1.0.0",
  "description": "",
  "main": "src/index.ts",
  "scripts": {
    "start": "tsx ./src/index.ts"
  },
  "type": "module",
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@apollo/client": "^3.12.11",
    "@betswirl/sdk-core": "^0.1.2-beta.3",
    "@betswirl/wagmi-provider": "^0.1.1",
    "@inquirer/prompts": "^7.3.1",
    "@wagmi/core": "^2.16.3",
    "viem": "^2.29.2"
  },
  "devDependencies": {
    "@types/node": "^22.13.1",
    "chalk": "^5.4.1",
    "dotenv": "^16.4.7",
    "tsx": "^4.19.2",
    "typescript": "^5.0.0"
  }
}
</file>

<file path="packages/core/src/data/casino.ts">
import type { Abi, Chain, Hex } from "viem";
import { coinTossAbi } from "../abis/v2/casino/cointoss";
import { diceAbi } from "../abis/v2/casino/dice";
import { kenoAbi } from "../abis/v2/casino/keno";
import { rouletteAbi } from "../abis/v2/casino/roulette";
import { weightedGameAbi } from "../abis/v2/casino/weightedGame";
import { chainByKey } from "./chains";

export const MAX_HOUSE_EGDE = 3500;
export const MAX_SDK_HOUSE_EGDE = 1000;

export type CasinoChainId = keyof typeof casinoChainById;

export type CasinoChain = {
  id: CasinoChainId;
  viemChain: Chain;
  options: {
    pollingInterval: number;
  };
  contracts: {
    bank: Hex;
    games: {
      [key in CASINO_GAME_TYPE]?: { address: Hex; abi: Abi };
    };
    leaderboard?: Hex;
    freebet?: Hex;
  };
  graphql: {
    endpoint: string;
    defaultEndpoint: string;
  };
  defaultAffiliate: Hex;
};

export enum CASINO_GAME_TYPE {
  COINTOSS = "coin-toss",
  DICE = "dice",
  ROULETTE = "roulette",
  KENO = "keno",
  WHEEL = "wheel",
  CUSTOM_WEIGHTED_GAME = "custom-weighted-game",
}

export type NORMAL_CASINO_GAME_TYPE =
  | CASINO_GAME_TYPE.COINTOSS
  | CASINO_GAME_TYPE.DICE
  | CASINO_GAME_TYPE.ROULETTE
  | CASINO_GAME_TYPE.KENO;

export type WEIGHTED_CASINO_GAME_TYPE =
  | CASINO_GAME_TYPE.WHEEL
  | CASINO_GAME_TYPE.CUSTOM_WEIGHTED_GAME;

export const NORMAL_GAME_TYPES = [
  CASINO_GAME_TYPE.COINTOSS,
  CASINO_GAME_TYPE.DICE,
  CASINO_GAME_TYPE.ROULETTE,
  CASINO_GAME_TYPE.KENO,
];

export const WEIGHTED_CASINO_GAME_TYPES = [
  CASINO_GAME_TYPE.WHEEL,
  CASINO_GAME_TYPE.CUSTOM_WEIGHTED_GAME,
];

export enum CASINO_GAME_SUBGRAPH_TYPE {
  COINTOSS = "CoinToss",
  DICE = "Dice",
  ROULETTE = "Roulette",
  KENO = "Keno",
  WHEEL = "Wheel",
  CUSTOM_WEIGHTED_GAME = "CUSTOM_WEIGHTED_GAME",
}

export enum CASINO_GAME_LABEL_TYPE {
  COINTOSS = "Coin Toss",
  DICE = "Dice",
  ROULETTE = "Roulette",
  KENO = "Keno",
  WHEEL = "Wheel",
  CUSTOM_WEIGHTED_GAME = "Custom game",
}

const COINTOSS_ROLL_ABI =
  "event Roll(uint256 indexed id, address indexed receiver, address indexed token, uint256 totalBetAmount, bool face, bool[] rolled, uint256 payout)";
const DICE_ROLL_ABI =
  "event Roll(uint256 indexed id, address indexed receiver, address indexed token, uint256 totalBetAmount, uint8 cap, uint8[] rolled, uint256 payout)";
const ROULETTE_ROLL_ABI =
  "event Roll(uint256 indexed id, address indexed receiver, address indexed token, uint256 totalBetAmount, uint40 numbers, uint8[] rolled, uint256 payout)";
const KENO_ROLL_ABI =
  "event Roll(uint256 indexed id, address indexed receiver, address indexed token, uint256 totalBetAmount, uint40 numbers, uint40[] rolled, uint256 payout)";
const WEIGHTED_GAME_ROLL_ABI =
  "event Roll(uint256 indexed id, address indexed receiver, address indexed token, uint256 totalBetAmount, uint32 configId, uint8[] rolled, uint256 payout)";

export const CASINO_GAME_ROLL_ABI: Record<
  CASINO_GAME_TYPE,
  | typeof COINTOSS_ROLL_ABI
  | typeof DICE_ROLL_ABI
  | typeof ROULETTE_ROLL_ABI
  | typeof KENO_ROLL_ABI
  | typeof WEIGHTED_GAME_ROLL_ABI
> = {
  [CASINO_GAME_TYPE.COINTOSS]: COINTOSS_ROLL_ABI,
  [CASINO_GAME_TYPE.DICE]: DICE_ROLL_ABI,
  [CASINO_GAME_TYPE.ROULETTE]: ROULETTE_ROLL_ABI,
  [CASINO_GAME_TYPE.KENO]: KENO_ROLL_ABI,
  [CASINO_GAME_TYPE.WHEEL]: WEIGHTED_GAME_ROLL_ABI,
  [CASINO_GAME_TYPE.CUSTOM_WEIGHTED_GAME]: WEIGHTED_GAME_ROLL_ABI,
};

const arbitrumSepoliaData: CasinoChain = {
  id: chainByKey.arbitrumSepolia.id,
  viemChain: chainByKey.arbitrumSepolia,
  options: {
    pollingInterval: 200,
  },
  contracts: {
    bank: "0x3ca54e047aE5f9141b49c6817aa7994CDc589d19",
    games: {
      [CASINO_GAME_TYPE.DICE]: {
        address: "0xF68762683515f6670Fe661bff4Fe469A1A459904",
        abi: diceAbi,
      },
      [CASINO_GAME_TYPE.COINTOSS]: {
        address: "0x0Ff6EEfc86a79aE2239399ceC4C826099391B046",
        abi: coinTossAbi,
      },
      [CASINO_GAME_TYPE.ROULETTE]: {
        address: "0x044c7E3Cd069d3e12D37686E92B85799E36fa7e4",
        abi: rouletteAbi,
      },
      [CASINO_GAME_TYPE.KENO]: {
        address: "0xA78465DE64F302568cbb869698413a60681d2Fe8",
        abi: kenoAbi,
      },
      [CASINO_GAME_TYPE.WHEEL]: {
        address: "0xd021018E82eE105Feb7f50a0534DC0a3e6776F32",
        abi: weightedGameAbi,
      },
      [CASINO_GAME_TYPE.CUSTOM_WEIGHTED_GAME]: {
        address: "0xd021018E82eE105Feb7f50a0534DC0a3e6776F32",
        abi: weightedGameAbi,
      },
    },
    leaderboard: "0xf8e7EE248BE53C8b428542E9bc498D78fea09Ee4",
    freebet: "0xBf34537E0648724713740267c72826A8f08ECadA",
  },
  graphql: {
    endpoint:
      "https://api.studio.thegraph.com/query/80936/betswirl-arbitrum-sepolia-v2/version/latest",
    defaultEndpoint:
      "https://api.studio.thegraph.com/query/80936/betswirl-arbitrum-sepolia-v2/version/latest",
  },
  defaultAffiliate: "0x057BcBF736DADD774A8A45A185c1697F4cF7517D",
};

const avalancheFujiData: CasinoChain = {
  id: chainByKey.avalancheFuji.id,
  viemChain: chainByKey.avalancheFuji,
  options: {
    pollingInterval: 500,
  },
  contracts: {
    bank: "0x25bED5A341218Df801a64951d02d3c968E84a6d4",
    games: {
      [CASINO_GAME_TYPE.DICE]: {
        address: "0xE25b810B1A3d7DCff051abcdc109466d32b4F2a1",
        abi: diceAbi,
      },
      [CASINO_GAME_TYPE.COINTOSS]: {
        address: "0x5856B199ae1c51296cB17d29D65Da702FE0DA12a",
        abi: coinTossAbi,
      },
      [CASINO_GAME_TYPE.ROULETTE]: {
        address: "0x91f6A418E2B4535f1828836d2DEa93E99d49836e",
        abi: rouletteAbi,
      },
      [CASINO_GAME_TYPE.KENO]: {
        address: "0xEC5800455EeFE3A193778747EeAfF38221bFdFe4",
        abi: kenoAbi,
      },
      [CASINO_GAME_TYPE.WHEEL]: {
        address: "0xEaFBA4d8a062b4C41775FED9Ced52633c89DFca0",
        abi: weightedGameAbi,
      },
      [CASINO_GAME_TYPE.CUSTOM_WEIGHTED_GAME]: {
        address: "0xEaFBA4d8a062b4C41775FED9Ced52633c89DFca0",
        abi: weightedGameAbi,
      },
    },
    leaderboard: "0xbB613c35D539eE86AB600e376117887A006d028f",
    freebet: "0xf341aa5e54E9536BDac0928d4Dbba3E09A8f774E",
  },
  graphql: {
    endpoint: "https://api.studio.thegraph.com/query/80936/betswirl-fuji-v2/version/latest",
    defaultEndpoint: "https://api.studio.thegraph.com/query/80936/betswirl-fuji-v2/version/latest",
  },
  defaultAffiliate: "0x057BcBF736DADD774A8A45A185c1697F4cF7517D",
};

const polygonAmoyData: CasinoChain = {
  id: chainByKey.polygonAmoy.id,
  viemChain: chainByKey.polygonAmoy,
  options: {
    pollingInterval: 500,
  },
  contracts: {
    bank: "0x89D47048152581633579450DC4888C931CD4c28C",
    games: {
      [CASINO_GAME_TYPE.DICE]: {
        address: "0xE14E752c6Ef78fB54da5A28ff7C9f808534603e9",
        abi: diceAbi,
      },
      [CASINO_GAME_TYPE.COINTOSS]: {
        address: "0xC2fc743768A1a842dD2CfA121359b8545B9876cA",
        abi: coinTossAbi,
      },
      [CASINO_GAME_TYPE.ROULETTE]: {
        address: "0x5F628ccd0D5929B16fF6E239D8BB8C81F1b0feD9",
        abi: rouletteAbi,
      },
      [CASINO_GAME_TYPE.KENO]: {
        address: "0x77A654D0895baF09c42314FBb4b18822Ec3c1DD0",
        abi: kenoAbi,
      },
      [CASINO_GAME_TYPE.WHEEL]: {
        address: "0xd300a3757dDBb3Eafb8fb3e401a5eb60e4a571b1",
        abi: weightedGameAbi,
      },
      [CASINO_GAME_TYPE.CUSTOM_WEIGHTED_GAME]: {
        address: "0xd300a3757dDBb3Eafb8fb3e401a5eb60e4a571b1",
        abi: weightedGameAbi,
      },
    },
    leaderboard: "0x143DB52C913143345B6a24D8f22f1a8BEaC19e16",
    freebet: "0xfBE92f62bd32B3b6c2335D757049f190752f5292",
  },
  graphql: {
    endpoint: "https://api.studio.thegraph.com/query/80936/betswirl-amoy-v2/version/latest",
    defaultEndpoint: "https://api.studio.thegraph.com/query/80936/betswirl-amoy-v2/version/latest",
  },
  defaultAffiliate: "0x057BcBF736DADD774A8A45A185c1697F4cF7517D",
};

const baseSepoliaData: CasinoChain = {
  id: chainByKey.baseSepolia.id,
  viemChain: chainByKey.baseSepolia,
  options: {
    pollingInterval: 200,
  },
  contracts: {
    bank: "0x637D401554875a330264e910A3778DAf549F2021",
    games: {
      [CASINO_GAME_TYPE.DICE]: {
        address: "0x76e982a4823bEd3ed77d8E0b4c3FAa616385a286",
        abi: diceAbi,
      },
      [CASINO_GAME_TYPE.COINTOSS]: {
        address: "0x431c7E0856C0DEf20e50A809cBDdEcF5F8dD6142",
        abi: coinTossAbi,
      },
      [CASINO_GAME_TYPE.ROULETTE]: {
        address: "0x441b191bc9253ab4E16D7d90E99650bb71D0E4f4",
        abi: rouletteAbi,
      },
      [CASINO_GAME_TYPE.KENO]: {
        address: "0xb5C9f183C1E5D2e9d0CA0679D7149ea075E0e82F",
        abi: kenoAbi,
      },
      [CASINO_GAME_TYPE.WHEEL]: {
        address: "0x011e537eB2313fc0096a87AA4ACC3750f712Ce2D",
        abi: weightedGameAbi,
      },
      [CASINO_GAME_TYPE.CUSTOM_WEIGHTED_GAME]: {
        address: "0x011e537eB2313fc0096a87AA4ACC3750f712Ce2D",
        abi: weightedGameAbi,
      },
    },
    leaderboard: "0xd60Fac02E78e2a4E37501053ab3E822E330dd970",
    freebet: "0xcBa83991C4D6A8c75FA7Aac02AAE202Ed0E44224",
  },
  graphql: {
    endpoint: "https://api.studio.thegraph.com/query/80936/betswirl-base-sepolia-v2/version/latest",
    defaultEndpoint:
      "https://api.studio.thegraph.com/query/80936/betswirl-base-sepolia-v2/version/latest",
  },
  defaultAffiliate: "0x057BcBF736DADD774A8A45A185c1697F4cF7517D",
};

const arbitrumData: CasinoChain = {
  id: chainByKey.arbitrum.id,
  viemChain: chainByKey.arbitrum,
  options: {
    pollingInterval: 200,
  },
  contracts: {
    bank: "0x8FB3110015FBCAA469ee45B64dcd2BdF544B9CFA",
    games: {
      [CASINO_GAME_TYPE.DICE]: {
        address: "0xAa4D2931a9fE14c3dec8AC3f12923Cbb535C0e5f",
        abi: diceAbi,
      },
      [CASINO_GAME_TYPE.COINTOSS]: {
        address: "0xC3Dff2489F8241729B824e23eD01F986fcDf8ec3",
        abi: coinTossAbi,
      },
      [CASINO_GAME_TYPE.ROULETTE]: {
        address: "0x6678e3B4AB2a8C8Cdd068F132C21293CcBda33cb",
        abi: rouletteAbi,
      },
      [CASINO_GAME_TYPE.KENO]: {
        address: "0xc3428E4FEb5C770Db51DCb9B1C08223B10994a89",
        abi: kenoAbi,
      },
      [CASINO_GAME_TYPE.WHEEL]: {
        address: "0xdec2A4f75c5fAE4a09c83975681CE1Dd1dff764b",
        abi: weightedGameAbi,
      },
      [CASINO_GAME_TYPE.CUSTOM_WEIGHTED_GAME]: {
        address: "0xdec2A4f75c5fAE4a09c83975681CE1Dd1dff764b",
        abi: weightedGameAbi,
      },
    },
    freebet: "0x7a1EFD33f41150E3247F14209b2a733bc6B1cb7a",
    leaderboard: "0x0E5C8EA20a1EB26e5dDE5AFab5279F546dB92a79",
  },
  graphql: {
    endpoint:
      "https://gateway.thegraph.com/api/{key}/deployments/id/QmWFXojReSDay6LBfkvgqqsfu11QCrNwQnSa1j3DgZT17i",
    defaultEndpoint: "https://api.studio.thegraph.com/query/1726/betswirl-arbitrum-one/v2.2.0",
  },
  defaultAffiliate: "0xf14C79a7fA22c1f97C779F573c9bF39b6b43381c",
};

const avalancheData: CasinoChain = {
  id: chainByKey.avalanche.id,
  viemChain: chainByKey.avalanche,
  options: {
    pollingInterval: 500,
  },
  contracts: {
    bank: "0x8FB3110015FBCAA469ee45B64dcd2BdF544B9CFA",
    games: {
      [CASINO_GAME_TYPE.DICE]: {
        address: "0xAa4D2931a9fE14c3dec8AC3f12923Cbb535C0e5f",
        abi: diceAbi,
      },
      [CASINO_GAME_TYPE.COINTOSS]: {
        address: "0xC3Dff2489F8241729B824e23eD01F986fcDf8ec3",
        abi: coinTossAbi,
      },
      [CASINO_GAME_TYPE.ROULETTE]: {
        address: "0x6678e3B4AB2a8C8Cdd068F132C21293CcBda33cb",
        abi: rouletteAbi,
      },
      [CASINO_GAME_TYPE.KENO]: {
        address: "0xc3428E4FEb5C770Db51DCb9B1C08223B10994a89",
        abi: kenoAbi,
      },
      [CASINO_GAME_TYPE.WHEEL]: {
        address: "0xdec2A4f75c5fAE4a09c83975681CE1Dd1dff764b",
        abi: weightedGameAbi,
      },
      [CASINO_GAME_TYPE.CUSTOM_WEIGHTED_GAME]: {
        address: "0xdec2A4f75c5fAE4a09c83975681CE1Dd1dff764b",
        abi: weightedGameAbi,
      },
    },
    freebet: "0x7a1EFD33f41150E3247F14209b2a733bc6B1cb7a",
    leaderboard: "0x0E5C8EA20a1EB26e5dDE5AFab5279F546dB92a79",
  },
  graphql: {
    endpoint:
      "https://gateway.thegraph.com/api/{key}/deployments/id/QmYDbKdk8cnYn6jkCgVagLvER73N9DcNc12dttyUKB6CGy",
    defaultEndpoint: "https://api.studio.thegraph.com/query/1726/betswirl-avalanche/v2.2.0",
  },
  defaultAffiliate: "0x1a75280F832280Af93f588f715a5Fb4Ca7918430",
};

const polygonData: CasinoChain = {
  id: chainByKey.polygon.id,
  viemChain: chainByKey.polygon,
  options: {
    pollingInterval: 1000,
  },
  contracts: {
    bank: "0x8FB3110015FBCAA469ee45B64dcd2BdF544B9CFA",
    games: {
      [CASINO_GAME_TYPE.DICE]: {
        address: "0xAa4D2931a9fE14c3dec8AC3f12923Cbb535C0e5f",
        abi: diceAbi,
      },
      [CASINO_GAME_TYPE.COINTOSS]: {
        address: "0xC3Dff2489F8241729B824e23eD01F986fcDf8ec3",
        abi: coinTossAbi,
      },
      [CASINO_GAME_TYPE.ROULETTE]: {
        address: "0x6678e3B4AB2a8C8Cdd068F132C21293CcBda33cb",
        abi: rouletteAbi,
      },
      [CASINO_GAME_TYPE.KENO]: {
        address: "0xc3428E4FEb5C770Db51DCb9B1C08223B10994a89",
        abi: kenoAbi,
      },
      [CASINO_GAME_TYPE.WHEEL]: {
        address: "0xdec2A4f75c5fAE4a09c83975681CE1Dd1dff764b",
        abi: weightedGameAbi,
      },
      [CASINO_GAME_TYPE.CUSTOM_WEIGHTED_GAME]: {
        address: "0xdec2A4f75c5fAE4a09c83975681CE1Dd1dff764b",
        abi: weightedGameAbi,
      },
    },
    freebet: "0x7a1EFD33f41150E3247F14209b2a733bc6B1cb7a",
    leaderboard: "0x0E5C8EA20a1EB26e5dDE5AFab5279F546dB92a79",
  },
  graphql: {
    endpoint:
      "https://gateway.thegraph.com/api/{key}/deployments/id/QmemAqAdjsbNQUtaMmJX54yS6Zg1uGx1bohWMYd3MV3Gmn",
    defaultEndpoint: "https://api.studio.thegraph.com/query/1726/betswirl-polygon/v2.2.0",
  },
  defaultAffiliate: "0xfA695010bF9e757a1abCd2703259F419217aa756",
};

const bscData: CasinoChain = {
  id: chainByKey.bsc.id,
  viemChain: chainByKey.bsc,
  options: {
    pollingInterval: 500,
  },
  contracts: {
    bank: "0x8FB3110015FBCAA469ee45B64dcd2BdF544B9CFA",
    games: {
      [CASINO_GAME_TYPE.DICE]: {
        address: "0xAa4D2931a9fE14c3dec8AC3f12923Cbb535C0e5f",
        abi: diceAbi,
      },
      [CASINO_GAME_TYPE.COINTOSS]: {
        address: "0xC3Dff2489F8241729B824e23eD01F986fcDf8ec3",
        abi: coinTossAbi,
      },
      [CASINO_GAME_TYPE.ROULETTE]: {
        address: "0x6678e3B4AB2a8C8Cdd068F132C21293CcBda33cb",
        abi: rouletteAbi,
      },
      [CASINO_GAME_TYPE.KENO]: {
        address: "0xc3428E4FEb5C770Db51DCb9B1C08223B10994a89",
        abi: kenoAbi,
      },
      [CASINO_GAME_TYPE.WHEEL]: {
        address: "0xdec2A4f75c5fAE4a09c83975681CE1Dd1dff764b",
        abi: weightedGameAbi,
      },
      [CASINO_GAME_TYPE.CUSTOM_WEIGHTED_GAME]: {
        address: "0xdec2A4f75c5fAE4a09c83975681CE1Dd1dff764b",
        abi: weightedGameAbi,
      },
    },
    freebet: "0x7a1EFD33f41150E3247F14209b2a733bc6B1cb7a",
    leaderboard: "0x0E5C8EA20a1EB26e5dDE5AFab5279F546dB92a79",
  },
  graphql: {
    endpoint:
      "https://gateway.thegraph.com/api/{key}/deployments/id/QmZq1G2kXuRWuzTkZivDxdEyHffkbmgMSqFcBmBnfYrVSS",
    defaultEndpoint: "https://api.studio.thegraph.com/query/1726/betswirl-bnb-chain/v2.2.0",
  },
  defaultAffiliate: "0xCD25325a6eF20BC5dF9bceAc0cC22a48d2e8f6eF",
};

const baseData: CasinoChain = {
  id: chainByKey.base.id,
  viemChain: chainByKey.base,
  options: {
    pollingInterval: 200,
  },
  contracts: {
    bank: "0x8FB3110015FBCAA469ee45B64dcd2BdF544B9CFA",
    games: {
      [CASINO_GAME_TYPE.DICE]: {
        address: "0xAa4D2931a9fE14c3dec8AC3f12923Cbb535C0e5f",
        abi: diceAbi,
      },
      [CASINO_GAME_TYPE.COINTOSS]: {
        address: "0xC3Dff2489F8241729B824e23eD01F986fcDf8ec3",
        abi: coinTossAbi,
      },
      [CASINO_GAME_TYPE.ROULETTE]: {
        address: "0x6678e3B4AB2a8C8Cdd068F132C21293CcBda33cb",
        abi: rouletteAbi,
      },
      [CASINO_GAME_TYPE.KENO]: {
        address: "0xc3428E4FEb5C770Db51DCb9B1C08223B10994a89",
        abi: kenoAbi,
      },
      [CASINO_GAME_TYPE.WHEEL]: {
        address: "0xdec2A4f75c5fAE4a09c83975681CE1Dd1dff764b",
        abi: weightedGameAbi,
      },
      [CASINO_GAME_TYPE.CUSTOM_WEIGHTED_GAME]: {
        address: "0xdec2A4f75c5fAE4a09c83975681CE1Dd1dff764b",
        abi: weightedGameAbi,
      },
    },
    freebet: "0x7a1EFD33f41150E3247F14209b2a733bc6B1cb7a",
    leaderboard: "0x0E5C8EA20a1EB26e5dDE5AFab5279F546dB92a79",
  },
  graphql: {
    endpoint:
      "https://gateway.thegraph.com/api/{key}/deployments/id/QmRdCiCM3gKcrdfiSxxRkqSLvS4ApU3iHKmPMhqiUWAuLK",
    defaultEndpoint: "https://api.studio.thegraph.com/query/1726/betswirl-base/v2.2.0",
  },
  defaultAffiliate: "0xBf1998e1F1cD52fBfb63e7E646bb39c091A7B70A",
};

export const casinoChainById = {
  [chainByKey.arbitrumSepolia.id]: arbitrumSepoliaData,
  [chainByKey.avalancheFuji.id]: avalancheFujiData,
  [chainByKey.polygonAmoy.id]: polygonAmoyData,
  [chainByKey.baseSepolia.id]: baseSepoliaData,
  [chainByKey.arbitrum.id]: arbitrumData,
  [chainByKey.avalanche.id]: avalancheData,
  [chainByKey.polygon.id]: polygonData,
  [chainByKey.bsc.id]: bscData,
  [chainByKey.base.id]: baseData,
} as const;

export const casinoChains = Object.values(casinoChainById) as unknown as readonly [
  CasinoChain,
  ...CasinoChain[],
];

export const casinoChainIds: CasinoChainId[] = casinoChains.map(
  (chain) => chain.viemChain.id as CasinoChainId,
);

export const labelCasinoGameByType = {
  [CASINO_GAME_TYPE.COINTOSS]: CASINO_GAME_LABEL_TYPE.COINTOSS,
  [CASINO_GAME_TYPE.DICE]: CASINO_GAME_LABEL_TYPE.DICE,
  [CASINO_GAME_TYPE.ROULETTE]: CASINO_GAME_LABEL_TYPE.ROULETTE,
  [CASINO_GAME_TYPE.KENO]: CASINO_GAME_LABEL_TYPE.KENO,
  [CASINO_GAME_TYPE.WHEEL]: CASINO_GAME_LABEL_TYPE.WHEEL,
  [CASINO_GAME_TYPE.CUSTOM_WEIGHTED_GAME]: CASINO_GAME_LABEL_TYPE.CUSTOM_WEIGHTED_GAME,
} as const;

export const typeBySubgraphCasinoGame = {
  [CASINO_GAME_SUBGRAPH_TYPE.COINTOSS]: CASINO_GAME_TYPE.COINTOSS,
  [CASINO_GAME_SUBGRAPH_TYPE.DICE]: CASINO_GAME_TYPE.DICE,
  [CASINO_GAME_SUBGRAPH_TYPE.ROULETTE]: CASINO_GAME_TYPE.ROULETTE,
  [CASINO_GAME_SUBGRAPH_TYPE.KENO]: CASINO_GAME_TYPE.KENO,
  [CASINO_GAME_SUBGRAPH_TYPE.WHEEL]: CASINO_GAME_TYPE.WHEEL,
  [CASINO_GAME_SUBGRAPH_TYPE.CUSTOM_WEIGHTED_GAME]: CASINO_GAME_TYPE.CUSTOM_WEIGHTED_GAME,
} as const;

export const subgraphGameByType = {
  [CASINO_GAME_TYPE.COINTOSS]: CASINO_GAME_SUBGRAPH_TYPE.COINTOSS,
  [CASINO_GAME_TYPE.DICE]: CASINO_GAME_SUBGRAPH_TYPE.DICE,
  [CASINO_GAME_TYPE.ROULETTE]: CASINO_GAME_SUBGRAPH_TYPE.ROULETTE,
  [CASINO_GAME_TYPE.KENO]: CASINO_GAME_SUBGRAPH_TYPE.KENO,
  [CASINO_GAME_TYPE.WHEEL]: CASINO_GAME_SUBGRAPH_TYPE.WHEEL,
  [CASINO_GAME_TYPE.CUSTOM_WEIGHTED_GAME]: CASINO_GAME_SUBGRAPH_TYPE.CUSTOM_WEIGHTED_GAME,
} as const;

// Could be increased in the future if we increase vrfCallbackGasExtraBet value in smart contracts
// This limit is a static limit, you need to Math.min(static limit, dynamic limit)
export const maxGameBetCountByType = {
  [CASINO_GAME_TYPE.COINTOSS]: 100,
  [CASINO_GAME_TYPE.DICE]: 200,
  [CASINO_GAME_TYPE.ROULETTE]: 200,
  [CASINO_GAME_TYPE.KENO]: 125,
  [CASINO_GAME_TYPE.WHEEL]: 100,
  [CASINO_GAME_TYPE.CUSTOM_WEIGHTED_GAME]: 100,
} as const;
</file>

<file path="packages/core/src/provider/client.ts">
import type { Address, Hash, Hex, TransactionReceipt } from "viem";
import { DEFAULT_ITEMS_PER_PAGE, DEFAULT_PAGE } from "../constants";
import type { CASINO_GAME_TYPE, CasinoChainId } from "../data/casino";
import {
  type CasinoBetFilterStatus,
  fetchBet,
  fetchBetByHash,
  fetchBets,
} from "../data/subgraphs/protocol/clients/bet";
import {
  Bet_OrderBy,
  OrderDirection,
  Token_OrderBy,
} from "../data/subgraphs/protocol/documents/types";
import type { SubgraphError } from "../errors";
import type {
  BetRequirements,
  CasinoBet,
  CasinoGame,
  CasinoGameToken,
  CasinoToken,
  SubgraphToken,
  Token,
} from "../interfaces";

import { fetchToken, fetchTokens } from "../data/subgraphs/protocol/clients/token";
import type { BetSwirlWallet } from "./wallet";

import type { ApolloCache, DefaultOptions } from "@apollo/client/core/index.js";
import type { CoinTossParams, CoinTossPlacedBet } from "../actions/casino/cointoss";
import type { DiceParams } from "../actions/casino/dice";
import type { DicePlacedBet } from "../actions/casino/dice";
import type {
  CasinoPlaceBetOptions,
  NormalCasinoPlacedBet,
  PlaceBetCallbacks,
  WeightedCasinoPlacedBet,
} from "../actions/casino/game";
import type { KenoParams, KenoPlacedBet } from "../actions/casino/keno";
import type { RouletteParams, RoulettePlacedBet } from "../actions/casino/roulette";
import type { WheelParams, WheelPlacedBet } from "../actions/casino/wheel";
import type { ALLOWANCE_TYPE } from "../actions/common/approve";
import type { ChainId } from "../data";
import type {
  CasinoRolledBet,
  CasinoWaitRollOptions,
  CoinTossRolledBet,
  DiceRolledBet,
  GAS_PRICE_TYPE,
  KenoConfiguration,
  KenoRolledBet,
  RouletteRolledBet,
} from "../read";
import type { WeightedGameConfiguration } from "../read/casino/weightedGame";
import type { WheelRolledBet } from "../read/casino/wheel";
import { FORMAT_TYPE, getCasinoChainId } from "../utils";

export interface BetSwirlClientOptions {
  gasPriceType?: GAS_PRICE_TYPE;
  gasPrice?: bigint;
  chainId?: ChainId;
  affiliate?: Hex;
  allowanceType?: ALLOWANCE_TYPE;
  pollingInterval?: number;
  formatType?: FORMAT_TYPE;
  subgraphClient?: {
    graphqlKey?: string;
    cache?: ApolloCache<any>;
    defaultOptions?: DefaultOptions;
  };
}

export abstract class BetSwirlClient {
  public betSwirlWallet: BetSwirlWallet;
  public betSwirlDefaultOptions: BetSwirlClientOptions;

  constructor(betSwirlWallet: BetSwirlWallet, betSwirlDefaultOptions: BetSwirlClientOptions) {
    this.betSwirlWallet = betSwirlWallet;
    this.betSwirlDefaultOptions = betSwirlDefaultOptions;
  }

  /* Casino games */

  abstract waitRolledBet(
    placedBet: NormalCasinoPlacedBet,
    options?: CasinoWaitRollOptions,
  ): Promise<{ rolledBet: CasinoRolledBet; receipt: TransactionReceipt }>;

  abstract waitRolledBet(
    placedBet: WeightedCasinoPlacedBet,
    options: CasinoWaitRollOptions | undefined,
    weightedGameConfiguration: WeightedGameConfiguration,
    houseEdge: number,
  ): Promise<{ rolledBet: CasinoRolledBet; receipt: TransactionReceipt }>;

  abstract playCoinToss(
    params: CoinTossParams,
    options?: CasinoPlaceBetOptions,
    callbacks?: PlaceBetCallbacks,
  ): Promise<{ placedBet: CoinTossPlacedBet; receipt: TransactionReceipt }>;

  abstract waitCoinToss(
    placedBet: CoinTossPlacedBet,
    options?: CasinoWaitRollOptions,
  ): Promise<{ rolledBet: CoinTossRolledBet; receipt: TransactionReceipt }>;

  abstract playDice(
    params: DiceParams,
    options?: CasinoPlaceBetOptions,
    callbacks?: PlaceBetCallbacks,
  ): Promise<{ placedBet: DicePlacedBet; receipt: TransactionReceipt }>;

  abstract waitDice(
    placedBet: DicePlacedBet,
    options?: CasinoWaitRollOptions,
  ): Promise<{ rolledBet: DiceRolledBet; receipt: TransactionReceipt }>;

  abstract playRoulette(
    params: RouletteParams,
    options?: CasinoPlaceBetOptions,
    callbacks?: PlaceBetCallbacks,
  ): Promise<{ placedBet: RoulettePlacedBet; receipt: TransactionReceipt }>;

  abstract waitRoulette(
    placedBet: RoulettePlacedBet,
    options?: CasinoWaitRollOptions,
  ): Promise<{ rolledBet: RouletteRolledBet; receipt: TransactionReceipt }>;

  abstract playKeno(
    params: KenoParams,
    options?: CasinoPlaceBetOptions,
    callbacks?: PlaceBetCallbacks,
  ): Promise<{ placedBet: KenoPlacedBet; receipt: TransactionReceipt }>;

  abstract waitKeno(
    placedBet: KenoPlacedBet,
    options?: CasinoWaitRollOptions,
  ): Promise<{ rolledBet: KenoRolledBet; receipt: TransactionReceipt }>;

  abstract playWheel(
    params: WheelParams,
    options?: CasinoPlaceBetOptions,
    callbacks?: PlaceBetCallbacks,
  ): Promise<{ placedBet: WheelPlacedBet; receipt: TransactionReceipt }>;

  abstract waitWheel(
    placedBet: WheelPlacedBet,
    weightedGameConfiguration: WeightedGameConfiguration,
    houseEdge: number,
    options?: CasinoWaitRollOptions,
  ): Promise<{ rolledBet: WheelRolledBet; receipt: TransactionReceipt }>;

  /* Casino utilities */

  abstract getCasinoGames(onlyActive?: boolean): Promise<CasinoGame[]>;

  abstract getCasinoTokens(onlyActive?: boolean): Promise<CasinoToken[]>;

  abstract getCasinoGameToken(
    casinoToken: CasinoToken,
    game: CASINO_GAME_TYPE,
    affiliate?: Hex,
  ): Promise<CasinoGameToken>;

  abstract getBetRequirements(
    token: Token,
    multiplier: number,
    game: CASINO_GAME_TYPE,
  ): Promise<BetRequirements>;

  abstract getChainlinkVrfCost(
    game: CASINO_GAME_TYPE,
    tokenAddress: Hex,
    betCount: number,
    gasPrice?: bigint,
    gasPriceType?: GAS_PRICE_TYPE,
  ): Promise<bigint>;

  abstract getKenoConfiguration(token: Token): Promise<KenoConfiguration>;

  abstract getWeighedGameConfiguration(
    configId: number | string,
  ): Promise<WeightedGameConfiguration>;

  /* Subgraph queries */

  async fetchBets(
    chainId?: CasinoChainId,
    filter?: {
      bettor?: Address;
      game?: CASINO_GAME_TYPE;
      token?: Token;
      status?: CasinoBetFilterStatus;
      affiliates?: Address[];
    },
    page = DEFAULT_PAGE,
    itemsPerPage = DEFAULT_ITEMS_PER_PAGE,
    sortBy: { key: Bet_OrderBy; order: OrderDirection } = {
      key: Bet_OrderBy.BetTimestamp,
      order: OrderDirection.Desc,
    },
  ): Promise<{ bets: CasinoBet[]; error: SubgraphError | undefined }> {
    const casinoChainId = getCasinoChainId(this.betSwirlWallet, chainId);
    return fetchBets(
      {
        ...this.betSwirlDefaultOptions.subgraphClient,
        chainId: casinoChainId,
        formatType: this.betSwirlDefaultOptions.formatType,
      },
      filter,
      page,
      itemsPerPage,
      sortBy,
    );
  }

  async fetchBet(
    id: string | bigint,
    chainId?: CasinoChainId,
  ): Promise<{ bet: CasinoBet | undefined; error: SubgraphError | undefined }> {
    const casinoChainId = getCasinoChainId(this.betSwirlWallet, chainId);
    return fetchBet(id, {
      ...this.betSwirlDefaultOptions.subgraphClient,
      chainId: casinoChainId,
      formatType: this.betSwirlDefaultOptions.formatType,
    });
  }

  async fetchBetByHash(
    placeBetHash: Hash,
    chainId?: CasinoChainId,
  ): Promise<{ bet: CasinoBet | undefined; error: SubgraphError | undefined }> {
    const casinoChainId = getCasinoChainId(this.betSwirlWallet, chainId);
    return fetchBetByHash(placeBetHash, {
      ...this.betSwirlDefaultOptions.subgraphClient,
      chainId: casinoChainId,
      formatType: this.betSwirlDefaultOptions.formatType,
    });
  }

  async fetchTokens(
    chainId?: CasinoChainId,
    page = DEFAULT_PAGE,
    itemsPerPage = DEFAULT_ITEMS_PER_PAGE,
    sortBy: { key: Token_OrderBy; order: OrderDirection } = {
      key: Token_OrderBy.Symbol,
      order: OrderDirection.Asc,
    },
  ): Promise<{ tokens: SubgraphToken[]; error: SubgraphError | undefined }> {
    const casinoChainId = getCasinoChainId(this.betSwirlWallet, chainId);
    return fetchTokens(
      {
        ...this.betSwirlDefaultOptions.subgraphClient,
        chainId: casinoChainId,
        formatType: this.betSwirlDefaultOptions.formatType,
      },
      page,
      itemsPerPage,
      sortBy,
    );
  }

  async fetchToken(
    address: Address,
    chainId?: CasinoChainId,
  ): Promise<{ token: SubgraphToken | undefined; error: SubgraphError | undefined }> {
    const casinoChainId = getCasinoChainId(this.betSwirlWallet, chainId);
    return fetchToken(address, {
      ...this.betSwirlDefaultOptions.subgraphClient,
      chainId: casinoChainId,
      formatType: this.betSwirlDefaultOptions.formatType,
    });
  }
}
</file>

<file path="packages/core/src/provider/viemClient.ts">
import type { Hex, PublicClient, TransactionReceipt, WalletClient } from "viem";
import {
  type BetRequirements,
  type BetSwirlClientOptions,
  type CasinoGameToken,
  type CasinoPlaceBetOptions,
  type CasinoPlacedBet,
  type CasinoRolledBet,
  type CasinoToken,
  type CasinoWaitRollOptions,
  type CoinTossRolledBet,
  type DiceParams,
  type DicePlacedBet,
  type DiceRolledBet,
  type GAS_PRICE_TYPE,
  type KenoConfiguration,
  type KenoRolledBet,
  type NormalCasinoPlacedBet,
  type PlaceBetCallbacks,
  type RouletteParams,
  type RoulettePlacedBet,
  type RouletteRolledBet,
  type Token,
  WEIGHTED_CASINO_GAME_TYPES,
  type WeightedCasinoPlacedBet,
  casinoChainById,
  getBetRequirements,
  getCasinoGameToken,
  getCasinoGames,
  getCasinoTokens,
  getChainlinkVrfCost,
  getKenoConfiguration,
  placeDiceBet,
  placeRouletteBet,
  waitCoinTossRolledBet,
  waitDiceRolledBet,
  waitKenoRolledBet,
  waitRolledBet,
  waitRouletteRolledBet,
} from "..";
import { type CoinTossPlacedBet, placeCoinTossBet } from "../actions/casino/cointoss";
import type { CoinTossParams } from "../actions/casino/cointoss";
import { type KenoParams, type KenoPlacedBet, placeKenoBet } from "../actions/casino/keno";
import { type WheelParams, type WheelPlacedBet, placeWheelBet } from "../actions/casino/wheel";
import type { CASINO_GAME_TYPE } from "../data";
import {
  type WeightedGameConfiguration,
  getWeightedGameConfiguration,
} from "../read/casino/weightedGame";
import { type WheelRolledBet, waitWheelRolledBet } from "../read/casino/wheel";
import { BetSwirlClient } from "./client";
import { ViemBetSwirlWallet } from "./viemWallet";

export class ViemBetSwirlClient extends BetSwirlClient {
  public publicClient: PublicClient;

  constructor(
    publicClient: PublicClient,
    walletClient?: WalletClient,
    betSwirlDefaultOptions: BetSwirlClientOptions = {},
  ) {
    super(new ViemBetSwirlWallet(publicClient, walletClient), betSwirlDefaultOptions);
    this.publicClient = publicClient;
  }

  /* Casino Games */

  async waitRolledBet(
    placedBet: NormalCasinoPlacedBet,
    options?: CasinoWaitRollOptions,
  ): Promise<{ rolledBet: CasinoRolledBet; receipt: TransactionReceipt }>;

  async waitRolledBet(
    placedBet: WeightedCasinoPlacedBet,
    options: CasinoWaitRollOptions | undefined,
    weightedGameConfiguration: WeightedGameConfiguration,
    houseEdge: number,
  ): Promise<{ rolledBet: CasinoRolledBet; receipt: TransactionReceipt }>;

  async waitRolledBet(
    placedBet: CasinoPlacedBet,
    options?: CasinoWaitRollOptions,
    weightedGameConfiguration?: WeightedGameConfiguration,
    houseEdge?: number,
  ): Promise<{ rolledBet: CasinoRolledBet; receipt: TransactionReceipt }> {
    const isWeighted = WEIGHTED_CASINO_GAME_TYPES.includes(placedBet.game);
    if (isWeighted) {
      return waitRolledBet(
        this.betSwirlWallet,
        placedBet as WeightedCasinoPlacedBet,
        { ...this.betSwirlDefaultOptions, ...options },
        weightedGameConfiguration!,
        houseEdge!,
      );
    }
    return waitRolledBet(this.betSwirlWallet, placedBet as NormalCasinoPlacedBet, {
      ...this.betSwirlDefaultOptions,
      ...options,
    });
  }

  async playCoinToss(
    params: CoinTossParams,
    options?: CasinoPlaceBetOptions,
    callbacks?: PlaceBetCallbacks,
  ): Promise<{ placedBet: CoinTossPlacedBet; receipt: TransactionReceipt }> {
    return placeCoinTossBet(
      this.betSwirlWallet,
      { ...params, affiliate: this.betSwirlDefaultOptions.affiliate },
      {
        ...this.betSwirlDefaultOptions,
        ...options,
      },
      callbacks,
    );
  }

  async waitCoinToss(
    placedBet: CoinTossPlacedBet,
    options?: CasinoWaitRollOptions,
  ): Promise<{ rolledBet: CoinTossRolledBet; receipt: TransactionReceipt }> {
    return waitCoinTossRolledBet(this.betSwirlWallet, placedBet, {
      ...this.betSwirlDefaultOptions,
      ...options,
    });
  }

  async playDice(
    params: DiceParams,
    options?: CasinoPlaceBetOptions,
    callbacks?: PlaceBetCallbacks,
  ): Promise<{ placedBet: DicePlacedBet; receipt: TransactionReceipt }> {
    return placeDiceBet(
      this.betSwirlWallet,
      { ...params, affiliate: this.betSwirlDefaultOptions.affiliate },
      {
        ...this.betSwirlDefaultOptions,
        ...options,
      },
      callbacks,
    );
  }

  async waitDice(
    placedBet: DicePlacedBet,
    options?: CasinoWaitRollOptions,
  ): Promise<{ rolledBet: DiceRolledBet; receipt: TransactionReceipt }> {
    return waitDiceRolledBet(this.betSwirlWallet, placedBet, {
      ...this.betSwirlDefaultOptions,
      ...options,
    });
  }

  async playRoulette(
    params: RouletteParams,
    options?: CasinoPlaceBetOptions,
    callbacks?: PlaceBetCallbacks,
  ): Promise<{ placedBet: RoulettePlacedBet; receipt: TransactionReceipt }> {
    return placeRouletteBet(
      this.betSwirlWallet,
      { ...params, affiliate: this.betSwirlDefaultOptions.affiliate },
      {
        ...this.betSwirlDefaultOptions,
        ...options,
      },
      callbacks,
    );
  }

  async waitRoulette(
    placedBet: RoulettePlacedBet,
    options?: CasinoWaitRollOptions,
  ): Promise<{ rolledBet: RouletteRolledBet; receipt: TransactionReceipt }> {
    return waitRouletteRolledBet(this.betSwirlWallet, placedBet, {
      ...this.betSwirlDefaultOptions,
      ...options,
    });
  }

  async playKeno(
    params: KenoParams,
    options?: CasinoPlaceBetOptions,
    callbacks?: PlaceBetCallbacks,
  ): Promise<{ placedBet: KenoPlacedBet; receipt: TransactionReceipt }> {
    return placeKenoBet(
      this.betSwirlWallet,
      { ...params, affiliate: this.betSwirlDefaultOptions.affiliate },
      {
        ...this.betSwirlDefaultOptions,
        ...options,
      },
      callbacks,
    );
  }

  async waitKeno(
    placedBet: KenoPlacedBet,
    options?: CasinoWaitRollOptions,
  ): Promise<{ rolledBet: KenoRolledBet; receipt: TransactionReceipt }> {
    return waitKenoRolledBet(this.betSwirlWallet, placedBet, {
      ...this.betSwirlDefaultOptions,
      ...options,
    });
  }

  async playWheel(
    params: WheelParams,
    options?: CasinoPlaceBetOptions,
    callbacks?: PlaceBetCallbacks,
  ): Promise<{ placedBet: WheelPlacedBet; receipt: TransactionReceipt }> {
    return placeWheelBet(
      this.betSwirlWallet,
      { ...params, affiliate: this.betSwirlDefaultOptions.affiliate },
      {
        ...this.betSwirlDefaultOptions,
        ...options,
      },
      callbacks,
    );
  }

  async waitWheel(
    placedBet: WheelPlacedBet,
    weightedGameConfiguration: WeightedGameConfiguration,
    houseEdge: number,
    options?: CasinoWaitRollOptions,
  ): Promise<{ rolledBet: WheelRolledBet; receipt: TransactionReceipt }> {
    return waitWheelRolledBet(
      this.betSwirlWallet,
      placedBet,
      weightedGameConfiguration,
      houseEdge,
      {
        ...this.betSwirlDefaultOptions,
        ...options,
      },
    );
  }

  /* Casino Utilities */

  async getCasinoGames(onlyActive = false) {
    return getCasinoGames(this.betSwirlWallet, onlyActive);
  }

  async getCasinoTokens(onlyActive = false): Promise<CasinoToken[]> {
    return getCasinoTokens(this.betSwirlWallet, onlyActive);
  }

  async getCasinoGameToken(
    casinoToken: CasinoToken,
    game: CASINO_GAME_TYPE,
    affiliate?: Hex,
  ): Promise<CasinoGameToken> {
    const casinoChain = casinoChainById[casinoToken.chainId];
    return getCasinoGameToken(
      this.betSwirlWallet,
      casinoToken,
      game,
      affiliate || casinoChain.defaultAffiliate,
    );
  }

  async getBetRequirements(
    token: Token,
    multiplier: number | number[],
    game: CASINO_GAME_TYPE,
  ): Promise<BetRequirements> {
    return getBetRequirements(this.betSwirlWallet, token, multiplier, game);
  }

  async getChainlinkVrfCost(
    game: CASINO_GAME_TYPE,
    tokenAddress: Hex,
    betCount: number,
    gasPrice?: bigint,
    gasPriceType?: GAS_PRICE_TYPE,
  ) {
    return getChainlinkVrfCost(
      this.betSwirlWallet,
      game,
      tokenAddress,
      betCount,
      gasPrice || this.betSwirlDefaultOptions.gasPrice,
      gasPriceType || this.betSwirlDefaultOptions.gasPriceType,
    );
  }

  async getKenoConfiguration(token: Token): Promise<KenoConfiguration> {
    return getKenoConfiguration(this.betSwirlWallet, token);
  }

  async getWeighedGameConfiguration(configId: number | string): Promise<WeightedGameConfiguration> {
    return getWeightedGameConfiguration(this.betSwirlWallet, configId);
  }

  /* Private */

  static init(
    viemPublicClient: PublicClient,
    viemWalletClient?: WalletClient,
    options?: BetSwirlClientOptions,
  ): ViemBetSwirlClient {
    return new ViemBetSwirlClient(viemPublicClient, viemWalletClient, options);
  }
}

export function initViemBetSwirlClient(
  viemPublicClient: PublicClient,
  viemWalletClient?: WalletClient,
  options?: BetSwirlClientOptions,
): ViemBetSwirlClient {
  return ViemBetSwirlClient.init(viemPublicClient, viemWalletClient, options);
}
</file>

<file path="packages/core/src/read/index.ts">
/* casino */
export * from "./casino/bank";
export * from "./casino/cointoss";
export * from "./casino/dice";
export * from "./casino/roulette";
export * from "./casino/keno";
export * from "./casino/game";
export * from "./casino/weightedGame";
export * from "./casino/wheel";

/* common */
export * from "./common/chainlinkVrfCost";
export * from "./common/gasPrice";
</file>

<file path="packages/providers/wagmi/src/client.ts">
import type {
  BetRequirements,
  BetSwirlClientOptions,
  CASINO_GAME_TYPE,
  CasinoChainId,
  CasinoGameToken,
  CasinoPlaceBetOptions,
  CasinoPlacedBet,
  CasinoRolledBet,
  CasinoToken,
  CasinoWaitRollOptions,
  ChainId,
  CoinTossParams,
  CoinTossPlacedBet,
  CoinTossRolledBet,
  DiceParams,
  DicePlacedBet,
  DiceRolledBet,
  GAS_PRICE_TYPE,
  KenoConfiguration,
  KenoParams,
  KenoPlacedBet,
  KenoRolledBet,
  NormalCasinoPlacedBet,
  PlaceBetCallbacks,
  RouletteParams,
  RoulettePlacedBet,
  RouletteRolledBet,
  Token,
  WeightedCasinoPlacedBet,
  WeightedGameConfiguration,
  WheelParams,
  WheelPlacedBet,
  WheelRolledBet,
} from "@betswirl/sdk-core";
import {
  BetSwirlClient,
  WEIGHTED_CASINO_GAME_TYPES,
  casinoChainById,
  getBetRequirements,
  getCasinoGameToken,
  getCasinoGames,
  getCasinoTokens,
  getChainlinkVrfCost,
  getKenoConfiguration,
  getWeightedGameConfiguration,
  placeCoinTossBet,
  placeDiceBet,
  placeKenoBet,
  placeRouletteBet,
  placeWheelBet,
  waitCoinTossRolledBet,
  waitDiceRolledBet,
  waitKenoRolledBet,
  waitRolledBet,
  waitRouletteRolledBet,
  waitWheelRolledBet,
} from "@betswirl/sdk-core";
import { type Config as WagmiConfig, switchChain } from "@wagmi/core";
import type { Hex, TransactionReceipt } from "viem";
import { WagmiBetSwirlWallet } from "./wallet";

export class WagmiBetSwirlClient extends BetSwirlClient {
  public wagmiConfig: WagmiConfig;

  constructor(wagmiConfig: WagmiConfig, betSwirlDefaultOptions: BetSwirlClientOptions = {}) {
    super(new WagmiBetSwirlWallet(wagmiConfig), betSwirlDefaultOptions);
    this.wagmiConfig = wagmiConfig;
  }

  /* Casino Games */

  async waitRolledBet(
    placedBet: NormalCasinoPlacedBet,
    options?: CasinoWaitRollOptions,
  ): Promise<{ rolledBet: CasinoRolledBet; receipt: TransactionReceipt }>;

  async waitRolledBet(
    placedBet: WeightedCasinoPlacedBet,
    options: CasinoWaitRollOptions | undefined,
    weightedGameConfiguration: WeightedGameConfiguration,
    houseEdge: number,
  ): Promise<{ rolledBet: CasinoRolledBet; receipt: TransactionReceipt }>;

  async waitRolledBet(
    placedBet: CasinoPlacedBet,
    options?: CasinoWaitRollOptions,
    weightedGameConfiguration?: WeightedGameConfiguration,
    houseEdge?: number,
  ): Promise<{ rolledBet: CasinoRolledBet; receipt: TransactionReceipt }> {
    this._switchChain(placedBet.chainId);
    const isWeighted = WEIGHTED_CASINO_GAME_TYPES.includes(placedBet.game);
    if (isWeighted) {
      return waitRolledBet(
        this.betSwirlWallet,
        placedBet as WeightedCasinoPlacedBet,
        {
          ...this.betSwirlDefaultOptions,
          ...options,
        },
        weightedGameConfiguration!,
        houseEdge!,
      );
    }
    return waitRolledBet(this.betSwirlWallet, placedBet as NormalCasinoPlacedBet, {
      ...this.betSwirlDefaultOptions,
      ...options,
    });
  }

  async playCoinToss(
    params: CoinTossParams,
    options?: CasinoPlaceBetOptions,
    callbacks?: PlaceBetCallbacks,
    chainId?: CasinoChainId,
  ): Promise<{ placedBet: CoinTossPlacedBet; receipt: TransactionReceipt }> {
    this._switchChain(chainId);
    return placeCoinTossBet(
      this.betSwirlWallet,
      { ...params, affiliate: this.betSwirlDefaultOptions.affiliate },
      {
        ...this.betSwirlDefaultOptions,
        ...options,
      },
      callbacks,
    );
  }

  async waitCoinToss(
    placedBet: CoinTossPlacedBet,
    options?: CasinoWaitRollOptions,
  ): Promise<{ rolledBet: CoinTossRolledBet; receipt: TransactionReceipt }> {
    this._switchChain(placedBet.chainId);
    return waitCoinTossRolledBet(this.betSwirlWallet, placedBet, {
      ...this.betSwirlDefaultOptions,
      ...options,
    });
  }

  async playDice(
    params: DiceParams,
    options?: CasinoPlaceBetOptions,
    callbacks?: PlaceBetCallbacks,
    chainId?: CasinoChainId,
  ): Promise<{ placedBet: DicePlacedBet; receipt: TransactionReceipt }> {
    this._switchChain(chainId);
    return placeDiceBet(
      this.betSwirlWallet,
      { ...params, affiliate: this.betSwirlDefaultOptions.affiliate },
      {
        ...this.betSwirlDefaultOptions,
        ...options,
      },
      callbacks,
    );
  }

  async waitDice(
    placedBet: DicePlacedBet,
    options?: CasinoWaitRollOptions,
  ): Promise<{ rolledBet: DiceRolledBet; receipt: TransactionReceipt }> {
    this._switchChain(placedBet.chainId);
    return waitDiceRolledBet(this.betSwirlWallet, placedBet, {
      ...this.betSwirlDefaultOptions,
      ...options,
    });
  }

  async playRoulette(
    params: RouletteParams,
    options?: CasinoPlaceBetOptions,
    callbacks?: PlaceBetCallbacks,
    chainId?: CasinoChainId,
  ): Promise<{ placedBet: RoulettePlacedBet; receipt: TransactionReceipt }> {
    this._switchChain(chainId);
    return placeRouletteBet(
      this.betSwirlWallet,
      { ...params, affiliate: this.betSwirlDefaultOptions.affiliate },
      {
        ...this.betSwirlDefaultOptions,
        ...options,
      },
      callbacks,
    );
  }

  async waitRoulette(
    placedBet: RoulettePlacedBet,
    options?: CasinoWaitRollOptions,
  ): Promise<{ rolledBet: RouletteRolledBet; receipt: TransactionReceipt }> {
    this._switchChain(placedBet.chainId);
    return waitRouletteRolledBet(this.betSwirlWallet, placedBet, {
      ...this.betSwirlDefaultOptions,
      ...options,
    });
  }

  async playKeno(
    params: KenoParams,
    options?: CasinoPlaceBetOptions,
    callbacks?: PlaceBetCallbacks,
    chainId?: CasinoChainId,
  ): Promise<{ placedBet: KenoPlacedBet; receipt: TransactionReceipt }> {
    this._switchChain(chainId);
    return placeKenoBet(
      this.betSwirlWallet,
      { ...params, affiliate: this.betSwirlDefaultOptions.affiliate },
      {
        ...this.betSwirlDefaultOptions,
        ...options,
      },
      callbacks,
    );
  }

  async waitKeno(
    placedBet: KenoPlacedBet,
    options?: CasinoWaitRollOptions,
  ): Promise<{ rolledBet: KenoRolledBet; receipt: TransactionReceipt }> {
    this._switchChain(placedBet.chainId);
    return waitKenoRolledBet(this.betSwirlWallet, placedBet, {
      ...this.betSwirlDefaultOptions,
      ...options,
    });
  }

  async playWheel(
    params: WheelParams,
    options?: CasinoPlaceBetOptions,
    callbacks?: PlaceBetCallbacks,
    chainId?: CasinoChainId,
  ): Promise<{ placedBet: WheelPlacedBet; receipt: TransactionReceipt }> {
    this._switchChain(chainId);
    return placeWheelBet(
      this.betSwirlWallet,
      { ...params, affiliate: this.betSwirlDefaultOptions.affiliate },
      {
        ...this.betSwirlDefaultOptions,
        ...options,
      },
      callbacks,
    );
  }

  async waitWheel(
    placedBet: WheelPlacedBet,
    weightedGameConfiguration: WeightedGameConfiguration,
    houseEdge: number,
    options?: CasinoWaitRollOptions,
  ): Promise<{ rolledBet: WheelRolledBet; receipt: TransactionReceipt }> {
    this._switchChain(placedBet.chainId);
    return waitWheelRolledBet(
      this.betSwirlWallet,
      placedBet,
      weightedGameConfiguration,
      houseEdge,
      {
        ...this.betSwirlDefaultOptions,
        ...options,
      },
    );
  }

  /* Casino Utilities */

  async getCasinoGames(onlyActive = false, chainId?: CasinoChainId) {
    this._switchChain(chainId);
    return getCasinoGames(this.betSwirlWallet, onlyActive);
  }

  async getCasinoTokens(onlyActive = false, chainId?: CasinoChainId): Promise<CasinoToken[]> {
    this._switchChain(chainId);
    return getCasinoTokens(this.betSwirlWallet, onlyActive);
  }

  async getCasinoGameToken(
    casinoToken: CasinoToken,
    game: CASINO_GAME_TYPE,
    affiliate?: Hex,
  ): Promise<CasinoGameToken> {
    const casinoChain = casinoChainById[casinoToken.chainId];
    this._switchChain(casinoToken.chainId);
    return getCasinoGameToken(
      this.betSwirlWallet,
      casinoToken,
      game,
      affiliate || casinoChain.defaultAffiliate,
    );
  }

  async getBetRequirements(
    token: Token,
    multiplier: number | number[],
    game: CASINO_GAME_TYPE,
    chainId?: CasinoChainId,
  ): Promise<BetRequirements> {
    this._switchChain(chainId);
    return getBetRequirements(this.betSwirlWallet, token, multiplier, game);
  }

  async getChainlinkVrfCost(
    game: CASINO_GAME_TYPE,
    tokenAddress: Hex,
    betCount: number,
    gasPrice?: bigint,
    gasPriceType?: GAS_PRICE_TYPE,
    chainId?: CasinoChainId,
  ) {
    this._switchChain(chainId);
    return getChainlinkVrfCost(
      this.betSwirlWallet,
      game,
      tokenAddress,
      betCount,
      gasPrice || this.betSwirlDefaultOptions.gasPrice,
      gasPriceType || this.betSwirlDefaultOptions.gasPriceType,
    );
  }

  async getKenoConfiguration(token: Token, chainId?: CasinoChainId): Promise<KenoConfiguration> {
    this._switchChain(chainId);
    return getKenoConfiguration(this.betSwirlWallet, token);
  }

  async getWeighedGameConfiguration(
    configId: number | string,
    chainId?: CasinoChainId,
  ): Promise<WeightedGameConfiguration> {
    this._switchChain(chainId);
    return getWeightedGameConfiguration(this.betSwirlWallet, configId);
  }

  /* Private */
  async _switchChain(chainId?: ChainId) {
    const effectiveChainId = chainId || this.betSwirlDefaultOptions.chainId;
    if (effectiveChainId) {
      const currentChainId = await this.betSwirlWallet.getChainId();
      if (currentChainId !== effectiveChainId) {
        await switchChain(this.wagmiConfig, { chainId: effectiveChainId });
      }
    }
  }

  static init(wagmiConfig: WagmiConfig, options?: BetSwirlClientOptions): WagmiBetSwirlClient {
    return new WagmiBetSwirlClient(wagmiConfig, options);
  }
}

export function initWagmiBetSwirlClient(
  wagmiConfig: WagmiConfig,
  options?: BetSwirlClientOptions,
): WagmiBetSwirlClient {
  return WagmiBetSwirlClient.init(wagmiConfig, options);
}
</file>

<file path=".github/ansible/deploy.yml">
---
- hosts: webservers
  tasks:
    - name: Copy dist files
      synchronize:
        src: ../../examples/mini-app/storybook-static/
        dest: /var/www/betswirl-sdk/storybook-static
        delete: yes
        archive: no
        recursive: yes
        rsync_opts:
          - "--no-perms"
          - "--no-owner"
          - "--no-group"
          - "--no-times"
          - "--compress"
</file>

<file path="examples/mini-app/src/components/ui/button.tsx">
import { Slot } from "@radix-ui/react-slot"
import { type VariantProps, cva } from "class-variance-authority"
import * as React from "react"

import { cn } from "../../lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-semibold ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-neutral-background text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
        iconRound:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80 rounded-full",
        iconTransparent:
          "bg-secondary/20 text-secondary-foreground hover:bg-secondary/30 rounded-full border border-transparent-button-border",
      },
      size: {
        default: "h-[42px] w-[120px]",
        sm: "h-9 rounded-md px-3",
        lg: "h-12 rounded-md px-8 text-base font-bold",
        icon: "h-10 w-10",
        iconRound: "h-7 w-7",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  },
)
Button.displayName = "Button"

export { Button }
</file>

<file path="examples/mini-app/src/components/ui/input.stories.tsx">
import type { Meta, StoryObj } from "@storybook/react"
import { TokenImage } from "@coinbase/onchainkit/token"
import { ETH_TOKEN } from "../../lib/tokens"
import { Input } from "./input"

const meta = {
  title: "UI/Input",
  component: Input,
  parameters: {
    layout: "centered",
  },
  tags: ["autodocs"],
  argTypes: {
    type: { control: "text" },
    placeholder: { control: "text" },
    disabled: { control: "boolean" },
    className: { control: "text" },
    token: { control: "object" },
  },
  args: {
    type: "text",
    placeholder: "Enter text...",
    disabled: false,
    className: "w-64",
  },
} satisfies Meta<typeof Input>

export default meta
type Story = StoryObj<typeof meta>

export const Default: Story = {
  args: {
    type: "number",
    placeholder: "0",
    value: "10.5",
    token: {
      icon: <TokenImage token={ETH_TOKEN} size={16} className="mr-1" />,
      symbol: "ETH",
    },
  },
}

export const Disabled: Story = {
  args: {
    type: "number",
    placeholder: "0",
    value: "10.5",
    token: {
      icon: <TokenImage token={ETH_TOKEN} size={16} className="mr-1" />,
      symbol: "ETH",
    },
    disabled: true,
  },
}
</file>

<file path="examples/mini-app/src/App.tsx">
import "./App.css"
import { CoinTossGame } from "./components/game/CoinTossGame"

function App() {
  return <CoinTossGame />
}

export default App
</file>

<file path="examples/mini-app/tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
  ],
  prefix: "",
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    fontSize: {
      sm: ["14px", "157%"],
      base: ["16px", "150%"],
      lg: ["18px", "133%"],
    },
    extend: {
      fontFamily: {
        inter: ["Inter", "sans-serif"],
      },
      fontWeight: {
        medium: "500",
        semibold: "600",
        bold: "700",
        extrabold: "800",
      },
    },
  },
  plugins: [require("tw-animate-css")],
}
</file>

<file path="packages/core/package.json">
{
  "name": "@chainhackers/sdk-core",
  "description": "VanillaJS library for Betswirl protocol",
  "version": "0.1.1",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/chainhackers/sdk.git",
    "directory": "packages/core"
  },
  "type": "module",
  "module": "./dist/index.mjs",
  "types": "./dist/index.d.ts",
  "main": "./dist/index.cjs",
  "exports": {
    "import": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.mjs"
    },
    "require": {
      "types": "./dist/index.d.cts",
      "require": "./dist/index.cjs"
    }
  },
  "sideEffects": false,
  "scripts": {
    "gql:cleanup": "rimraf --glob \"./src/data/subgraphs/protocol/documents/**/*.ts\"",
    "gql": "graphql-codegen",
    "build": "rimraf ./dist && npm run gql && tsup --tsconfig tsconfig.build.json",
    "prepublishOnly": "cross-env NODE_ENV=production npm run build"
  },
  "contributors": ["kinco_dev"],
  "keywords": ["betswirl", "bet", "ethereum", "dapps", "casino", "web3"],
  "peerDependencies": {
    "@apollo/client": ">=3.12.11",
    "typescript": ">=5.0.4",
    "viem": "^2.29.2"
  },
  "peerDependenciesMeta": {
    "typescript": {
      "optional": true
    }
  },
  "files": ["dist"],
  "dependencies": {
    "decimal.js": "^10.5.0",
    "graphql-tag": "^2.12.6"
  },
  "devDependencies": {
    "@graphql-codegen/cli": "^5.0.4",
    "@graphql-codegen/client-preset": "^4.6.2",
    "@graphql-codegen/near-operation-file-preset": "^3.0.0",
    "@graphql-codegen/typescript": "^4.1.3",
    "@graphql-codegen/typescript-document-nodes": "^4.0.13",
    "@graphql-codegen/typescript-operations": "^4.4.1",
    "cross-env": "^7.0.3",
    "rimraf": "^6.0.1",
    "tsup": "^8.3.6"
  }
}
</file>

<file path="packages/providers/wagmi/package.json">
{
  "name": "@chainhackers/wagmi-provider",
  "description": "Wagmi client & wallet for Betswirl core SDK",
  "version": "0.1.1",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/chainhackers/sdk.git",
    "directory": "packages/providers/wagmi"
  },
  "type": "module",
  "module": "./dist/index.mjs",
  "types": "./dist/index.d.ts",
  "main": "./dist/index.cjs",
  "exports": {
    "import": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.mjs"
    },
    "require": {
      "types": "./dist/index.d.cts",
      "require": "./dist/index.cjs"
    }
  },
  "sideEffects": false,
  "scripts": {
    "build": "rimraf ./dist && tsup --tsconfig tsconfig.build.json",
    "prepublishOnly": "cross-env NODE_ENV=production npm run build"
  },
  "contributors": ["kinco_dev"],
  "keywords": ["betswirl", "wagmi", "casino", "web3"],
  "peerDependencies": {
    "@wagmi/core": ">=2.16.3"
  },
  "files": ["dist"],
  "dependencies": {
    "@chainhackers/sdk-core": "^0.1.1",
    "viem": "^2.29.2"
  },
  "devDependencies": {
    "cross-env": "^7.0.3",
    "rimraf": "^6.0.1",
    "tsup": "^8.3.6"
  }
}
</file>

<file path="package.json">
{
  "private": true,
  "name": "@chainhackers/sdk",
  "packageManager": "pnpm@10.10.0",
  "scripts": {
    "build": "pnpm turbo build",
    "build:libs": "pnpm turbo --filter \"./packages/**\" build",
    "build:libs:prod": "cross-env NODE_ENV=production pnpm build:libs",
    "change:add": "pnpm changeset add",
    "change:version": "pnpm changeset version && pnpm lint:fix",
    "change:publish": "pnpm build:libs:prod && pnpm changeset publish --no-git-tag",
    "lint": "biome check --diagnostic-level=error --max-diagnostics=200",
    "lint:fix": "biome check --write",
    "prepare": "husky"
  },
  "type": "module",
  "workspaces": ["packages/core", "packages/providers/*", "examples/*"],
  "engines": {
    "node": ">=20.11.1 <24",
    "npm": "please-use-pnpm",
    "pnpm": ">=8",
    "yarn": "please-use-pnpm"
  },
  "devDependencies": {
    "@biomejs/biome": "^1.9.4",
    "@changesets/changelog-github": "^0.5.1",
    "@changesets/cli": "^2.28.1",
    "cross-env": "^7.0.3",
    "husky": "^9.1.7",
    "turbo": "^2.4.4"
  }
}
</file>

<file path="examples/mini-app/src/components/game/InfoSheetPanel.stories.tsx">
import type { Meta, StoryObj } from "@storybook/react"
import { Info } from "lucide-react"
import React, { useState, useEffect, useRef } from "react"
import { cn } from "../../lib/utils"
import { Button } from "../ui/button"
import { Sheet, SheetTrigger } from "../ui/sheet"
import { InfoSheetPanel } from "./InfoSheetPanel"

interface PanelStoryWrapperProps {
  children: (container: HTMLDivElement) => React.ReactNode
  theme?: "light" | "dark" | "system"
}

const PanelStoryWrapper: React.FC<PanelStoryWrapperProps> = ({
  children,
  theme = "system",
}) => {
  const containerRef = useRef<HTMLDivElement>(null)
  const [isMounted, setIsMounted] = useState(false)

  useEffect(() => {
    setIsMounted(true)
  }, [])

  const themeClass = theme === "system" ? undefined : theme

  return (
    <div
      ref={containerRef}
      className={cn(
        "w-[328px] h-[512px] border rounded-[20px] p-3 relative overflow-hidden",
        "bg-card text-card-foreground",
        themeClass,
      )}
    >
      {isMounted && containerRef.current ? (
        children(containerRef.current)
      ) : (
        <p>Preparing story...</p>
      )}
      <p className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-muted-foreground text-center">
        This is a mock card container. <br /> Click the button to open the
        panel.
      </p>
    </div>
  )
}

const InfoSheetWithWrapper = ({
  winChance,
  rngFee,
  targetPayout,
  gasPrice,
  theme = "light",
}: {
  winChance: number
  rngFee: string | number
  targetPayout: string
  gasPrice: string
  theme?: "light" | "dark" | "system"
}) => {
  const [isOpen, setIsOpen] = useState(false)

  return (
    <PanelStoryWrapper theme={theme}>
      {(portalContainer) => (
        <Sheet open={isOpen} onOpenChange={setIsOpen}>
          <SheetTrigger asChild>
            <Button
              variant="iconTransparent"
              size="iconRound"
              className="absolute top-2 left-2 text-primary border-primary data-[state=open]:text-primary data-[state=open]:border-primary"
            >
              <Info className="h-4 w-4" />
            </Button>
          </SheetTrigger>
          <InfoSheetPanel
            portalContainer={portalContainer}
            winChance={winChance}
            rngFee={rngFee}
            targetPayout={targetPayout}
            gasPrice={gasPrice}
          />
        </Sheet>
      )}
    </PanelStoryWrapper>
  )
}

const meta = {
  title: "Game/Components/InfoSheetPanel",
  component: InfoSheetWithWrapper,
  parameters: {
    layout: "centered",
  },
  tags: ["autodocs"],
  argTypes: {
    winChance: { control: "number" },
    rngFee: { control: "text" },
    targetPayout: { control: "text" },
    gasPrice: { control: "text" },
    theme: {
      control: "radio",
      options: ["light", "dark", "system"],
    },
  },
  args: {
    winChance: 50,
    rngFee: "0",
    targetPayout: "1.94",
    gasPrice: "34.2123 gwei",
    theme: "light",
  },
} satisfies Meta<typeof InfoSheetWithWrapper>

export default meta
type Story = StoryObj<typeof meta>

export const Default: Story = {
  args: {
    winChance: 50,
    rngFee: "0",
    targetPayout: "1.94",
    gasPrice: "34.2123 gwei",
    theme: "light",
  },
  name: "Light Theme",
}

export const DarkThemeInfoPanel: Story = {
  args: {
    winChance: 75,
    rngFee: "0.01",
    targetPayout: "3.50",
    gasPrice: "40 gwei",
    theme: "dark",
  },
  name: "Dark Theme",
  parameters: {
    backgrounds: { default: "dark" },
  },
}

export const HighValues: Story = {
  args: {
    winChance: 90,
    rngFee: "100.12345",
    targetPayout: "1999.99",
    gasPrice: "1000.00005 gwei",
    theme: "light",
  },
  name: "High Values",
}
</file>

<file path="examples/mini-app/src/components/ui/sheet.tsx">
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"
import * as React from "react"

import { cn } from "../../lib/utils"

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />
}

function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />
}

function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />
}

function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />
}

function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className,
      )}
      {...props}
    />
  )
}

function SheetContent({
  className,
  children,
  side = "right",
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: "top" | "right" | "bottom" | "left"
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
          side === "right" &&
            "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm",
          side === "left" &&
            "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
          side === "top" &&
            "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b",
          side === "bottom" &&
            "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t",
          className,
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  )
}

function SheetHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  )
}

function SheetFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}

function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}

function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

type SheetBottomPanelContentProps = React.ComponentPropsWithoutRef<
  typeof SheetPrimitive.Content
>

const SheetBottomPanelContent = React.forwardRef<
  React.ComponentRef<typeof SheetPrimitive.Content>,
  SheetBottomPanelContentProps
>(({ className, children, ...props }, ref) => (
  <SheetPrimitive.Content
    ref={ref}
    className={cn(
      "bg-menu-bg data-[state=open]:animate-in data-[state=closed]:animate-out !absolute z-50 flex flex-col gap-0 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
      "!inset-x-0 !bottom-0 !w-full",
      "data-[state=closed]:!slide-out-to-bottom data-[state=open]:!slide-in-from-bottom",
      "rounded-t-[16px]",
      className,
    )}
    {...props}
  >
    {children}
    <SheetPrimitive.Close
      className={cn(
        "ring-offset-background focus:ring-ring data-[state=open]:bg-secondary",
        "absolute right-3 sm:right-4 rounded-sm opacity-70 transition-opacity hover:opacity-100",
        "focus:outline-none disabled:pointer-events-none bg-close-btn-hovered",
        "z-[60]",
        "-top-8",
      )}
    >
      <XIcon className="h-5 w-5 text-close-btn-color" />
      <span className="sr-only">Close</span>
    </SheetPrimitive.Close>
  </SheetPrimitive.Content>
))
SheetBottomPanelContent.displayName = "SheetBottomPanelContent"

export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
  SheetPortal,
  SheetOverlay,
  SheetBottomPanelContent,
}
</file>

<file path="examples/mini-app/src/main.tsx">
import { StrictMode } from "react"
import { createRoot } from "react-dom/client"
import "./index.css"
import App from "./App.tsx"
import { AppProviders } from "./providers.tsx"

createRoot(document.getElementById("root")!).render(
  <StrictMode>
    <AppProviders>
      <App />
    </AppProviders>
  </StrictMode>,
)
</file>

<file path="examples/mini-app/src/providers.tsx">
import { type ReactNode } from "react"
import { OnchainKitProvider } from "@coinbase/onchainkit"
import { base } from "wagmi/chains"
import { QueryClient, QueryClientProvider } from "@tanstack/react-query"
import { http, type Hex } from "viem"
import { createConfig, WagmiProvider } from "wagmi"
import { BettingConfigProvider } from "./context/BettingConfigContext.tsx"

const CHAIN = base

const queryClient = new QueryClient()

export function AppProviders({ children }: { children: ReactNode }) {
  const affiliate = import.meta.env.AFFILIATE_ADDRESS as Hex
  const rpcUrl = import.meta.env.VITE_RPC_URL
  const config = createConfig({
    chains: [CHAIN],
    transports: {
      [CHAIN.id]: http(rpcUrl),
    },
  })

  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        <OnchainKitProvider
          chain={CHAIN}
          config={{
            wallet: {
              display: "modal",
              termsUrl: "https://example.com/terms",
              privacyUrl: "https://example.com/privacy",
            },
            appearance: {
              name: "CoinToss Game",
              mode: "auto",
            },
          }}
        >
          <BettingConfigProvider value={{ affiliate }}>
            {children}
          </BettingConfigProvider>
        </OnchainKitProvider>
      </QueryClientProvider>
    </WagmiProvider>
  )
}
</file>

<file path=".github/workflows/storybook.yml">
name: Deploy Storybook

on:
  push:
    tags:
      - 'v*.*.*'

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./examples/mini-app

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '23'

      - name: Enable Corepack
        run: corepack enable

      - name: Install pnpm
        run: corepack use pnpm@latest-10

      - name: Install dependencies
        run: pnpm install --ignore-workspace

      - name: Build Storybook
        run: pnpm build-storybook

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: storybook-static
          path: examples/mini-app/storybook-static/
          retention-days: 30

      - name: Run Ansible playbook
        uses: dawidd6/action-ansible-playbook@v3
        with:
          playbook: .github/ansible/deploy.yml
          configuration: |
            [defaults]
            callbacks_enabled = ansible.posix.profile_tasks, ansible.posix.timer
            stdout_callback = yaml
            host_key_checking = False
          key: ${{ secrets.SSH_DEPLOY_KEY }}
          inventory: |
            [webservers]
            ${{ vars.DEPLOY_HOST }}
          known_hosts: ${{ vars.KNOWN_HOSTS }}
          options: |
            -u ${{ vars.DEPLOY_USER }}
            -v
</file>

<file path="examples/mini-app/src/components/game/HistorySheetPanel.stories.tsx">
import type { Meta, StoryObj } from "@storybook/react"
import { History as HistoryIcon } from "lucide-react"
import React, { useState, useEffect, useRef } from "react"
import { cn } from "../../lib/utils"
import { Button } from "../ui/button"
import { Sheet, SheetTrigger } from "../ui/sheet"
import { type HistoryEntry, HistorySheetPanel } from "./HistorySheetPanel"
import { TokenImage } from "@coinbase/onchainkit/token"
import { ETH_TOKEN } from "../../lib/tokens"

interface PanelStoryWrapperProps {
  children: (container: HTMLDivElement) => React.ReactNode
  theme?: "light" | "dark" | "system"
}

const PanelStoryWrapper: React.FC<PanelStoryWrapperProps> = ({
  children,
  theme = "system",
}) => {
  const containerRef = useRef<HTMLDivElement>(null)
  const [isMounted, setIsMounted] = useState(false)

  useEffect(() => {
    setIsMounted(true)
  }, [])

  const themeClass = theme === "system" ? undefined : theme

  return (
    <div
      ref={containerRef}
      className={cn(
        "w-[328px] h-[512px] border rounded-[20px] p-3 relative overflow-hidden",
        "bg-card text-card-foreground",
        themeClass,
      )}
    >
      {isMounted && containerRef.current ? (
        children(containerRef.current)
      ) : (
        <p>Preparing story...</p>
      )}
      <p className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-muted-foreground text-center">
        This is a mock card container. <br /> Click the button to open the
        panel.
      </p>
    </div>
  )
}

const mockHistoryDataDefault: HistoryEntry[] = [
  {
    id: "1",
    status: "Won bet",
    multiplier: 1.94,
    payoutAmount: "1.94675",
    payoutCurrencyIcon: <TokenImage token={ETH_TOKEN} size={14} />,
    timestamp: "~24h ago",
  },
  {
    id: "2",
    status: "Busted",
    multiplier: 1.2,
    payoutAmount: 0.0,
    payoutCurrencyIcon: <TokenImage token={ETH_TOKEN} size={14} />,
    timestamp: "~2h ago",
  },
]

const mockHistoryDataExtended: HistoryEntry[] = [
  ...mockHistoryDataDefault,
  ...Array.from({ length: 15 }, (_, i) => ({
    id: `ext-${i + 3}`,
    status: Math.random() > 0.5 ? ("Won bet" as const) : ("Busted" as const),
    multiplier: (Math.random() * 5 + 1).toFixed(2),
    payoutAmount: (Math.random() * 10).toFixed(4),
    payoutCurrencyIcon: <TokenImage token={ETH_TOKEN} size={14} />,
    timestamp: `~${i * 5 + 10}m ago`,
  })),
]

const HistorySheetWithWrapper = ({
  historyData,
  theme = "light",
}: {
  historyData: HistoryEntry[]
  theme?: "light" | "dark" | "system"
}) => {
  const [isOpen, setIsOpen] = useState(false)

  return (
    <PanelStoryWrapper theme={theme}>
      {(portalContainer) => (
        <Sheet open={isOpen} onOpenChange={setIsOpen}>
          <SheetTrigger asChild>
            <Button
              variant="iconTransparent"
              size="iconRound"
              className="absolute top-2 right-2 text-primary border-primary data-[state=open]:text-primary data-[state=open]:border-primary"
            >
              <HistoryIcon className="h-4 w-4" />
            </Button>
          </SheetTrigger>
          <HistorySheetPanel
            portalContainer={portalContainer}
            historyData={historyData}
          />
        </Sheet>
      )}
    </PanelStoryWrapper>
  )
}

const meta = {
  title: "Game/Components/HistorySheetPanel",
  component: HistorySheetWithWrapper,
  parameters: {
    layout: "centered",
  },
  tags: ["autodocs"],
  argTypes: {
    historyData: { control: "object" },
    theme: {
      control: "radio",
      options: ["light", "dark", "system"],
    },
  },
  args: {
    historyData: mockHistoryDataDefault,
    theme: "light",
  },
} satisfies Meta<typeof HistorySheetWithWrapper>

export default meta
type Story = StoryObj<typeof meta>

export const Default: Story = {
  args: {
    historyData: mockHistoryDataDefault,
    theme: "light",
  },
  name: "Light Theme",
}

export const DarkThemeHistoryPanel: Story = {
  args: {
    historyData: mockHistoryDataDefault,
    theme: "dark",
  },
  name: "Dark Theme",
  parameters: {
    backgrounds: { default: "dark" },
  },
}

export const ExtendedHistory: Story = {
  args: {
    historyData: mockHistoryDataExtended,
    theme: "light",
  },
  name: "Extended List",
}

export const EmptyHistory: Story = {
  args: {
    historyData: [],
    theme: "light",
  },
  name: "Empty",
}
</file>

<file path="examples/mini-app/src/components/game/InfoSheetPanel.tsx">
import { cn } from "../../lib/utils"
import { SheetBottomPanelContent, SheetOverlay, SheetPortal } from "../ui/sheet"

interface InfoSheetPanelProps {
  portalContainer: HTMLElement
  winChance: number
  rngFee: number | string
  targetPayout: string
  gasPrice: string
}

export function InfoSheetPanel({
  portalContainer,
  winChance,
  rngFee,
  targetPayout,
  gasPrice,
}: InfoSheetPanelProps) {
  return (
    <SheetPortal container={portalContainer}>
      <SheetOverlay className="!absolute !inset-0 !bg-black/60" />
      <SheetBottomPanelContent
        className={cn("!h-auto !max-h-[70%]", "p-5 sm:p-6")}
      >
        <div className="grid grid-cols-2 gap-x-4 sm:gap-x-6 gap-y-3 sm:gap-y-4 text-sm font-medium text-text-on-surface-variant">
          <div>
            <p>Win chance:</p>
            <p className="text-text-on-surface">{winChance}%</p>
          </div>
          <div>
            <p>RNG fee:</p>
            <p className="text-text-on-surface">{rngFee} ETH</p>
          </div>
          <div>
            <p>Target payout:</p>
            <p className="text-text-on-surface">{targetPayout} ETH</p>
          </div>
          <div>
            <p>Gas price:</p>
            <p className="text-text-on-surface">{gasPrice}</p>
          </div>
        </div>
      </SheetBottomPanelContent>
    </SheetPortal>
  )
}
</file>

<file path="examples/mini-app/src/components/ui/input.tsx">
import * as React from "react"

import { cn } from "../../lib/utils"

export interface TokenInfo {
  icon?: React.ReactNode
  symbol: string
}

export interface InputProps
  extends Omit<React.InputHTMLAttributes<HTMLInputElement>, "prefix"> {
  token?: TokenInfo
}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, token, ...props }, ref) => {
    const hasTokenInfo = token && (token.icon || token.symbol)

    return (
      <div
        className={cn(
          "relative flex h-12 w-full items-center text-sm",
          className,
        )}
      >
        <input
          type={type}
          data-slot="input"
          className={cn(
            "flex h-full w-full rounded-[12px] border-0",
            "bg-neutral-background text-foreground font-semibold",
            "px-4 py-2",
            hasTokenInfo ? "pr-16 md:pr-20" : "",
            "text-base placeholder:text-muted-foreground",
            "ring-offset-background focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-primary focus-visible:ring-offset-0",
            "disabled:cursor-not-allowed disabled:opacity-50",
          )}
          ref={ref}
          {...props}
        />
        {hasTokenInfo && (
          <div className="absolute right-0 top-1/2 mr-3 flex -translate-y-1/2 transform items-center gap-1 text-foreground pointer-events-none font-medium">
            {token.icon}
            <span>{token.symbol}</span>
          </div>
        )}
      </div>
    )
  },
)
Input.displayName = "Input"

export { Input }
</file>

<file path="examples/mini-app/src/components/game/HistorySheetPanel.tsx">
import React from "react"
import { cn } from "../../lib/utils"
import { ScrollArea } from "../ui/scroll-area"
import { SheetBottomPanelContent, SheetOverlay, SheetPortal } from "../ui/sheet"
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "../ui/table"

export interface HistoryEntry {
  id: string
  status: "Won bet" | "Busted"
  multiplier: number | string
  payoutAmount: number | string
  payoutCurrencyIcon: React.ReactElement
  timestamp: string
}

interface HistorySheetPanelProps {
  portalContainer: HTMLElement
  historyData: HistoryEntry[]
}

export function HistorySheetPanel({
  portalContainer,
  historyData,
}: HistorySheetPanelProps) {
  const isEmpty = historyData.length === 0

  return (
    <SheetPortal container={portalContainer}>
      <SheetOverlay className="!absolute !inset-0 !bg-black/60" />
      <SheetBottomPanelContent
        className={cn(
          isEmpty ? "!h-auto !max-h-[70%]" : "!h-[70%] !max-h-full",
          "p-0",
        )}
      >
        <ScrollArea className="h-full w-full rounded-t-[16px] overflow-hidden">
          <div className="p-1 pt-0">
            <Table className="text-sm font-medium">
              <TableHeader>
                <TableRow className="border-b border-table-separator">
                  <TableHead className="px-3 py-2.5 text-text-on-surface-variant top-0 bg-menu-bg">
                    Draw
                  </TableHead>
                  <TableHead className="px-3 py-2.5 text-right text-text-on-surface-variant top-0 bg-menu-bg">
                    X
                  </TableHead>
                  <TableHead className="px-3 py-2.5 text-right text-text-on-surface-variant top-0 bg-menu-bg">
                    Payout
                  </TableHead>
                  <TableHead className="px-3 py-2.5 text-right text-text-on-surface-variant top-0 bg-menu-bg">
                    Time
                  </TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {isEmpty ? (
                  <TableRow className="border-b-0">
                    <TableCell
                      colSpan={4}
                      className="px-3 py-6 text-left align-top"
                    >
                      <div>
                        <p className="text-base text-card-foreground font-semibold">
                          No bets currently
                        </p>
                        <p className="text-sm text-muted-foreground mt-1 font-medium">
                          Play the game to make your first bet
                        </p>
                      </div>
                    </TableCell>
                  </TableRow>
                ) : (
                  historyData.map((entry) => (
                    <TableRow
                      key={entry.id}
                      className="border-b border-table-separator last:border-b-0"
                    >
                      <TableCell
                        className={cn(
                          "px-3 py-2.5",
                          entry.status === "Won bet"
                            ? "text-game-win"
                            : "text-game-loss",
                        )}
                      >
                        {entry.status}
                      </TableCell>
                      <TableCell className="px-3 py-2.5 text-right text-table-text">
                        {entry.multiplier}
                      </TableCell>
                      <TableCell className="px-3 py-2.5 text-table-text">
                        <div className="flex items-center justify-end gap-1">
                          <span>{entry.payoutAmount}</span>
                          {entry.payoutCurrencyIcon}
                        </div>
                      </TableCell>
                      <TableCell className="px-3 py-2.5 text-right text-text-on-surface-variant">
                        {entry.timestamp}
                      </TableCell>
                    </TableRow>
                  ))
                )}
              </TableBody>
            </Table>
          </div>
        </ScrollArea>
      </SheetBottomPanelContent>
    </SheetPortal>
  )
}
</file>

<file path="examples/mini-app/src/hooks/usePlaceBet.ts">
import { useState, useCallback, useEffect } from "react"
import { Hex, zeroAddress, decodeEventLog } from "viem"
import { useAccount, usePublicClient, useWriteContract } from "wagmi"
import { useOnchainKit } from "@coinbase/onchainkit"
import {
  GenericCasinoBetParams,
  CasinoChainId,
  getChainlinkVrfCostFunctionData,
  getPlaceBetFunctionData,
  getPlaceBetEventData,
  getRollEventData,
  CoinToss,
  COINTOSS_FACE,
  CASINO_GAME_TYPE,
} from "@betswirl/sdk-core"
import { useBetResultWatcher } from "./useBetResultWatcher"
import type { GameResult, WatchTarget } from "./types"
import { createLogger } from "../lib/logger"

const logger = createLogger("usePlaceBet")

interface SubmitBetResult {
  txHash: Hex
  contractAddress: Hex
}

export function usePlaceBet() {
  const { chain } = useOnchainKit()
  const chainId = chain?.id as CasinoChainId | undefined
  const publicClient = usePublicClient({ chainId })
  const { address: connectedAddress } = useAccount()
  const { writeContractAsync, reset: resetWagmiWriteContract } =
    useWriteContract()

  const [betStatus, setBetStatus] = useState<
    "pending" | "success" | "error" | null
  >(null)
  const [gameResult, setGameResult] = useState<GameResult | null>(null)
  const [watchTarget, setWatchTarget] = useState<WatchTarget | null>(null)

  const {
    gameResult: watcherGameResult,
    status: watcherStatus,
    reset: resetWatcher,
  } = useBetResultWatcher({
    watchParams: watchTarget,
    publicClient,
    enabled: !!watchTarget,
  })

  useEffect(() => {
    if (watcherStatus === "success" && watcherGameResult) {
      setGameResult(watcherGameResult)
      setBetStatus("success")
      logger.debug("watcher: Bet resolved: SUCCESS", {
        gameResult: watcherGameResult,
      })
    } else if (watcherStatus === "error") {
      setBetStatus("error")
      logger.debug("watcher: Bet resolved: ERROR from watcher")
    }
  }, [watcherStatus, watcherGameResult])

  const placeBet = useCallback(
    async (betAmount: bigint, choice: COINTOSS_FACE) => {
      try {
        resetWagmiWriteContract()
        setGameResult(null)
        setWatchTarget(null)
        resetWatcher()

        const betParams = {
          game: CASINO_GAME_TYPE.COINTOSS,
          gameEncodedInput: CoinToss.encodeInput(choice),
          betAmount,
        }

        if (
          !publicClient ||
          !chainId ||
          !connectedAddress ||
          !writeContractAsync
        ) {
          logger.error(
            "placeBet: Wagmi/OnchainKit clients or address are not initialized.",
          )
          setBetStatus("error")
          return
        }
        logger.debug("placeBet: Starting bet process:", {
          betParams,
          connectedAddress,
        })
        setBetStatus("pending")

        const vrfCost = await _fetchVrfCost(
          betParams.game,
          chainId,
          publicClient,
        )

        const submitResult = await _submitBetTransaction(
          betParams,
          connectedAddress,
          vrfCost,
          chainId,
          writeContractAsync,
        )
        const { txHash, contractAddress } = submitResult

        const betId = await _extractBetIdFromReceipt(
          txHash,
          contractAddress,
          betParams.game,
          chainId,
          connectedAddress,
          publicClient,
        )

        if (!betId) {
          logger.error(
            "placeBet: Bet ID was not extracted. Roll event listener will not be started.",
          )
          setBetStatus("error")
          return
        }

        const { data: rollEventData } = getRollEventData(
          betParams.game,
          chainId,
          betId,
        )
        logger.debug("placeBet: Setting up Roll event listener...")
        setWatchTarget({
          betId,
          contractAddress,
          gameType: betParams.game,
          eventAbi: rollEventData.abi,
          eventName: rollEventData.eventName,
          eventArgs: rollEventData.args,
        })
      } catch (error) {
        logger.error("placeBet: Error placing bet:", error)
        setBetStatus("error")
      }
    },
    [
      publicClient,
      chainId,
      connectedAddress,
      writeContractAsync,
      resetWagmiWriteContract,
      resetWatcher,
    ],
  )

  const resetBetState = useCallback(() => {
    setBetStatus(null)
    setGameResult(null)
    setWatchTarget(null)
    resetWatcher()
  }, [resetWatcher])

  return { placeBet, betStatus, gameResult, resetBetState }
}

async function _fetchVrfCost(
  gameType: CASINO_GAME_TYPE,
  chainId: CasinoChainId,
  publicClient: ReturnType<typeof usePublicClient>,
): Promise<bigint> {
  if (!publicClient) {
    logger.error("_fetchVrfCost: publicClient is undefined")
    throw new Error("publicClient is undefined")
  }
  logger.debug("_fetchVrfCost: Getting VRF cost...")
  const vrfCostFunctionData = getChainlinkVrfCostFunctionData(
    gameType,
    zeroAddress,
    1,
    chainId,
  )
  const vrfCost = (await publicClient.readContract({
    address: vrfCostFunctionData.data.to,
    abi: vrfCostFunctionData.data.abi,
    functionName: vrfCostFunctionData.data.functionName,
    args: vrfCostFunctionData.data.args,
  })) as bigint
  logger.debug("_fetchVrfCost: VRF cost received:", vrfCost?.toString())
  return vrfCost
}

async function _submitBetTransaction(
  betParams: GenericCasinoBetParams,
  receiver: Hex,
  vrfCost: bigint,
  chainId: CasinoChainId,
  writeContractAsync: ReturnType<typeof useWriteContract>["writeContractAsync"],
): Promise<SubmitBetResult> {
  logger.debug("_submitBetTransaction: Preparing and sending transaction...")
  const placeBetTxData = getPlaceBetFunctionData(
    { ...betParams, receiver },
    chainId,
  )
  const txHash = await writeContractAsync({
    abi: placeBetTxData.data.abi,
    address: placeBetTxData.data.to,
    functionName: placeBetTxData.data.functionName,
    args: placeBetTxData.data.args,
    value: placeBetTxData.extraData.getValue(betParams.betAmount + vrfCost),
  })
  logger.debug("_submitBetTransaction: Transaction sent, hash:", txHash)
  return {
    txHash,
    contractAddress: placeBetTxData.data.to,
  }
}

async function _extractBetIdFromReceipt(
  txHash: Hex,
  expectedContractAddress: Hex,
  gameType: CASINO_GAME_TYPE,
  chainId: CasinoChainId,
  receiver: Hex,
  publicClient: ReturnType<typeof usePublicClient>,
): Promise<bigint | null> {
  if (!publicClient) {
    logger.error("_extractBetIdFromReceipt: publicClient is undefined")
    throw new Error("publicClient is undefined")
  }
  logger.debug("_extractBetIdFromReceipt: Waiting for receipt for", txHash)
  const receipt = await publicClient.waitForTransactionReceipt({ hash: txHash })
  logger.debug("_extractBetIdFromReceipt: Receipt received.")

  const { data: placeBetEventData } = getPlaceBetEventData(
    gameType,
    chainId,
    receiver,
  )

  for (const log of receipt.logs) {
    if (log.address.toLowerCase() !== expectedContractAddress.toLowerCase())
      continue
    const decodedLog = decodeEventLog({
      abi: placeBetEventData.abi,
      data: log.data,
      topics: log.topics,
      strict: false,
    })
    if (decodedLog.eventName === placeBetEventData.eventName) {
      return (decodedLog.args as unknown as { id: bigint }).id
    }
  }
  logger.error("_extractBetIdFromReceipt: Bet ID not found in receipt.")
  return null
}
</file>

<file path="examples/mini-app/package.json">
{
  "name": "@chainhackers/ui",
  "repository": {
    "type": "git",
    "url": "https://github.com/chainhackers/sdk.git",
    "directory": "examples/mini-app"
  },
  "version": "0.0.3",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "storybook": "storybook dev -p 6006",
    "build-storybook": "storybook build",
    "format": "prettier --write .",
    "test:loki": "pnpm loki test --chromeTolerance 1",
    "prepublishOnly": "pnpm build"
  },
  "dependencies": {
    "@betswirl/sdk-core": "^0.1.2-beta.3",
    "@coinbase/onchainkit": "^0.38.13",
    "@radix-ui/react-dialog": "^1.1.13",
    "@radix-ui/react-label": "^2.1.4",
    "@radix-ui/react-popover": "^1.1.11",
    "@radix-ui/react-scroll-area": "^1.2.8",
    "@radix-ui/react-slider": "^1.3.2",
    "@radix-ui/react-slot": "^1.2.0",
    "@tailwindcss/vite": "^4.1.5",
    "@tanstack/react-query": "^5.75.6",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "loki": "^0.35.1",
    "lucide-react": "^0.503.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "tailwind-merge": "^3.2.0",
    "tailwindcss": "^4.1.5",
    "viem": "^2.29.2",
    "wagmi": "^2.15.2"
  },
  "devDependencies": {
    "@chromatic-com/storybook": "^3",
    "@eslint/js": "^9.22.0",
    "@storybook/addon-essentials": "8.2.9",
    "@storybook/addon-onboarding": "8.2.9",
    "@storybook/blocks": "8.2.9",
    "@storybook/react": "8.2.9",
    "@storybook/react-vite": "8.2.9",
    "@storybook/test": "8.2.9",
    "@types/node": "^22.15.3",
    "@types/react": "^19.0.10",
    "@types/react-dom": "^19.0.4",
    "@vitejs/plugin-react": "^4.3.4",
    "@vitest/browser": "^3.1.2",
    "@vitest/coverage-v8": "^3.1.2",
    "eslint": "^9.22.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "eslint-plugin-storybook": "^0.12.0",
    "globals": "^16.0.0",
    "playwright": "^1.52.0",
    "prettier": "3.5.3",
    "storybook": "^8.6.12",
    "tw-animate-css": "^1.2.8",
    "typescript": "~5.7.2",
    "typescript-eslint": "^8.26.1",
    "vite": "^6.3.1",
    "vitest": "^3.1.2"
  },
  "eslintConfig": {
    "extends": [
      "plugin:storybook/recommended"
    ]
  },
  "loki": {
    "configurations": {
      "chrome.laptop": {
        "target": "chrome.docker",
        "width": 1366,
        "height": 768,
        "deviceScaleFactor": 1,
        "mobile": false
      },
      "chrome.iphone7": {
        "target": "chrome.docker",
        "preset": "iPhone 7"
      }
    }
  }
}
</file>

<file path="examples/mini-app/src/components/game/CoinTossGame.stories.tsx">
import type { Meta, StoryObj } from "@storybook/react"
import { CoinTossGame } from "./CoinTossGame"
import gameBg from "../../assets/game/game-background-1.png"
import { AppProviders } from "../../../src/providers"

const meta = {
  title: "Game/CoinTossGame",
  component: CoinTossGame,
  parameters: {
    layout: "centered",
    backgrounds: {
      default: "light",
      values: [
        { name: "light", value: "#FFFFFF" },
        { name: "dark", value: "oklch(0.15 0 0)" },
      ],
    },
    loki: {
      skip: true,
    },
  },
  decorators: [
    (Story) => (
      <AppProviders>
        <Story />
      </AppProviders>
    ),
  ],
  tags: ["autodocs"],
  argTypes: {
    theme: {
      control: "radio",
      options: ["light", "dark", "system"],
    },
    customTheme: {
      control: "object",
      description: "Custom theme",
      table: {
        type: {
          summary: "object",
          detail: `{
            "--primary": string,
            "--play-btn-font": string,
            "--game-window-overlay": string,
          }`,
        },
      },
    },
    backgroundImage: {
      control: "file",
      description: "Background image",
      accept: "image/*",
    },
  },
} satisfies Meta<typeof CoinTossGame>

export default meta
type Story = StoryObj<typeof meta>

const Template: Story = {
  render: (args) => <CoinTossGame {...args} />,
}

export const LightTheme: Story = {
  ...Template,
  args: {
    theme: "light",
  },
}

export const DarkTheme: Story = {
  ...Template,
  args: {
    theme: "dark",
  },
  parameters: {
    backgrounds: { default: "dark" },
  },
}

export const SystemTheme: Story = {
  ...Template,
  args: {
    theme: "system",
  },
}

export const CustomTheme1: Story = {
  ...Template,
  args: {
    theme: "light",
    customTheme: {
      "--primary": "#4dae52",
      "--play-btn-font": "#1B5E20",
      "--game-window-overlay": "oklch(0 0 0 / 40%)",
    } as React.CSSProperties,
  },
}

export const CustomTheme2: Story = {
  ...Template,
  args: {
    theme: "light",
    customTheme: {
      "--primary": "#6AB3D3",
      "--play-btn-font": "#ffffff",
      "--game-window-overlay": "oklch(0 0 0 / 10%)",
    } as React.CSSProperties,
    backgroundImage: gameBg,
  },
}
</file>

<file path="examples/mini-app/src/index.css">
@import "tailwindcss";
@import "tw-animate-css";

@theme inline {
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary-border: var(--secondary-border);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-control-panel-background: var(--control-panel-background);
  --color-transparent-button-border: var(--transparent-button-border);
  --color-neutral-background: var(--neutral-background);
  --color-game-win: var(--game-win);
  --color-game-loss: var(--game-loss);
  --color-play-btn-font: var(--play-btn-font);
  --color-title-color: var(--title-color);
  --color-text-on-surface-variant: var(--text-on-surface-variant);
  --color-text-on-surface: var(--text-on-surface);
  --color-border-stroke: var(--border-stroke);
  --color-game-window-overlay: var(--game-window-overlay);
  --color-menu-bg: var(--menu-bg);
  --color-table-separator: var(--table-separator);
  --color-close-btn-color: var(--close-btn-color);
  --color-close-btn-hovered: var(--close-btn-hovered);
  --color-game-result-icon-bg: var(--game-result-icon-bg);
  --color-table-text: var(--table-text);
}

@layer base {
  :root {
    --light-surface: oklch(0.98 0.0017 247.84);
    --dark-surface: oklch(0.15 0.0066 236.83);
    --light-stroke: oklch(0.16 0.02 269.69 / 8%);
    --dark-stroke: oklch(1 0 0 / 8%);
    --dark-on-surface-variant: oklch(0.78 0.0129 276.04);
    --white: oklch(1 0 0);
    --dark-gray: oklch(0.25 0 0);
    --dark-surface-high: oklch(0.24 0.0059 236.8);

    --radius: 0.625rem;
    --radius-sm: 0.375rem;
    --radius-md: 0.5rem;
    --radius-lg: 0.625rem;
    --radius-xl: 0.875rem;

    --background: var(--white);
    --foreground: oklch(0.1 0 0 / 0.87);

    --card: var(--light-surface);
    --card-foreground: oklch(0.1 0 0 / 0.87);

    --popover: var(--light-surface);
    --popover-foreground: oklch(0.1 0 0 / 0.87);

    --primary: oklch(0.66 0.1519 255.97);
    --primary-foreground: var(--dark-surface);

    --secondary: oklch(0.86 0.0043 271.36);
    --secondary-foreground: oklch(0.1 0 0 / 0.8);
    --secondary-border: oklch(0.81 0.0057 274.95);

    --muted: oklch(0.97 0.0029 264.54);
    --muted-foreground: oklch(0.4 0 0 / 0.7);

    --accent: oklch(0.97 0.0029 264.54);
    --accent-foreground: oklch(0.1 0 0 / 0.87);

    --destructive: oklch(0.577 0.245 27.325 / 0.9);
    --destructive-foreground: var(--white);

    --border: oklch(0.93 0.0058 264.53);
    --input: oklch(0.16 0.02 269.69 / 10%);
    --ring: transparent;

    --chart-1: oklch(0.646 0.222 41.116);
    --chart-2: oklch(0.6 0.118 184.704);
    --chart-3: oklch(0.398 0.07 227.392);
    --chart-4: oklch(0.828 0.189 84.429);
    --chart-5: oklch(0.769 0.188 70.08);

    --control-panel-background: var(--light-stroke);
    --transparent-button-border: oklch(0.91 0.0029 264.54 / 11.37%);
    --neutral-background: oklch(0.16 0.02 269.69 / 10%);

    --title-color: var(--dark-surface);
    --text-on-surface-variant: oklch(0.61 0.014 271.18);
    --text-on-surface: oklch(0.34 0.0139 235.28);
    --border-stroke: var(--light-stroke);
    --game-window-overlay: oklch(0 0 0 / 40%);
    --play-btn-font: var(--white);

    --game-win: oklch(0.71 0.1322 165.92);
    --game-loss: oklch(0.63 0.1893 23.38);

    --menu-bg: var(--light-surface);
    --table-separator: var(--light-stroke);
    --close-btn-color: var(--light-surface);
    --close-btn-hovered: var(--dark-stroke);
    --game-result-icon-bg: var(--white);
    --table-text: var(--dark-surface);
  }

  .dark {
    --background: oklch(0.15 0 0);
    --foreground: oklch(0.9 0 0);
    --card: var(--dark-surface);
    --card-foreground: oklch(0.9 0 0);
    --popover: oklch(0.18 0 0);
    --popover-foreground: oklch(0.9 0 0);
    --primary: oklch(0.66 0.1519 255.97);
    --primary-foreground: oklch(0.98 0 0);
    --secondary: oklch(1 0 0 / 10%);
    --secondary-foreground: oklch(0.9 0 0);
    --secondary-border: var(--dark-gray);
    --muted: var(--dark-gray);
    --muted-foreground: oklch(0.6 0 0);
    --accent: var(--dark-gray);
    --accent-foreground: oklch(0.9 0 0);
    --destructive: oklch(0.577 0.245 27.325);
    --destructive-foreground: oklch(0.9 0 0);
    --border: oklch(0.3 0 0 / 0.5);
    --input: oklch(1 0 0 / 10%);
    --ring: transparent;
    --chart-1: oklch(0.646 0.222 41.116);
    --chart-2: oklch(0.6 0.118 184.704);
    --chart-3: oklch(0.398 0.07 227.392);
    --chart-4: oklch(0.828 0.189 84.429);
    --chart-5: oklch(0.769 0.188 70.08);

    --control-panel-background: var(--dark-stroke);
    --transparent-button-border: var(--dark-gray);
    --neutral-background: oklch(1 0 0 / 10%);
    --title-color: var(--white);
    --text-on-surface-variant: var(--dark-on-surface-variant);
    --text-on-surface: oklch(0.93 0.0058 264.53);
    --border-stroke: var(--dark-stroke);
    --play-btn-font: var(--white);

    --game-win: oklch(0.78 0.1418 166.22);

    --menu-bg: var(--dark-surface-high);
    --table-separator: var(--dark-stroke);
    --close-btn-color: var(--dark-on-surface-variant);
    --game-result-icon-bg: var(--dark-surface-high);
    --table-text: var(--white);
  }

  @font-face {
    font-family: "Inter";
    font-style: normal;
    font-weight: 500;
    font-display: swap;
    src: url("./assets/fonts/Inter-Medium.woff2") format("woff2");
  }

  @font-face {
    font-family: "Inter";
    font-style: normal;
    font-weight: 600;
    font-display: swap;
    src: url("./assets/fonts/Inter-SemiBold.woff2") format("woff2");
  }

  @font-face {
    font-family: "Inter";
    font-style: normal;
    font-weight: 700;
    font-display: swap;
    src: url("./assets/fonts/Inter-Bold.woff2") format("woff2");
  }

  .game-global-styles {
    font-family: "Inter", sans-serif;
    font-weight: 500;

    /* Hide arrows for input[type=number] */
    /* Chrome, Safari, Edge, Opera */
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    /* Firefox */
    input[type="number"] {
      -moz-appearance: textfield;
      appearance: textfield;
    }
  }

  body {
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }
}

@layer components {
  @import "@coinbase/onchainkit/styles.css";
}
</file>

<file path="examples/mini-app/src/components/game/CoinTossGame.tsx">
import React from "react"
import coinTossBackground from "../../assets/game/game-background.png"
import { cn } from "../../lib/utils"

import { ConnectWallet, Wallet } from "@coinbase/onchainkit/wallet"
import { Avatar, Name } from "@coinbase/onchainkit/identity"
import { TokenImage } from "@coinbase/onchainkit/token"
import { useAccount, useBalance } from "wagmi"
import { formatEther, formatUnits, parseEther } from "viem"

import { type HistoryEntry } from "./HistorySheetPanel"
import { ETH_TOKEN } from "../../lib/tokens"

import { usePlaceBet } from "../../hooks/usePlaceBet"
import { COINTOSS_FACE } from "@betswirl/sdk-core"
import { GameFrame } from "./GameFrame"

export interface CoinTossGameProps
  extends React.HTMLAttributes<HTMLDivElement> {
  theme?: "light" | "dark" | "system"
  customTheme?: {
    "--primary"?: string
    "--play-btn-font"?: string
    "--game-window-overlay"?: string
  } & React.CSSProperties
  backgroundImage?: string
}

const mockHistoryData: HistoryEntry[] = [
  {
    id: "1",
    status: "Won bet",
    multiplier: 1.94,
    payoutAmount: "1.94675",
    payoutCurrencyIcon: <TokenImage token={ETH_TOKEN} size={14} />,
    timestamp: "~24h ago",
  },
  {
    id: "2",
    status: "Won bet",
    multiplier: 1.2,
    payoutAmount: 0.2,
    payoutCurrencyIcon: <TokenImage token={ETH_TOKEN} size={14} />,
    timestamp: "~2h ago",
  },
  {
    id: "3",
    status: "Busted",
    multiplier: 1.94,
    payoutAmount: 1.94,
    payoutCurrencyIcon: <TokenImage token={ETH_TOKEN} size={14} />,
    timestamp: "~2h ago",
  },
  {
    id: "4",
    status: "Won bet",
    multiplier: 1.946,
    payoutAmount: 2.453,
    payoutCurrencyIcon: <TokenImage token={ETH_TOKEN} size={14} />,
    timestamp: "~2h ago",
  },
  {
    id: "5",
    status: "Busted",
    multiplier: 1.94,
    payoutAmount: 1.94,
    payoutCurrencyIcon: <TokenImage token={ETH_TOKEN} size={14} />,
    timestamp: "~2h ago",
  },
  {
    id: "6",
    status: "Won bet",
    multiplier: 1.946,
    payoutAmount: 2.453,
    payoutCurrencyIcon: <TokenImage token={ETH_TOKEN} size={14} />,
    timestamp: "~2h ago",
  },
  {
    id: "7",
    status: "Won bet",
    multiplier: 1.94,
    payoutAmount: 0.1,
    payoutCurrencyIcon: <TokenImage token={ETH_TOKEN} size={14} />,
    timestamp: "~2h ago",
  },
  {
    id: "8",
    status: "Won bet",
    multiplier: 1.94,
    payoutAmount: 0.1,
    payoutCurrencyIcon: <TokenImage token={ETH_TOKEN} size={14} />,
    timestamp: "~2h ago",
  },
  {
    id: "9",
    status: "Won bet",
    multiplier: 1.94,
    payoutAmount: 0.1,
    payoutCurrencyIcon: <TokenImage token={ETH_TOKEN} size={14} />,
    timestamp: "~2h ago",
  },
]

export function CoinTossGame({
  theme = "system",
  customTheme,
  backgroundImage = coinTossBackground,
  ...props
}: CoinTossGameProps) {
  const themeSettings = { theme, customTheme, backgroundImage }
  const { isConnected: isWalletConnected, address } = useAccount()
  const { data: balance } = useBalance({
    address,
  })
  const balanceFloat = balance
    ? parseFloat(formatUnits(balance.value, balance.decimals))
    : 0

  const tokenDecimals = balance?.decimals ?? 18

  const { placeBet, betStatus, gameResult, resetBetState } = usePlaceBet()
  const isInGameResultState = !!gameResult

  const handlePlayButtonClick = (betAmount: string) => {
    if (betStatus === "error") {
      resetBetState()
      placeBet(parseEther(betAmount), COINTOSS_FACE.HEADS)
    } else if (isInGameResultState) {
      resetBetState()
    } else {
      placeBet(parseEther(betAmount), COINTOSS_FACE.HEADS)
    }
  }

  const gameResultFormatted = gameResult
    ? {
        ...gameResult,
        payout: Number(formatEther(gameResult.payout)),
      }
    : null

  return (
    <GameFrame
      {...props}
      onPlayBtnClick={handlePlayButtonClick}
      historyData={mockHistoryData}
      tokenDecimals={tokenDecimals}
      themeSettings={themeSettings}
      isConnected={isWalletConnected}
      balance={balanceFloat}
      gameResult={gameResultFormatted}
      betStatus={betStatus}
      connectWallletBtn={
        <Wallet>
          <ConnectWallet
            className={cn(
              "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-semibold ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
              "bg-neutral-background",
              "rounded-[12px]",
              "border border-border-stroke",
              "px-3 py-1.5 h-[44px]",
              "text-primary",
            )}
            disconnectedLabel="Connect"
          >
            <div className="flex items-center">
              <Avatar
                className="h-7 w-7 mr-2"
                address="0x838aD0EAE54F99F1926dA7C3b6bFbF617389B4D9"
              />
              <Name className="text-title-color" />
            </div>
          </ConnectWallet>
        </Wallet>
      }
    />
  )
}
</file>

</files>
